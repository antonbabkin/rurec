---
title: "Industry-Health"
editor: source
format:
  html:
    toc: true
    toc-depth: 4
    self-contained: true
    page-layout: full
    code-fold: true
    code-tools: true
---


# setup

```{r include = FALSE}



source("projects/industry_health/dataprep.R", local = (ih_dp <- new.env()))
source("datasets/circularity/circularity.R", local = (circularity <- new.env()))
source("R/geography.R", local = (geo <- new.env()))
source("R/basic_utilities.R", local = (util <- new.env()))

# install.packages("vtable")
# install.packages("dplyr")
# install.packages("tidyverse")
# install.packages("ggplot2")
# install.packages("stringr")
# install.packages("spdep")
#install.packages("tidycensus")
# install.packages("tigris")
# install.packages("viridis")
# install.packages("cowplot")
# install.packages("estimatr")
# install.packages("huxtable")
# #install.packages("margins")
# install.packages(c("lmtest", "sandwich"))
# install.packages("spatialreg")
 # install.packages("gridExtra")
 # install.packages("rgeoda") 
 # install.packages("spgwr")
 # install.packages("lavaan")
 # install.packages("lavaanPlot")
#install.packages("ggthemes")
# install.packages("sesem")


library(vtable)
library(dplyr)
library(tidyverse)
library(ggplot2)
library(spdep)
library(tidycensus)
library(tigris)
library(viridis)
library(cowplot)
library(lmtest)
library(sandwich)
library(estimatr)
library(huxtable)
#library(margins)
library(spatialreg)
library(logger)
library(moments)
library(PerformanceAnalytics)
library(correlation)
library(estimatr)
library(Hmisc)
library(rstatix)
library(glue)
library(sf)
library(units)
library(leaflet)
library(htmltools)
library(tmap)
library(gridExtra)
library(tidycensus) 
library(rgeoda) 
library(spgwr)
library(lavaan)
library(lavaanPlot)
library(ggeffects)
library(patchwork)
library(ggthemes)
library(sesem)

# chunk behavior 
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 

# nonscientific notation
options(scipen=999)

# log output 
log_threshold(WARN)



##Load Hard Coded Data Sets 

##Median Age of County 2012
age = get_acs(geography = "county",
                   survey = "acs5",
                   variables = c("S0101_C01_030E"
                   ),
                   year = 2012) %>%
  select("place"=GEOID, "age"=estimate)

##pct over 65
age = get_acs(geography = "county",
                   survey = "acs5",
                   variables = c("S0101_C01_028E"
                   ),
                   year = 2012) %>%
  mutate(age = estimate/100) %>%
  select("place"=GEOID, age)


##% College degree or more
bach = get_acs(geography = "county",
                   survey = "acs5",
                   variables = c("S1501_C02_012E"
                   ),
                   year = 2012) %>%
  mutate(bach = estimate/100) %>%
  select("place"=GEOID, bach)




##ERS County Typologies 

ers = read.csv("https://www.ers.usda.gov/webdocs/DataFiles/48652/2015CountyTypologyCodes.csv?v=8831.8") %>%
  mutate(place = sprintf("%05d", FIPStxt)) %>%
  select(place, "ers_ag"=Farming_2015_Update, "ers_mine"=Mining_2015.Update, "ers_mfg"=Manufacturing_2015_Update, "ers_gov"=Government_2015_Update, "ers_rec"=Recreation_2015_Update, "ers_nonsp"=Nonspecialized_2015_Update)



# ##Industry Structure
# 
# industry = get_acs(geography = "county",
#                    survey = "acs5",
#                    variables = c("DP03_0032E","DP03_0033E","DP03_0034E"
#                                         ,"DP03_0035E","DP03_0036E","DP03_0037E"
#                                         ,"DP03_0038E","DP03_0039E","DP03_0040E"
#                                         ,"DP03_0041E","DP03_0042E","DP03_0043E"
#                                         ,"DP03_0044E","DP03_0045E"
#                    ),
#                    year = 2012) %>%
#   select("place"=GEOID, variable, estimate) %>%
#   pivot_wider(names_from = variable, values_from = estimate) %>%
#   mutate(pct_afm = DP03_0033/DP03_0032, pct_mfg = DP03_0034/DP03_0032, pct_fire = DP03_0039/DP03_0032, pct_edmed = DP03_0041/DP03_0032, pct_rec = DP03_0042/DP03_0032, pct_gov = DP03_0044/DP03_0032) %>%
#   select(place, pct_afm, pct_mfg, pct_fire, pct_edmed, pct_rec, pct_gov)


# unzip datapacks
# util$zip_unpack("tmp/datapack_bea_io_v240709.zip", overwrite = TRUE)
# util$zip_unpack("tmp/datapack_cbp_v240709.zip", overwrite = TRUE)
# util$zip_unpack("tmp/datapack_infogroup_county_v240709.zip", overwrite = TRUE)
# util$zip_unpack("tmp/datapack_agcen_v240709.zip", overwrite = TRUE)

```

```{r}

# # not working
# abc = ih_dp$call_agcensus12()

# https://www.nass.usda.gov/datasets/qs.census2012.txt.gz
agc_clean = read.delim2("data/projects/industry_health/jobs/qs.census2012.txt") #import ag census
# https://www2.census.gov/programs-surveys/cbp/datasets/2012/cbp12co.zip
jobs_clean <- read_delim("data/projects/industry_health/jobs/cbp12co.txt") #import cbp

agwork = agc_clean %>%
  filter(AGG_LEVEL_DESC == "COUNTY" & SHORT_DESC == "LABOR, HIRED, GE 150 DAYS - NUMBER OF WORKERS" & DOMAIN_DESC == "TOTAL") %>%
  mutate(place = str_c(sprintf("%02d",STATE_FIPS_CODE),"",sprintf("%03d",COUNTY_CODE)), agwork = as.numeric(gsub(",","",VALUE))) %>%
  select(place, agwork)


agops = agc_clean %>%
  filter(AGG_LEVEL_DESC == "COUNTY" & SHORT_DESC == "OPERATORS, (ALL) - NUMBER OF OPERATORS") %>%
  mutate(place = str_c(sprintf("%02d",STATE_FIPS_CODE),"",sprintf("%03d",COUNTY_CODE)), agops = as.numeric(gsub(",","",VALUE))) %>%
  select(place, agops)

agc = agwork %>%
  left_join(y=agops, by="place") %>%
  mutate(agwork = ifelse(is.na(agwork), 0, agwork), agops = ifelse(is.na(agops), 0, agwork), ag_emp = agwork + agops) %>%
  select(place, ag_emp)

jobs = jobs_clean %>%
  filter(naics != "------") %>%
  mutate(naicsfilt = substr(naics,3,3), place = str_c(fipstate,"",fipscty)) %>%
  filter(naicsfilt == "-") %>%
  mutate(naics = str_c("n","",substr(naics,1,2))) %>%
  select(place, naics, emp) %>%
  pivot_wider(names_from = naics, values_from = emp)

jobs_temp = jobs_clean %>%
  filter(naics == "------") %>%
  mutate(place = str_c(fipstate,"",fipscty)) %>%
  select(place, "cbp.tot"=emp)

jobs = jobs %>%
  left_join(y=jobs_temp, by="place") %>%
  replace(is.na(.), 0) %>%
  mutate(cbp.no.ag = cbp.tot - n11, n_fire = n52 + n53, n_edmed = n61 + n62, n_prof = n54 + n55) %>%
  select(place, cbp.no.ag, "n_mine"=n22, "n_mfg"=n31, n_fire, n_edmed, n_prof) %>%
  left_join(y=agc, by="place") %>%
  mutate(totemp = cbp.no.ag + ag_emp, pct_ag = ag_emp/totemp, pct_mine = n_mine/totemp, pct_mfg = n_mfg/totemp, pct_fire = n_fire/totemp, pct_edmed = n_edmed/totemp, pct_prof = n_prof/totemp) %>%
  select(place, "jobs"=totemp, pct_ag, pct_mine, pct_mfg, pct_fire, pct_prof, pct_edmed) %>%
  mutate(pct_edmed = ifelse(pct_edmed == "Inf", NA, pct_edmed), pct_fire = ifelse(pct_fire == "Inf", NA, pct_fire))

jobs2 = jobs_clean %>%
  mutate(n2d = substr(naics,1,2)) %>%
  mutate(filt3 = substr(naics,4,6)) %>%
  filter(n2d == "31"|n2d == "32"|n2d == "33") %>%
  filter(filt3 == "///") %>%
  mutate(durable = ifelse(n2d < 33, "nondurable", "durable"), durable = ifelse((naics == "321///" | naics == "327///"), "durable", durable), place = str_c(fipstate,"",fipscty)) %>%
  group_by(place, durable) %>%
  dplyr::summarize(emp = sum(emp)) %>%
  pivot_wider(names_from = durable, values_from = emp)

jobs = jobs %>%
  left_join(y=jobs2, by="place") %>%
  mutate(pct_durable = durable/jobs, pct_nondurable = nondurable/jobs) %>%
  select(-durable, -nondurable)

```

# data

```{r include = FALSE}
chr<-ih_dp$call_chr(2017) 

pop<-ih_dp$call_population(2012) 

data<- left_join (chr, pop, by = "place")

laborforce_part_rate<-ih_dp$call_laborforce_rate(2012)

data<- left_join (data, laborforce_part_rate, by = "place")

unempr<-ih_dp$call_unemp_rate(2012) 

data<- left_join (data, unempr, by = "place")

incr<-ih_dp$call_income_rate(2012)

data<- left_join (data, incr, by = "place")

povr<-ih_dp$call_poverty_rate(2012) 

data<- left_join (data, povr, by = "place")

# edur<-ih_dp$call_highschool_attainment_rate(2012) 

rucc<- ih_dp$call_ruc (2013) %>% 
  rename(place = fips)  


data<- left_join (data, rucc, by = "place")

data = data %>% 
mutate(metro_nonmetro = if_else(data$ruc_code < 4, "metro", "nonmetro"),
       logpop = log(population))

ind_struct<- ih_dp$call_industry_structure(2012)

data<- left_join (data, ind_struct, by = "place")

data<- left_join (data, age, by = "place")

data<- left_join (data, ers, by = "place")

data<- left_join (data, jobs, by = "place")

data<- left_join (data, bach, by = "place")

# circularity_import <- circularity$get_circularity()
# 
# 
# YR = 2012
# circu = circularity_import %>%  
#   filter(year == YR & ilevel == "det" & bus_data == "cbp_imp") %>%
#   select(place, retention, autonomy, excess_supply, intermediate_supply, excess_demand, intermediate_demand)
  

# data<- left_join (data, circu, by = "place")

print(data)



```

## 7/9/24 circularity

Commented code is to use infogroup data in sensitivity analysis

```{r}
#circu <- ih_dp$call_circularity(2012, bus_data = "infogroup", ilevel = "det") %>%
circu <- ih_dp$call_circularity(2012, bus_data = "cbp_imp", ilevel = "det") %>%
  select(place, retention_calc = retention, autonomy_calc = autonomy)
data <- left_join (data, circu, by = "place")
```


# Summary Statistics

```{r}

##summary statistics- global
summary_stats = data %>% 
  select(paam, retention_calc, autonomy_calc, pct_mfg, pct_mine, pct_ag, laborforce_part_rate, age, bach, poverty_rate, income_rate, logpop, uninsured) %>%
  get_summary_stats(, type = "common") %>% 
  relocate(variable, n, mean, median, min, max)
summary_stats = as.data.frame(summary_stats)
summary_stats


# Summary statistics for metro cases 
summary_stats_metro = data %>%
   filter(metro_nonmetro == "metro") %>% 
  select(paam, retention_calc, autonomy_calc, pct_mfg, pct_mine, pct_ag, 
         laborforce_part_rate, age, bach, poverty_rate, income_rate, 
         logpop, uninsured) %>%
  get_summary_stats(type = "common") %>%  
  relocate(variable, n, mean, median, min, max)  
summary_stats_metro = as.data.frame(summary_stats_metro)  
summary_stats_metro  


# Summary statistics for nonmetro cases 
summary_stats_nonmetro = data %>%
  filter(metro_nonmetro == "nonmetro") %>% 
  select(paam, retention_calc, autonomy_calc, pct_mfg, pct_mine, pct_ag, 
         laborforce_part_rate, age, bach, poverty_rate, income_rate, 
         logpop, uninsured) %>%
  get_summary_stats(type = "common") %>%  
  relocate(variable, n, mean, median, min, max)  
summary_stats_nonmetro = as.data.frame(summary_stats_nonmetro)  
summary_stats_nonmetro



```

# Histograms

```{r}
data %>% select(paam, retention_calc, autonomy_calc, pct_mfg, pct_mine, pct_ag) %>% hist.data.frame()

data %>% select(laborforce_part_rate, age, bach, poverty_rate, income_rate, logpop, uninsured) %>% hist.data.frame()


```
# Density plots

```{r}
#paam, retention_calc, autonomy_calc, pct_mfg, pct_mine, pct_ag, laborforce_part_rate, income_rate, bach

# Define the number of colors you want from the "rocket" palette
num_colors <- 2  # Adjust the number of colors as needed

# Create a vector of colors from the "rocket" palette excluding yellow
my_colors <- viridis_pal(option = "magma", begin = 0.1, end = 0.7)(num_colors)



 # Define the variables and titles
vars = c("paam", "retention_calc", "autonomy_calc", "pct_mfg", "pct_ag", 
           "laborforce_part_rate", "age", "bach", "poverty_rate",    "income_rate", "logpop", "uninsured")

titles = c("Premature\n Death", "Retention", "Autonomy", "%\n Manufacturing", 
           "%\n Agriculture", 
           "Labor \nForce\n Participation Rate", "% \nOver 65", 
           "% \nBachelors Plus", "Poverty\n Rate", "Income \nRate", 
           "Log\n Population", "Uninsured \n Rate \nUnder 65")

# Function to create density plots
create_density_plots <- function(data, vars, metro_nonmetro, my_colors, titles) {
  plots <- list()  
  
  # Loop through the variable names
  for (i in seq_along(vars)) {
    var <- vars[i]          
    title <- titles[i]     
    
    plot <- ggplot(data, aes_string(x = var, group = metro_nonmetro, 
                                     color = paste0("as.factor(", metro_nonmetro, ")"))) +
      geom_density() +
      scale_color_manual(name = "Metro/Non-Metro", values = my_colors) +
      labs(title = title,   
           x = var,        
           y = "Density") +
      theme_minimal()  
    
    plots[[var]] <- plot  
  }
  
  return(plots)  
}


# Call the function
density_plots <- create_density_plots(data, vars, "metro_nonmetro", my_colors, titles)

for (plot in density_plots) {
  print(plot)
}
```


# Maps

```{r}


map = ih_dp$call_geog(2012)
df_map <- left_join(map, data, by = "place") %>% shift_geometry()

#install.packages("RColorBrewer")
# library(RColorBrewer)
 
 vars = list("paam", "retention_calc", "autonomy_calc", "pct_mfg", "pct_ag", "pct_fire", "pct_edmed", "laborforce_part_rate", "age", "bach", "poverty_rate", "income_rate", "logpop", "uninsured", "metro_nonmetro")
 
 titles = c("Premature\n Death", "Retention", "Autonomy", "%\n Manufacturing", "%\n Agriculture", "% FIRE", "% Edu and Med", "Labor \nForce\n Participation Rate", "% \nOver 65", "% \nBachelors Plus", "Poverty\n Rate", "Income \nRate", "Log\n Population", "Uninsured \n Rate \nUnder 65", "Metro & Nonmetro \n Counties")
 
for (i in seq_along(vars)) {
  v = vars[[i]]
  legend_title = titles[i]

 mdn = median(df_map[[v]], na.rm = TRUE)

 tmap_mode("plot")
 output = df_map %>%
   tm_shape() +
  tm_polygons(col = v, style = "quantile", n = 4, border.alpha = 0.1, style = "cont", id = v,
               palette = c("#f0f9e8","#ccebc5", "#a8ddb5", "#7bccc4", "#43a2ca","#0868ac")) +
   tm_layout(legend.title.size = 1.0, fontface = 2, legend.position = c("LEFT","top"), frame = FALSE) +
    tm_layout(legend.title.size = 1.0, legend.position = c("LEFT","top"), frame = FALSE) +
    tm_legend(title = legend_title, title.fontface = 2)

print(output)

 }
 
 output = df_map %>%
   tm_shape() +
  tm_polygons(col = "pct_mine", n = 4, border.alpha = 0.1, style = "jenks", id = "pct_mine",
               palette = c("#f0f9e8","#ccebc5", "#a8ddb5", "#7bccc4", "#43a2ca","#0868ac")) +
  tm_layout( legend.title.size = 1.0, legend.position = c("LEFT","top"), frame = FALSE) +
  tm_legend(title = "% \n Mining", title.fontface = 2)

print(output)
 


```

```{r}

# creating maps
 # map(val = df_map$paam, title = "Premature Age Adjusted Mortality", rev_scale = FALSE)
# map(val = df_map$ypll75, title = "Years of Potential Life Lost before 75", rev_scale = FALSE)
# map(val = df_map$retention, title = "Retention", rev_scale = FALSE)
# map(val = df_map$autonomy, title = "Autonomy", rev_scale = FALSE)
# map(val = df_map$emp_to_va, title = "Employee Share of Value Added", rev_scale = FALSE)
# map(val = df_map$emp_to_output, title = "Employee Share of Output", rev_scale = FALSE)
# map(val = df_map$va_to_output, title = "Value Added Share of Output", rev_scale = FALSE)




```


# Scatterplots
ToDO:: create metro/nonmetro scatter plots
ToDO: scatter plots for prosperity measures

```{r}

# Full data regressions

ggplot(data, aes(retention_calc, paam)) +
  geom_point() +
   geom_smooth(method = "lm") +
   labs(title = "Scatter Plot of Retention (2012) and \n Premature Age Adjusted Mortality (2013-2015)",
        x = "Retention",
        y = "Premature Age Adjusted Mortality")

ggplot(data, aes(autonomy_calc, paam)) +
  geom_point() +
   geom_smooth(method = "lm") +
   labs(title = "Scatter Plot of Autonomy (2012) and \n Premature Age Adjusted Mortality (2013-2015)",
        x = "Autonomy",
        y = "Premature Age Adjusted Mortality")

##scatter plot of retention and autonomy (2012)
ggplot(data, aes(autonomy_calc, retention_calc)) +
  geom_point() +
   geom_smooth(method = "lm") +
   labs(title = "Scatter Plot of Autonomy (2012) and \n Retention (2012)",
        x = "Autonomy",
        y = "Retention")


# Filter the data to include only "nmetro" cases
metro_data <- subset(data, metro_nonmetro == "metro")

ggplot(metro_data, aes(retention_calc, paam)) +
  geom_point() +
   geom_smooth(method = "lm") +
   labs(title = "Scatter Plot of Retention and \n Premature Age Adjusted Mortality for Non-Metro",
        x = "Retention",
        y = "Premature Age Adjusted Mortality")

ggplot(metro_data, aes(autonomy_calc, paam)) +
  geom_point() +
   geom_smooth(method = "lm") +
   labs(title = "Scatter Plot of Autonomy and \n Premature Age Adjusted Mortality for Non-Metro",
        x = "Autonomy",
        y = "Premature Age Adjusted Mortality")

##scatter plot of retention and autonomy (2012)
ggplot(metro_data, aes(autonomy_calc, retention_calc)) +
  geom_point() +
   geom_smooth(method = "lm") +
   labs(title = "Scatter Plot of Autonomy (2012) and \n Retention (2012)",
        x = "Autonomy",
        y = "Retention")

# Nonmetro plots
# Filter the data to include only "nonmetro" cases
nonmetro_data <- subset(data, metro_nonmetro == "nonmetro")

ggplot(nonmetro_data, aes(retention_calc, paam)) +
  geom_point() +
   geom_smooth(method = "lm") +
   labs(title = "Scatter Plot of Retention and \n Premature Age Adjusted Mortality for Non-Metro",
        x = "Retention",
        y = "Premature Age Adjusted Mortality")

ggplot(nonmetro_data, aes(autonomy_calc, paam)) +
  geom_point() +
   geom_smooth(method = "lm") +
   labs(title = "Scatter Plot of Autonomy and \n Premature Age Adjusted Mortality for Non-Metro",
        x = "Autonomy",
        y = "Premature Age Adjusted Mortality")

##scatter plot of retention and autonomy (2012)
ggplot(nonmetro_data, aes(autonomy_calc, retention_calc)) +
  geom_point() +
   geom_smooth(method = "lm") +
   labs(title = "Scatter Plot of Autonomy (2012) and \n Retention (2012)",
        x = "Autonomy",
        y = "Retention")

```




# ESDA

```{r}
map = ih_dp$call_geog(2012)
df_map <- left_join(map, data, by = "place") %>% 
  drop_na(paam, ypll75, retention_calc, autonomy_calc, emp_to_va, emp_to_output, va_to_output)


nb <- poly2nb(df_map, queen=TRUE)
lw <- nb2listw(nb, style="W", zero.policy=TRUE)
lw$weights[5]


```

##PAAM
###moran global paam 

```{r}
moran.test(df_map$paam,lw, zero.policy=TRUE)

```


###lisa paam
```{r}
df_lisa<- df_map %>% 
  shift_geometry()


w <- queen_weights(df_lisa)
lisa <- local_moran(w, df_lisa['paam'])
lisa_colors <- lisa_colors(lisa)
lisa_labels <- lisa_labels(lisa)
lisa_clusters <- lisa_clusters(lisa)
plot(st_geometry(df_lisa), 
     col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}), 
     border = "#333333", lwd=0.1)
title(main = "LISA, Premature Age-Adjusted Mortality")


# Create the legend separately

# legend_labels <- c("Not significant", "High-High", "Low-Low", "High-Low", "Low-High")
# legend_colors <- unlist(lisa_colors)
# legend("bottomleft", border = "#eeeeee")
```

##Retention
###moran global retention 

```{r}
moran.test(df_map$retention_calc,lw, zero.policy=TRUE)

```


###lisa retention
```{r}


w <- queen_weights(df_lisa)
lisa <- local_moran(w, df_lisa['retention_calc'])
lisa_colors <- lisa_colors(lisa)
lisa_labels <- lisa_labels(lisa)
lisa_clusters <- lisa_clusters(lisa)
plot(st_geometry(df_lisa), 
     col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}), 
     border = "#333333", lwd=0.2)
title(main = "LISA, Retention")


# Create the legend separately

# legend_labels <- c("Not significant", "High-High", "Low-Low", "High-Low", "Low-High")
# legend_colors <- unlist(lisa_colors)
# legend("bottomleft", border = "#eeeeee")
```

##Autonomy
###moran global autonomy 

```{r}
moran.test(df_map$autonomy_calc,lw, zero.policy=TRUE)

```


###lisa autonomy
```{r}


w <- queen_weights(df_lisa)
lisa <- local_moran(w, df_lisa['autonomy_calc'])
lisa_colors <- lisa_colors(lisa)
lisa_labels <- lisa_labels(lisa)
lisa_clusters <- lisa_clusters(lisa)
plot(st_geometry(df_lisa), 
     col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}), 
     border = "#333333", lwd=0.2)
title(main = "LISA, Autonomy")


# Create the legend separately

# legend_labels <- c("Not significant", "High-High", "Low-Low", "High-Low", "Low-High")
# legend_colors <- unlist(lisa_colors)
# legend("bottomleft", border = "#eeeeee")
```

# Models
```{r}
mi1 = df_map %>% drop_na(c(paam, retention_calc, autonomy_calc, pct_mfg, pct_mine, pct_ag, pct_fire, pct_edmed, laborforce_part_rate, age, bach, poverty_rate, income_rate, logpop, uninsured)) %>% mutate(metro = ifelse(ruc_code >= 4, 1, 0), paam = (paam - mean(paam, na.rm=TRUE))/sd(paam, na.rm=TRUE), retention_calc = (retention_calc - mean(retention_calc, na.rm=TRUE))/sd(retention_calc, na.rm=TRUE), autonomy_calc = (autonomy_calc - mean(autonomy_calc, na.rm=TRUE))/sd(autonomy_calc, na.rm=TRUE), pct_mfg = (pct_mfg - mean(pct_mfg, na.rm=TRUE))/sd(pct_mfg, na.rm=TRUE), pct_mine = (pct_mine - mean(pct_mine, na.rm=TRUE))/sd(pct_mine, na.rm=TRUE), pct_ag = (pct_ag - mean(pct_ag, na.rm=TRUE))/sd(pct_ag, na.rm=TRUE), pct_fire = (pct_fire - mean(pct_fire, na.rm=TRUE))/sd(pct_fire, na.rm=TRUE), pct_edmed = (pct_edmed - mean(pct_edmed, na.rm=TRUE))/sd(pct_edmed, na.rm=TRUE), laborforce_part_rate = (laborforce_part_rate - mean(laborforce_part_rate, na.rm=TRUE))/sd(laborforce_part_rate, na.rm=TRUE), age = (age - mean(age, na.rm=TRUE))/sd(age, na.rm=TRUE), bach = (bach - mean(bach, na.rm=TRUE))/sd(bach, na.rm=TRUE), poverty_rate = (poverty_rate - mean(poverty_rate, na.rm=TRUE))/sd(poverty_rate, na.rm=TRUE), income_rate = (income_rate - mean(income_rate, na.rm=TRUE))/sd(income_rate, na.rm=TRUE), logpop = (logpop - mean(logpop, na.rm=TRUE))/sd(logpop, na.rm=TRUE), uninsured = (uninsured - mean(uninsured, na.rm=TRUE))/sd(uninsured, na.rm=TRUE))

```


## OLS

```{r}

ols3a = lm(data = mi1, paam ~ retention_calc + autonomy_calc + pct_ag + pct_mine + pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + uninsured)

summary(ols3a)

# global and local autocorrelation
Q2ar = mi1
Q2ar$r = ols3a$resid
nb <- poly2nb(Q2ar, queen=TRUE)
lw <- nb2listw(nb, style="W", zero.policy=TRUE)
lw$weights[5]
moran.test(Q2ar$r,lw, zero.policy=TRUE)
w <- queen_weights(Q2ar)
lisa <- local_moran(w, Q2ar['r'])
lisa_colors <- lisa_colors(lisa)
lisa_labels <- lisa_labels(lisa)
lisa_clusters <- lisa_clusters(lisa)
Q2ar = Q2ar %>%
  filter(STATE_NAME != "Alaska" & STATE_NAME != "Hawaii")
plot(st_geometry(Q2ar), 
     col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}), 
     border = "#333333", lwd=0.2)


```

### sp auto

## M1-Spatial Error

```{r}

nb <- poly2nb(mi1, queen=TRUE)
lw <- nb2listw(nb, style="W", zero.policy=TRUE)

ols3a = errorsarlm(data = mi1, paam ~ retention_calc + autonomy_calc + pct_ag + pct_mine + pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + uninsured,
                  lw, zero.policy = TRUE)

summary(ols3a)



temp1 = data.frame(as.list(ols3a$coefficients)) %>% mutate(var = "coef") %>% pivot_longer(cols=!var, names_to = "name", values_to = "coef") %>% select(-var)
temp2 = data.frame(as.list(ols3a$rest.se)) %>% mutate(var = "se") %>% pivot_longer(cols=!var, names_to = "name", values_to = "se") %>% select(-var) %>% mutate(name = gsub('I.x...lambda...WX.', '', name), name = ifelse(name == ".Intercept.", "X.Intercept.", name))

viz_agg = temp1 %>% left_join(y=temp2, by="name") %>% mutate(rurality = "agg") %>% rename("var"="name") %>%
  filter(var != "X.Intercept.")



```

### sp auto

```{r}
# global and local autocorrelation
Q2ar = mi1
Q2ar$r = ols3a$resid
nb <- poly2nb(Q2ar, queen=TRUE)
lw <- nb2listw(nb, style="W", zero.policy=TRUE)
lw$weights[5]
moran.test(Q2ar$r,lw, zero.policy=TRUE)
w <- queen_weights(Q2ar)
lisa <- local_moran(w, Q2ar['r'])
lisa_colors <- lisa_colors(lisa)
lisa_labels <- lisa_labels(lisa)
lisa_clusters <- lisa_clusters(lisa)
Q2ar = Q2ar %>%
  filter(STATE_NAME != "Alaska" & STATE_NAME != "Hawaii")
plot(st_geometry(Q2ar),
     col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}),
     border = "#333333", lwd=0.2)

```


## SLX

```{r}

nb <- poly2nb(mi1, queen=TRUE)
lw <- nb2listw(nb, style="W", zero.policy=TRUE)

ols3a = errorsarlm(data = mi1, paam ~ retention_calc + autonomy_calc + pct_ag + pct_mine + pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + uninsured,
                  lw, zero.policy = TRUE)

summary(ols3a)


slx_import = lmSLX(data = mi1, paam ~ retention_calc + autonomy_calc + pct_ag + pct_mine + pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + uninsured, lw, zero.policy=TRUE)

summary(slx_import)


```

### sp auto
```{r}

Q2ar = mi1
Q2ar$r = slx_import$resid
nb <- poly2nb(Q2ar, queen=TRUE)
lw <- nb2listw(nb, style="W", zero.policy=TRUE)
lw$weights[5]
moran.test(Q2ar$r,lw, zero.policy=TRUE)
w <- queen_weights(Q2ar)
lisa <- local_moran(w, Q2ar['r'])
lisa_colors <- lisa_colors(lisa)
lisa_labels <- lisa_labels(lisa)
lisa_clusters <- lisa_clusters(lisa)
Q2ar = Q2ar %>%
  filter(STATE_NAME != "Alaska" & STATE_NAME != "Hawaii")
plot(st_geometry(Q2ar),
     col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}),
     border = "#333333", lwd=0.2)


```



<!-- #### SLX (using package) -->

<!-- ```{r} -->
<!-- nb <- poly2nb(mi1, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->
<!-- SLX_pack <- lmSLX(paam ~ retention_calc + autonomy_calc + pct_ag + pct_mine + pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + uninsured, data=mi1, listw=lw, zero.policy = TRUE) -->

<!-- summary(SLX_pack) -->

<!-- ``` -->



## M2- Regime- metro/non

```{r}
nb <- poly2nb(mi1, queen=TRUE)
lw <- nb2listw(nb, style="W", zero.policy=TRUE)

sr_data = mi1 %>% mutate(sr = metro_nonmetro)

sr2a = errorsarlm(data = sr_data, paam ~ 0 + sr/(retention_calc + autonomy_calc + pct_mfg + pct_ag + laborforce_part_rate + pct_mine + age + bach + poverty_rate + income_rate + logpop + uninsured),
                  lw, zero.policy = TRUE)

```

### sp auto

```{r}

nb <- poly2nb(mi1, queen=TRUE)
lw <- nb2listw(nb, style="W", zero.policy=TRUE)

sr_data = mi1 %>% mutate(sr = metro_nonmetro)

ols3a = errorsarlm(data = sr_data, paam ~ 0 + sr/(retention_calc + autonomy_calc + pct_ag + pct_mine + pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + uninsured),
                  lw, zero.policy = TRUE)

summary(ols3a)


temp1 = data.frame(as.list(ols3a$coefficients)) %>% mutate(var = "coef") %>% pivot_longer(cols=!var, names_to = "name", values_to = "coef") %>% select(-var) %>% filter(name != "srmetro" & name != "srnonmetro") %>% mutate(rurality = substr(name, 1, 5), name = gsub('srmetro.', '', name), name = gsub('srnonmetro.', '', name), rurality = ifelse(rurality == "srmet", "metro", "nonmetro"))
temp2 = data.frame(as.list(ols3a$rest.se)) %>% mutate(var = "se") %>% pivot_longer(cols=!var, names_to = "name", values_to = "se") %>% select(-var) %>% mutate(name = gsub('I.x...lambda...WX.', '', name), name = ifelse(name == ".Intercept.", "X.Intercept.", name)) %>% filter(name != "srmetro" & name != "srnonmetro") %>% mutate(rurality = substr(name, 1, 5), name = gsub('srmetro.', '', name), name = gsub('srnonmetro.', '', name), rurality = ifelse(rurality == "srmet", "metro", "nonmetro"))


viz_regime = temp1 %>% left_join(y=temp2, by=c("name","rurality")) %>% rename("var"="name")


# global and local autocorrelation
Q2ar = mi1
Q2ar$r = ols3a$resid
nb <- poly2nb(Q2ar, queen=TRUE)
lw <- nb2listw(nb, style="W", zero.policy=TRUE)
lw$weights[5]
moran.test(Q2ar$r,lw, zero.policy=TRUE)
w <- queen_weights(Q2ar)
lisa <- local_moran(w, Q2ar['r'])
lisa_colors <- lisa_colors(lisa)
lisa_labels <- lisa_labels(lisa)
lisa_clusters <- lisa_clusters(lisa)
Q2ar = Q2ar %>%
  filter(STATE_NAME != "Alaska" & STATE_NAME != "Hawaii")
plot(st_geometry(Q2ar),
     col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}),
     border = "#333333", lwd=0.2)

```


## aspatial SEM
```{r}
model5 <- '
  prosperity2 =~ laborforce_part_rate + poverty_rate + bach + income_rate

  retention_calc ~ pct_mfg + pct_ag + pct_mine
  autonomy_calc ~ pct_mfg + pct_ag + pct_mine
  prosperity2 ~ pct_mfg + pct_ag + pct_mine + a*retention_calc + autonomy_calc + logpop
  paam ~ logpop + b*prosperity2 + pct_mfg + pct_ag + pct_mine + c*retention_calc + autonomy_calc + age + uninsured
  
  # indirect (a*b)
  ab := a*b
  
  # total
  total := c + (a*b)
  
  retention_calc ~~ autonomy_calc
  
  
'

model5.fit <- sem(model5, data = mi1) 
summary(model5.fit, rsq = TRUE, fit.measures = TRUE, standardized = TRUE) 

fit <- cfa(model5, data=mi1)
```


### sp auto

```{r}


m1a  <- ' prosperity  =~ laborforce_part_rate + bach + poverty_rate + income_rate'

factor1 <- cfa(m1a, data=mi1,std.lv=TRUE)
summary(factor1)

PE <- parameterEstimates(factor1) %>%
  filter(lhs == "prosperity")

loading.laborforce_part_rate = PE %>%
  filter(rhs == "laborforce_part_rate") %>%
  select(est)
loading.laborforce_part_rate = loading.laborforce_part_rate$est

loading.bach = PE %>%
  filter(rhs == "bach") %>%
  select(est)
loading.bach = loading.bach$est

loading.poverty_rate = PE %>%
  filter(rhs == "poverty_rate") %>%
  select(est)
loading.poverty_rate = loading.poverty_rate$est

loading.income_rate = PE %>%
  filter(rhs == "income_rate") %>%
  select(est)
loading.income_rate = loading.income_rate$est

mi2 = mi1 %>%
  mutate(prosperity = ((laborforce_part_rate*loading.laborforce_part_rate)+(income_rate*loading.income_rate)+(poverty_rate*loading.poverty_rate)+(bach*loading.bach))/4, prosperity = (prosperity-mean(prosperity, na.rm=TRUE))/sd(prosperity, na.rm=TRUE))

# pooled

mi1_spa = mi2

model5_spa <- '
  retention_calc ~ pct_mfg + pct_ag + pct_mine
  autonomy_calc ~ pct_mfg + pct_ag + pct_mine
  prosperity ~ pct_mfg + pct_ag + pct_mine + a*retention_calc + autonomy_calc + logpop
  paam ~ logpop + b*prosperity + pct_mfg + pct_ag + pct_mine + c*retention_calc + autonomy_calc + age + uninsured
  
  # indirect (a*b)
  ab := a*b
  
  # total
  total := c + (a*b)
  
  retention_calc ~~ autonomy_calc
  
  
'

model5.fit_spa <- sem(model5_spa, data = mi2) 
summary(model5.fit_spa, rsq = TRUE, fit.measures = TRUE, standardized = TRUE) 

fit <- cfa(model5_spa, data=mi1_spa)

sem_pvy = lavPredictY(fit, ynames = c("paam"),
                 xnames = c("logpop", "retention_calc", "autonomy_calc", "uninsured", "age", "prosperity", "pct_mfg", "pct_ag", "pct_mine"))



sem_pvy2 = as.data.frame(sem_pvy)
sem_pvy3 = sem_pvy2$paam

mi1_spa2 <- cbind(mi1_spa, sem_pvy) %>%
  mutate(r_paam = paam - paam.1)

temp = mi1_spa2$r_paam

w <- queen_weights(mi1_spa2)
nb <- poly2nb(mi1_spa2, queen=TRUE)
lw <- nb2listw(nb, style="W", zero.policy=TRUE)
lw$weights[5]
moran.test(mi1_spa2$r_paam,lw, zero.policy=TRUE)
w <- queen_weights(mi1_spa2)
lisa <- local_moran(w, mi1_spa2['r_paam'])
lisa_colors <- lisa_colors(lisa)
lisa_labels <- lisa_labels(lisa)
lisa_clusters <- lisa_clusters(lisa)
mi1_spa2 = mi1_spa2 %>%
  filter(STATE_NAME != "Alaska" & STATE_NAME != "Hawaii")
plot(st_geometry(mi1_spa2),
     col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}),
     border = "#333333", lwd=0.2)



# metro

mi1_spa_metro = mi2 %>%
  filter(metro_nonmetro == "metro")

model5_spa <- '
  retention_calc ~ pct_mfg + pct_ag + pct_mine
  autonomy_calc ~ pct_mfg + pct_ag + pct_mine
  prosperity ~ pct_mfg + pct_ag + pct_mine + a*retention_calc + autonomy_calc + logpop
  paam ~ logpop + b*prosperity + pct_mfg + pct_ag + pct_mine + c*retention_calc + autonomy_calc + age + uninsured
  
  # indirect (a*b)
  ab := a*b
  
  # total
  total := c + (a*b)
  
  retention_calc ~~ autonomy_calc
  
  
'

model5.fit_spa <- sem(model5_spa, data = mi1_spa_metro) 
summary(model5.fit_spa, rsq = TRUE, fit.measures = TRUE, standardized = TRUE) 

fit <- cfa(model5_spa, data=mi1_spa_metro)

sem_pvy = lavPredictY(fit, ynames = c("paam"),
                 xnames = c("logpop", "retention_calc", "autonomy_calc", "uninsured", "age", "prosperity", "pct_mfg", "pct_ag", "pct_mine"))



sem_pvy2 = as.data.frame(sem_pvy)
sem_pvy3 = sem_pvy2$paam

mi1_spa2 <- cbind(mi1_spa_metro, sem_pvy) %>%
  mutate(r_paam = paam - paam.1)

temp = mi1_spa2$r_paam

w <- queen_weights(mi1_spa2)
nb <- poly2nb(mi1_spa2, queen=TRUE)
lw <- nb2listw(nb, style="W", zero.policy=TRUE)
lw$weights[5]
moran.test(mi1_spa2$r_paam,lw, zero.policy=TRUE)
mi1_spa2 = mi1_spa2 %>%
  filter(STATE_NAME != "Alaska" & STATE_NAME != "Hawaii")
plot(st_geometry(mi1_spa2),
     col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}),
     border = "#333333", lwd=0.2)





# nonmetro

mi1_spa_nonmetro = mi2 %>%
  filter(metro_nonmetro == "nonmetro")

model5_spa <- '
  retention_calc ~ pct_mfg + pct_ag + pct_mine
  autonomy_calc ~ pct_mfg + pct_ag + pct_mine
  prosperity ~ pct_mfg + pct_ag + pct_mine + a*retention_calc + autonomy_calc + logpop
  paam ~ logpop + b*prosperity + pct_mfg + pct_ag + pct_mine + c*retention_calc + autonomy_calc + age + uninsured
  
  # indirect (a*b)
  ab := a*b
  
  # total
  total := c + (a*b)
  
  retention_calc ~~ autonomy_calc
  
  
'

model5.fit_spa <- sem(model5_spa, data = mi1_spa_nonmetro) 
summary(model5.fit_spa, rsq = TRUE, fit.measures = TRUE, standardized = TRUE) 

fit <- cfa(model5_spa, data=mi1_spa_nonmetro)

sem_pvy = lavPredictY(fit, ynames = c("paam"),
                 xnames = c("logpop", "retention_calc", "autonomy_calc", "uninsured", "age", "prosperity", "pct_mfg", "pct_ag", "pct_mine"))



sem_pvy2 = as.data.frame(sem_pvy)
sem_pvy3 = sem_pvy2$paam

mi1_spa2 <- cbind(mi1_spa_nonmetro, sem_pvy) %>%
  mutate(r_paam = paam - paam.1)

temp = mi1_spa2$r_paam

w <- queen_weights(mi1_spa2)
nb <- poly2nb(mi1_spa2, queen=TRUE)
lw <- nb2listw(nb, style="W", zero.policy=TRUE)
lw$weights[5]
moran.test(mi1_spa2$r_paam,lw, zero.policy=TRUE)
mi1_spa2 = mi1_spa2 %>%
  filter(STATE_NAME != "Alaska" & STATE_NAME != "Hawaii")
plot(st_geometry(mi1_spa2),
     col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}),
     border = "#333333", lwd=0.2)



```


## M3-SEM-SLX


```{r}

nb <- poly2nb(mi1, queen=TRUE)
lw <- nb2listw(nb, style="W", zero.policy=TRUE)


slx_import = lmSLX(data = mi1, paam ~ retention_calc + autonomy_calc + pct_ag + pct_mine + pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + uninsured, lw, zero.policy=TRUE)

mi3 = mi1 %>%
  mutate(lag.retention_calc = slx_import$model$lag.retention_calc, lag.autonomy_calc = slx_import$model$lag.autonomy_calc, 
         lag.pct_ag = slx_import$model$lag.pct_ag, lag.pct_mine = slx_import$model$lag.pct_mine, 
         lag.pct_mfg = slx_import$model$lag.pct_mfg, lag.laborforce_part_rate = slx_import$model$lag.laborforce_part_rate, 
         lag.age = slx_import$model$lag.age, lag.bach = slx_import$model$lag.bach, 
         lag.poverty_rate = slx_import$model$lag.poverty_rate, lag.income_rate = slx_import$model$lag.income_rate, 
         lag.logpop = slx_import$model$lag.logpop, 
         lag.uninsured = slx_import$model$lag.uninsured
         )


model6 <- '
  prosperity2 =~ laborforce_part_rate + poverty_rate + bach + income_rate

  retention_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine
  autonomy_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine
  prosperity2 ~ pct_mfg + pct_ag + pct_mine + a*retention_calc + autonomy_calc + logpop + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop
  paam ~ logpop + b*prosperity2 + pct_mfg + pct_ag + pct_mine + c*retention_calc + autonomy_calc + age + uninsured + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop + lag.laborforce_part_rate + lag.poverty_rate + lag.bach + lag.income_rate + lag.age + lag.uninsured
  
  # indirect (a*b)
  ab := a*b
  
  # total
  total := c + (a*b)
  

  retention_calc ~~ autonomy_calc
  
'

model6.fit <- sem(model6, data = mi3) 
summary(model6.fit, rsq = TRUE, fit.measures = TRUE, standardized = TRUE) 

fit <- cfa(model6, data=mi3)


```

### sp auto

```{r}

m1a  <- ' prosperity  =~ laborforce_part_rate + bach + poverty_rate + income_rate'

factor1 <- cfa(m1a, data=mi1,std.lv=TRUE)
summary(factor1)

PE <- parameterEstimates(factor1) %>%
  filter(lhs == "prosperity")

loading.laborforce_part_rate = PE %>%
  filter(rhs == "laborforce_part_rate") %>%
  select(est)
loading.laborforce_part_rate = loading.laborforce_part_rate$est

loading.bach = PE %>%
  filter(rhs == "bach") %>%
  select(est)
loading.bach = loading.bach$est

loading.poverty_rate = PE %>%
  filter(rhs == "poverty_rate") %>%
  select(est)
loading.poverty_rate = loading.poverty_rate$est

loading.income_rate = PE %>%
  filter(rhs == "income_rate") %>%
  select(est)
loading.income_rate = loading.income_rate$est

mi3_spa = mi3 %>%
  mutate(prosperity = ((laborforce_part_rate*loading.laborforce_part_rate)+(income_rate*loading.income_rate)+(poverty_rate*loading.poverty_rate)+(bach*loading.bach))/4, prosperity = (prosperity-mean(prosperity, na.rm=TRUE))/sd(prosperity, na.rm=TRUE))


model5_spa <- '
  retention_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine
  autonomy_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine
  prosperity ~ pct_mfg + pct_ag + pct_mine + a*retention_calc + autonomy_calc + logpop + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop
  paam ~ logpop + b*prosperity + pct_mfg + pct_ag + pct_mine + c*retention_calc + autonomy_calc + age + uninsured + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop + lag.laborforce_part_rate + lag.poverty_rate + lag.bach + lag.income_rate + lag.age  + lag.uninsured
  
  # indirect (a*b)
  ab := a*b
  
  # total
  total := c + (a*b)
  

  retention_calc ~~ autonomy_calc
  
  
'

model5.fit_spa <- sem(model5_spa, data = mi3_spa) 
summary(model5.fit_spa, rsq = TRUE, fit.measures = TRUE, standardized = TRUE) 

fit <- cfa(model5_spa, data=mi3_spa)

sem_pvy = lavPredictY(fit, ynames = c("paam"),
                 xnames = c("logpop", "retention_calc", "autonomy_calc", "uninsured", "age", "prosperity", "pct_mfg", "pct_ag", "pct_mine", "lag.pct_mfg", "lag.pct_ag", "lag.pct_mine", "lag.retention_calc", "lag.autonomy_calc","lag.logpop", "lag.laborforce_part_rate","lag.poverty_rate","lag.bach","lag.income_rate", "lag.age", "lag.uninsured"))





sem_pvy2 = as.data.frame(sem_pvy)
sem_pvy3 = sem_pvy2$paam

mi3_spa2 <- cbind(mi3_spa, sem_pvy) %>%
  mutate(r_paam = paam - paam.1)

temp = mi3_spa2$r_paam

w <- queen_weights(mi3_spa2)
nb <- poly2nb(mi3_spa2, queen=TRUE)
lw <- nb2listw(nb, style="W", zero.policy=TRUE)
lw$weights[5]
moran.test(mi3_spa2$r_paam,lw, zero.policy=TRUE)
mi3_spa2 = mi3_spa2 %>%
  filter(STATE_NAME != "Alaska" & STATE_NAME != "Hawaii")
plot(st_geometry(mi3_spa2),
     col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}),
     border = "#333333", lwd=0.2)


```

## M3a-SEM-SLX-Metro

```{r}
nb <- poly2nb(mi1, queen=TRUE)
lw <- nb2listw(nb, style="W", zero.policy=TRUE)


slx_import = lmSLX(data = mi1, paam ~ retention_calc + autonomy_calc + pct_ag + pct_mine + pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + uninsured, lw, zero.policy=TRUE)

mi3 = mi1 %>%
  mutate(lag.retention_calc = slx_import$model$lag.retention_calc, lag.autonomy_calc = slx_import$model$lag.autonomy_calc, 
         lag.pct_ag = slx_import$model$lag.pct_ag, lag.pct_mine = slx_import$model$lag.pct_mine, 
         lag.pct_mfg = slx_import$model$lag.pct_mfg, lag.laborforce_part_rate = slx_import$model$lag.laborforce_part_rate, 
         lag.age = slx_import$model$lag.age, lag.bach = slx_import$model$lag.bach, 
         lag.poverty_rate = slx_import$model$lag.poverty_rate, lag.income_rate = slx_import$model$lag.income_rate, 
         lag.logpop = slx_import$model$lag.logpop, 
         lag.uninsured = slx_import$model$lag.uninsured
         )

mi3_metro = mi3 %>%
  filter(metro_nonmetro == "metro")

model6 <- '
  prosperity2 =~ laborforce_part_rate + poverty_rate + bach + income_rate

  retention_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine
  autonomy_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine
  prosperity2 ~ pct_mfg + pct_ag + pct_mine + a*retention_calc + autonomy_calc + logpop + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop
  paam ~ logpop + b*prosperity2 + pct_mfg + pct_ag + pct_mine + c*retention_calc + autonomy_calc + age + uninsured + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop + lag.laborforce_part_rate + lag.poverty_rate + lag.bach + lag.income_rate + lag.age + lag.uninsured
  
  # indirect (a*b)
  ab := a*b
  
  # total
  total := c + (a*b)
  
  retention_calc ~~ autonomy_calc

'

model6.fit <- sem(model6, data = mi3_metro) 
summary(model6.fit, rsq = TRUE, fit.measures = TRUE, standardized = TRUE) 

fit <- cfa(model6, data=mi3_metro)


```

### sp auto

```{r}

m1a  <- ' prosperity  =~ laborforce_part_rate + bach + poverty_rate + income_rate'

factor1 <- cfa(m1a, data=mi1,std.lv=TRUE)
summary(factor1)

PE <- parameterEstimates(factor1) %>%
  filter(lhs == "prosperity")

loading.laborforce_part_rate = PE %>%
  filter(rhs == "laborforce_part_rate") %>%
  select(est)
loading.laborforce_part_rate = loading.laborforce_part_rate$est

loading.bach = PE %>%
  filter(rhs == "bach") %>%
  select(est)
loading.bach = loading.bach$est

loading.poverty_rate = PE %>%
  filter(rhs == "poverty_rate") %>%
  select(est)
loading.poverty_rate = loading.poverty_rate$est

loading.income_rate = PE %>%
  filter(rhs == "income_rate") %>%
  select(est)
loading.income_rate = loading.income_rate$est

mi3_spa = mi3 %>%
  mutate(prosperity = ((laborforce_part_rate*loading.laborforce_part_rate)+(income_rate*loading.income_rate)+(poverty_rate*loading.poverty_rate)+(bach*loading.bach))/4, prosperity = (prosperity-mean(prosperity, na.rm=TRUE))/sd(prosperity, na.rm=TRUE))


mi3_metro_metro = mi3_spa %>%
  filter(metro_nonmetro == "metro")

model5_spa <- '
  retention_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine
  autonomy_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine
  prosperity ~ pct_mfg + pct_ag + pct_mine + a*retention_calc + autonomy_calc + logpop + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop
  paam ~ logpop + b*prosperity + pct_mfg + pct_ag + pct_mine + c*retention_calc + autonomy_calc + age + uninsured + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop + lag.laborforce_part_rate + lag.poverty_rate + lag.bach + lag.income_rate + lag.age  + lag.uninsured
  
  # indirect (a*b)
  ab := a*b
  
  # total
  total := c + (a*b)
  

  retention_calc ~~ autonomy_calc
  
  
'

model5.fit_spa <- sem(model5_spa, data = mi3_metro_metro) 
summary(model5.fit_spa, rsq = TRUE, fit.measures = TRUE, standardized = TRUE) 

fit <- cfa(model5_spa, data=mi3_metro_metro)

sem_pvy = lavPredictY(fit, ynames = c("paam"),
                 xnames = c("logpop", "retention_calc", "autonomy_calc", "uninsured", "age", "prosperity", "pct_mfg", "pct_ag", "pct_mine", "lag.pct_mfg", "lag.pct_ag", "lag.pct_mine", "lag.retention_calc", "lag.autonomy_calc","lag.logpop", "lag.laborforce_part_rate","lag.poverty_rate","lag.bach","lag.income_rate", "lag.age", "lag.uninsured"))





sem_pvy2 = as.data.frame(sem_pvy)
sem_pvy3 = sem_pvy2$paam

mi3_spa2 <- cbind(mi3_metro_metro, sem_pvy) %>%
  mutate(r_paam = paam - paam.1)

temp = mi3_spa2$r_paam


w <- queen_weights(mi3_spa2)
nb <- poly2nb(mi3_spa2, queen=TRUE)
lw <- nb2listw(nb, style="W", zero.policy=TRUE)
lw$weights[5]
moran.test(mi3_spa2$r_paam,lw, zero.policy=TRUE)
mi3_spa2 = mi3_spa2 %>%
  filter(STATE_NAME != "Alaska" & STATE_NAME != "Hawaii")
plot(st_geometry(mi3_spa2),
     col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}),
     border = "#333333", lwd=0.2)


```





## M3b-SEM-SLX-nonmetro
```{r}
nb <- poly2nb(mi1, queen=TRUE)
lw <- nb2listw(nb, style="W", zero.policy=TRUE)


slx_import = lmSLX(data = mi1, paam ~ retention_calc + autonomy_calc + pct_ag + pct_mine + pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + uninsured, lw, zero.policy=TRUE)

mi3 = mi1 %>%
  mutate(lag.retention_calc = slx_import$model$lag.retention_calc, lag.autonomy_calc = slx_import$model$lag.autonomy_calc, 
         lag.pct_ag = slx_import$model$lag.pct_ag, lag.pct_mine = slx_import$model$lag.pct_mine, 
         lag.pct_mfg = slx_import$model$lag.pct_mfg, lag.laborforce_part_rate = slx_import$model$lag.laborforce_part_rate, 
         lag.age = slx_import$model$lag.age, lag.bach = slx_import$model$lag.bach, 
         lag.poverty_rate = slx_import$model$lag.poverty_rate, lag.income_rate = slx_import$model$lag.income_rate, 
         lag.logpop = slx_import$model$lag.logpop, 
         lag.uninsured = slx_import$model$lag.uninsured
         )

mi3_nonmetro = mi3 %>%
  filter(metro_nonmetro == "nonmetro")

model6 <- '
  prosperity2 =~ laborforce_part_rate + poverty_rate + bach + income_rate

  retention_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine
  autonomy_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine
  prosperity2 ~ pct_mfg + pct_ag + pct_mine + a*retention_calc + autonomy_calc + logpop + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop
  paam ~ logpop + b*prosperity2 + pct_mfg + pct_ag + pct_mine + c*retention_calc + autonomy_calc + age + uninsured + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop + lag.laborforce_part_rate + lag.poverty_rate + lag.bach + lag.income_rate + lag.age + lag.uninsured
  
  # indirect (a*b)
  ab := a*b
  
  # total
  total := c + (a*b)

  retention_calc ~~ autonomy_calc

'

model6.fit <- sem(model6, data = mi3_nonmetro) 
summary(model6.fit, rsq = TRUE, fit.measures = TRUE, standardized = TRUE) 

fit <- cfa(model6, data=mi3_nonmetro)
```

### sp auto

```{r}

m1a  <- ' prosperity  =~ laborforce_part_rate + bach + poverty_rate + income_rate'

factor1 <- cfa(m1a, data=mi1,std.lv=TRUE)
summary(factor1)

PE <- parameterEstimates(factor1) %>%
  filter(lhs == "prosperity")

loading.laborforce_part_rate = PE %>%
  filter(rhs == "laborforce_part_rate") %>%
  select(est)
loading.laborforce_part_rate = loading.laborforce_part_rate$est

loading.bach = PE %>%
  filter(rhs == "bach") %>%
  select(est)
loading.bach = loading.bach$est

loading.poverty_rate = PE %>%
  filter(rhs == "poverty_rate") %>%
  select(est)
loading.poverty_rate = loading.poverty_rate$est

loading.income_rate = PE %>%
  filter(rhs == "income_rate") %>%
  select(est)
loading.income_rate = loading.income_rate$est

mi3_spa = mi3 %>%
  mutate(prosperity = ((laborforce_part_rate*loading.laborforce_part_rate)+(income_rate*loading.income_rate)+(poverty_rate*loading.poverty_rate)+(bach*loading.bach))/4, prosperity = (prosperity-mean(prosperity, na.rm=TRUE))/sd(prosperity, na.rm=TRUE))


mi3_metro_nonmetro = mi3_spa %>%
  filter(metro_nonmetro == "nonmetro")

model5_spa <- '
  retention_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine
  autonomy_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine
  prosperity ~ pct_mfg + pct_ag + pct_mine + a*retention_calc + autonomy_calc + logpop + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop
  paam ~ logpop + b*prosperity + pct_mfg + pct_ag + pct_mine + c*retention_calc + autonomy_calc + age + uninsured + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop + lag.laborforce_part_rate + lag.poverty_rate + lag.bach + lag.income_rate + lag.age  + lag.uninsured
  
  # indirect (a*b)
  ab := a*b
  
  # total
  total := c + (a*b)
  

  retention_calc ~~ autonomy_calc
  
  
'

model5.fit_spa <- sem(model5_spa, data = mi3_metro_nonmetro) 
summary(model5.fit_spa, rsq = TRUE, fit.measures = TRUE, standardized = TRUE) 

fit <- cfa(model5_spa, data=mi3_metro_nonmetro)

sem_pvy = lavPredictY(fit, ynames = c("paam"),
                 xnames = c("logpop", "retention_calc", "autonomy_calc", "uninsured", "age", "prosperity", "pct_mfg", "pct_ag", "pct_mine", "lag.pct_mfg", "lag.pct_ag", "lag.pct_mine", "lag.retention_calc", "lag.autonomy_calc","lag.logpop", "lag.laborforce_part_rate","lag.poverty_rate","lag.bach","lag.income_rate", "lag.age", "lag.uninsured"))





sem_pvy2 = as.data.frame(sem_pvy)
sem_pvy3 = sem_pvy2$paam

mi3_spa2 <- cbind(mi3_metro_nonmetro, sem_pvy) %>%
  mutate(r_paam = paam - paam.1)

temp = mi3_spa2$r_paam

w <- queen_weights(mi3_spa2)
nb <- poly2nb(mi3_spa2, queen=TRUE)
lw <- nb2listw(nb, style="W", zero.policy=TRUE)
lw$weights[5]
moran.test(mi3_spa2$r_paam,lw, zero.policy=TRUE)
mi3_spa2 = mi3_spa2 %>%
  filter(STATE_NAME != "Alaska" & STATE_NAME != "Hawaii")
plot(st_geometry(mi3_spa2),
     col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}),
     border = "#333333", lwd=0.2)



```

## M4-SE-SEM


```{r}

sesem_data = mi1 %>%
  mutate(Y = sf::st_coordinates(mi1$center)[,1]) %>%
  mutate(X = sf::st_coordinates(mi1$center)[,2]) %>%
  dplyr::select(X, Y, paam, laborforce_part_rate, poverty_rate, bach, income_rate, retention_calc, autonomy_calc, pct_ag, pct_mfg, pct_mine, logpop, age, uninsured) %>%
  st_drop_geometry()

sesem_data2 = as.data.frame(sesem_data)
sf::st_drop_geometry(sesem_data2)

#Step 2 calculate distance matrix and specify lag distance bin sizes

	# function calc.dist(datafile) calculates and stores the distance matrix for all X-Y pairs
	#	requires a dataset where the first two columns are x and y coordinates

# sesem_data_dist <-calc.dist(sesem_data2)
# NOTE: a unit of one is roughly equivalent to 1 mile (at least in the upper midwest)
# sesem_data_dist_AL <-calc.dist(sesem_data2)

binsize2 = c(0,1,100)
# using 0 to 50 miles as bin 1, outside that as bin 2
# results in about 5.9 neighbors per county
binname2=c("Bin1","Bin2")
plotbin(sesem_data_dist,binsize2)

sesem_data_covar<-make.covar(sesem_data2,sesem_data_dist,binsize2,binname2)

sesem_model <- '
  prosperity2 =~ laborforce_part_rate + poverty_rate + bach + income_rate

  retention_calc ~ pct_mfg + pct_ag + pct_mine
  autonomy_calc ~ pct_mfg + pct_ag + pct_mine
  prosperity2 ~ pct_mfg + pct_ag + pct_mine + a*retention_calc + autonomy_calc + logpop
  paam ~ logpop + b*prosperity2 + pct_mfg + pct_ag + pct_mine + c*retention_calc + autonomy_calc + age + uninsured
  
  # indirect (a*b)
  ab := a*b
  
  # total
  total := c + (a*b)
  
  retention_calc ~~ autonomy_calc
'

sesem_model_results<-runModels(sesem_model,sesem_data_covar)

# Step 5 Extract analysis results
	
modelsummary(sesem_model_results)

bin.results(sesem_model_results,bin="Bin1") # prints results for flat (nonspatial) bin
bin.results(sesem_model_results,bin="Bin2") # prints results for flat (nonspatial) bin
bin.results(sesem_model_results,bin="binflat") # prints results for flat (nonspatial) bin



```

### sp auto
```{r}
# 
# m1a  <- ' prosperity  =~ laborforce_part_rate + bach + poverty_rate + income_rate'
# 
# factor1 <- cfa(m1a, data=mi1,std.lv=TRUE)
# summary(factor1)
# 
# PE <- parameterEstimates(factor1) %>%
#   filter(lhs == "prosperity")
# 
# loading.laborforce_part_rate = PE %>%
#   filter(rhs == "laborforce_part_rate") %>%
#   select(est)
# loading.laborforce_part_rate = loading.laborforce_part_rate$est
# 
# loading.bach = PE %>%
#   filter(rhs == "bach") %>%
#   select(est)
# loading.bach = loading.bach$est
# 
# loading.poverty_rate = PE %>%
#   filter(rhs == "poverty_rate") %>%
#   select(est)
# loading.poverty_rate = loading.poverty_rate$est
# 
# loading.income_rate = PE %>%
#   filter(rhs == "income_rate") %>%
#   select(est)
# loading.income_rate = loading.income_rate$est
# 
# sesem_data2_sp = sesem_data2 %>%
#   mutate(prosperity = ((laborforce_part_rate*loading.laborforce_part_rate)+(income_rate*loading.income_rate)+(poverty_rate*loading.poverty_rate)+(bach*loading.bach))/4, prosperity = (prosperity-mean(prosperity, na.rm=TRUE))/sd(prosperity, na.rm=TRUE))
# 
# sesem_data_covar_sp<-make.covar(sesem_data2_sp,sesem_data_dist,binsize2,binname2)
# 
# sesem_model_sp <- '
#   retention_calc ~ pct_mfg + pct_ag + pct_mine
#   autonomy_calc ~ pct_mfg + pct_ag + pct_mine
#   prosperity ~ pct_mfg + pct_ag + pct_mine + a*retention_calc + autonomy_calc + logpop
#   paam ~ logpop + b*prosperity + pct_mfg + pct_ag + pct_mine + c*retention_calc + autonomy_calc + age + uninsured
#   
#   # indirect (a*b)
#   ab := a*b
#   
#   # total
#   total := c + (a*b)
#   
#   retention_calc ~~ autonomy_calc
# '
# 
# sesem_model_results_sp<-runModels(sesem_model_sp,sesem_data_covar_sp)
# 
# 
# fit <- cfa(sesem_model_sp, data=sesem_data2_sp)
# 
# sem_pvy = lavPredictY(fit, ynames = c("paam"),
#                  xnames = c("logpop", "retention_calc", "autonomy_calc", "uninsured", "prosperity", "age", "pct_mfg", "pct_ag", "pct_mine"))
# 
# 
# sem_pvy2 = as.data.frame(sem_pvy)
# sem_pvy3 = sem_pvy2$paam
# 
# sesem_data2_sp2 <- cbind(sesem_data2_sp, sem_pvy) %>%
#   rename("paam_orig"="paam") %>%
#   mutate(r_paam = paam_orig - paam)
# 
# temp = sesem_data2_sp2$r_paam
# 
# temp2 = mi1 %>%
#   select(place, STATE_NAME)
# 
# sesem_data2_sp3 = cbind(temp2, sesem_data2_sp2)
# 
# w <- queen_weights(sesem_data2_sp3)
# nb <- poly2nb(sesem_data2_sp3, queen=TRUE)
# lw <- nb2listw(nb, style="W", zero.policy=TRUE)
# lw$weights[5]
# moran.test(sesem_data2_sp3$r_paam,lw, zero.policy=TRUE)
# w <- queen_weights(sesem_data2_sp3)
# lisa <- local_moran(w, sesem_data2_sp3['r_paam'])
# lisa_colors <- lisa_colors(lisa)
# lisa_labels <- lisa_labels(lisa)
# lisa_clusters <- lisa_clusters(lisa)
# sesem_data2_sp3 = sesem_data2_sp3 %>%
#   filter(STATE_NAME != "Alaska" & STATE_NAME != "Hawaii")
# plot(st_geometry(sesem_data2_sp3),
#      col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}),
#      border = "#333333", lwd=0.2)
# 
# 


```



```{r}
truelove#Truelove lowland datafile
plantcomp #plant competition datafile
alexfiord #alexandra fiord datafile

# Note that if you are using the script files provided in the appendices to Lamb et al 2014
# you will need to copy the data and script files to files to your working directory, and use the following scripts to load them:
	truelove <- read.csv("data/rawdata_truelove.csv") # read Truelove lowland datafile
 	alexfiord <- read.csv("data/rawdata_Alexfiord.csv")# read Alexandra Fiord datafile
	plantcomp <- read.csv("data/rawdata_plantcomp.csv")# read Plant Competition datafile

#Step 2 calculate distance matrix and specify lag distance bin sizes

	# function calc.dist(datafile) calculates and stores the distance matrix for all X-Y pairs
	#	requires a dataset where the first two columns are x and y coordinates

truelovedist<-calc.dist(truelove)
alexfiorddist<-calc.dist(alexfiord)
plantcompdist<-calc.dist(plantcomp)

	# Need to specify 2 vectors for bin sizes:
	#	binsize is a vector of lag distances starting at 0. The following values are the upper limits of each distance bin
	#		binsize should have n+1 elements where n is the number of lag distance bins desired
	#	bin.name is a vector of unique names for each lag distance bin. there should be n elements, one for each bin

	# Bin sizes and names can be specified manually or using function make.bin

#make.bin(dist.mat,type="ALL",p.dist=50,n.bins=10,s.size=100)

	# generates cut off values for lag distance bins and corresponding bin names
	# The function has three default parameter values available, if user does not want to specify:
		#Inference distance as a percentage(p.dist) = 50%
		#Number of bins (n.bins) = 10
		#Sample size (s.size) = 100
	#dist.mat is a distance matrix produced by calc.dist
	#Can use type="ALL","n.bins" OR "s.size" to control parameter values.
	#The function produces a list object containing (1.)binsize and (2.)binname
	#These two vectors (binsize and binname) will be used by make.covar to calculate variance covariance matrices for each lag distance bin
	
	#Special note:
	#User specified number of lag distance bins OR sample size 
	#will be used to calculate initial cutoff value of each lag distance bin.
	#However, if the cutoff point is in between a lag distance bin, 
	#real cutoff will apply at the upper margin of the particular bin. 
	#Therefore, resulting number of bins are less than or equal AND 
	#resulting sample sizes are greater than or equal to the value specified by the user.
	
# function make.bin to generate all possible bins the Truelove lowland dataset to a maximum inference distance of 50%

#	note the need to extract sizes and names from the bin size object as shown below

Truelove_bins<-make.bin(truelovedist,type="ALL") #inference distance=50% AND number of bins=ALL
truebinsize<-Truelove_bins[1][[1]] #truelove lowland bin sizes
truebinname<-Truelove_bins[2][[1]] #truelove lowland bin names

# plotbin(distancematrix,binsize) provides a histogram of all pairs in the distance matrix and a plot of sample 
# 	size for the selected bin size.
	
plotbin(truelovedist,truebinsize)

	
# manual bin sizes for the Alexandra Fiord dataset
#	note that the bin name vector must have one less element than bin size
	
alexbinsize = c(0,1,2,2.2,4,5,8,16,32,64,96,128,160) #alex fiord bin sizes
alexbinname=c("Bin1","Bin2","Bin3","Bin4","Bin5","Bin6","Bin7","Bin8","Bin9","Bin10","Bin11","Bin12")#alex fiord Bin names

plotbin(alexfiorddist,alexbinsize)

# function make.bin to generate bins with 200 samples each to a maximum inference distance of 50% 
#	for the Plant Competition dataset

#	note the need to extract sizes and names from the bin size object as shown below

Plant_bins<-make.bin(plantcompdist,type="s.size",s.size=200) #inference distance=50% AND sample size=200
plantbinsize<-Plant_bins[1][[1]] #plant competition bin sizes
plantbinname<-Plant_bins[2][[1]] #plant competition bin names

plotbin(plantcompdist,plantbinsize)

	#User can use type="ALL","n.bins" OR "s.size"
	#make.covar uses binsize and binname, only if attibutes=NULL and is.vector=TRUE.


#Step 3 Calculate covariance matrices
	
	# function make.covar(datafile,distancematrix,binsize,binname) calculates variance covariance matrices
	#	for each lag distance bin and for a flat (non-spatial) bin
	#	Values in the bin summary include the low and high cut points for each bin and the count "aa.lagcnt" of 
	#	samples in each bin
	
	# this step can be computationally time consuming; the resulting object can be saved for later sesem analysis
	
truelove_covar<-make.covar(truelove,truelovedist,truebinsize,truebinname)
alex_covar<-make.covar(alexfiord,alexfiorddist,alexbinsize,alexbinname)
plant_covar<-make.covar(plantcomp,plantcompdist,plantbinsize,plantbinname)


# Step 4 Run Models

# function runModels()  
# 	lavaan library must be installed. 
#   need to specifify path model using lavaan syntax. 
#	See http://cran.r-project.org/web/packages/lavaan/lavaan.pdf for details
#	list object created by runModels() used in subsequent steps

#Truelove  and Alexandra Fiord Path Models
spatial_model<-'
	Gram ~ Moisture
	N_Fix ~ Bryoph + Lich + SoilCrust
	SoilCrust ~ Bryoph + Lich + Gram + Shrubs + Forbs	
	Bryoph ~ Gram + Shrubs + Forbs + Moisture
	Lich ~ Moisture + Forbs + Gram + Shrubs + Bryoph
	Forbs ~ Moisture
	Gram ~~ Forbs
	Shrubs ~ Moisture	
	Gram ~~ Shrubs
	Shrubs ~~ Forbs
	'

#Plant Competition Path Model
spatial_model_plant<-'
	SoilMoist ~ Topog.Pos
	ShootBio ~ TotalN + Topog.Pos + SoilMoist
	RootBio ~ TotalN + Topog.Pos + SoilMoist
	ShootBio ~~ RootBio
	LightInt ~ ShootBio + Topog.Pos
	Comp.Intensity ~ LightInt + RootBio + TotalN + SoilMoist
	SpRich ~ Comp.Intensity + SoilMoist + RootBio + ShootBio + Topog.Pos
	'

library(lavaan)

spatial_model_results_true<-runModels(spatial_model,truelove_covar)
spatial_model_results_alex<-runModels(spatial_model,alex_covar)
spatial_model_results_plant<-runModels(spatial_model_plant,plant_covar)

# Step 5 Extract analysis results

	# modelsummary() extracts basic model summary information from the object
	# created by runModels in a readable format
	
modelsummary(spatial_model_results_true)
modelsummary(spatial_model_results_alex)
modelsummary(spatial_model_results_plant)

# bin.results(spatial_model_results,bin="binflat") 
#	extracts path coefficients, standard errors, and standardized coefficients for a particular bin in a readable format

bin.results(spatial_model_results_true,bin="Bin2")# prints results for bin2 
bin.results(spatial_model_results_alex,bin="binflat") # prints results for flat (nonspatial) bin


# bin.rsquare(spatial_model_results,bin="binflat") 
#	extracts r-square values for each dependent variable for a particular bin

bin.rsquare(spatial_model_results_plant,bin="binflat")

# Step 6a plot model fit results

#	plotmodelfit(spatial_model_results,plots="all",add.line="none",rmsea_err=T,pch=16,lwd=2,lty=1)
#	model fit plotting with optional lines, and formatting

#	spatial_model_results = object output by runModels
#	plots = options for selecting fit indices to plot
#		"all" indicats all of chi square, cfi, rmsea, and srmr to be plotted 
#		"chi", "cfi", "rmsea", "srmr" select individual metrics for plotting
#	add.lines. options for plotting a fit line 
#		"none" indicates no line
#		"step" plots straight line segments between points
#		"smooth" plots a smoothed curve fit using function lowess. Smoothed lines do not include the flat model (lag distance zero)
#	rmsea_err should confidence limits for rmsea be plotted?
#	pch, lwd, lty options for formatting points and fit lines.
library(gplots)
plotmodelfit(spatial_model_results_true) # plots all metrics without lines and with rmsea errors
											# note that warnings will arise from the plotting of rmsea errors with zero length
											#these can be ignored
plotmodelfit(spatial_model_results_alex,add.line="step",rmsea_err=F,lwd=2) # plots stepped fit line
plotmodelfit(spatial_model_results_plant,add.line="smooth",rmsea_err=F,pch=16,lty=1) # plots smoothed fit line

plotmodelfit(spatial_model_results_true,plot="cfi",add.line="smooth",pch=16,lty=1,lwd=4,cex.lab=1.5,cex=2,cex.axis=1.5) #plots only cfi

# Step 6b plot path coefficent changes with lag distances

#	plotpath(spatial_model_results,path.type="directed",add.line="none",rmsea_err=T,pch=16,lwd=2,lty=1)
#   
#	spatial_model_results = object output by runModels
#	path.type= options for selecting which paths to plot
#		"directed" = only directed paths plotted
#		"undirected" = only undirected correlations plotted
#		"both" = all paths plotted
#		"user" = allows user to specify particular paths and a particular order for plotting
#			argument selectpath must also be provided with path.type="user"
#	selectpath = required when path.type="user"
#		usage is selectpath==c(5,18,16,23,29) where values refer to path numbers
#		path numbers can be obtained using spatial_model_results[2]
#	add.lines = options for plotting a fit line 
#		"none" indicates no line
#		"step" plots straight line segments between points
#		"smooth" plots a smoothed curve fit using function lowess
#	add.error = should standard error bars be added for each path coefficient
#	pcut = p-value cutoff above which points with non significant p-values are shaded grey
#		set pcut=1 to have all points black
#	pch, lwd, lty cex, cex.lab, cex.axis, cex.main options for formatting points and fit lines.

library(gplots)
plotpath(spatial_model_results_true,pch=11) # plots 
plotpath(spatial_model_results_plant,pch=16,path.type="directed",add.line="smooth")
plotpath(spatial_model_results_alex,path.type="both",add.error=F,add.line="step",pcut=0.01,lwd=1)
plotpath(spatial_model_results_true,path.type="user",selectpath=c(5,18,16,23,29),add.error=F,add.line="smooth",pcut=0.01,lwd=1)

#
#Step 6c plot changes in path coefficents using generalized additive models

#	gam.path(spatial_model_results,path.type="directed",selectpath="none selected",
#		plot.points=T,se.plot=T,lwd.pred=2,lty.pred=1,lwd.se=2,lty.se=3,cex=1,cex.axis=1,cex.lab=1
#		,xlab="Lag Distance",ylab="Unst. Path Coeff.",yaxt="s",xaxt="s")
#
#	library "mgcv" is required
   
#	This function prints some of the gam results for each path in the model as well as producing figures
   
#	spatial_model_results = object output by runModels
#	path.type= options for selecting which paths to plot
#		"directed" = only directed paths plotted
#		"undirected" = only undirected correlations plotted
#		"both" = all paths plotted
#		"user" = allows user to specify particular paths and a particular order for plotting
#			argument selectpath must also be provided with path.type="user"
#	selectpath = required when path.type="user"
#		usage is selectpath==c(5,18,16,23,29) where values refer to path numbers
#		path numbers can be obtained using spatial_model_results[2]
#	plot.points = should points be plotted on figure
#	se.plot = should standard errors for the prediction lines be printed
#	additional arguments formatting figure

#displays gam relationships for all directed paths in model

library(mgcv)

par(mar=c(2.5,2.5,1.5,1))
gam.path(spatial_model_results_true,plot.points=F,se.plot=T)

#displays gam relationships for a selection of paths in model
gam.path(spatial_model_results_plant,path.type="user",selectpath=c(5,18,16,14,7),plot.points=T,se.plot=T)

gam.path(spatial_model_results_alex,path.type="user",selectpath=c(5,18,16,14,7),plot.points=F,se.plot=F,lwd.pred=2,ylab="",xlab="",yaxt="n",xaxt="n")


#Step 7. Optimize model

# avg.modindices() extracts modification indices for all models in the object produced by runModels() 
# 		and summarizes the mod indices by taking the mean for each possible additional path
#		across all lag distance bins. The flat model is not included in these calculations
#	 modcut eliminates printing of average MI values below the cutoff. The default is 4
# 
# Based on the modification indices create a new lavaan path model description and return to step 4.


avg.modindices(spatial_model_results_true,modcut=3)# display modindices
avg.modindices(spatial_model_results_alex)# display modindices
avg.modindices(spatial_model_results_plant,modcut=1)# display modindices
```



# Output viz

```{r, fig.width=10}

viz = rbind(viz_agg, viz_regime) %>% mutate(rurality = ifelse(rurality=="agg","all",rurality), var = factor(var, levels = c('retention_calc', 'autonomy_calc', 'pct_ag', 'pct_mine', 'pct_mfg', 'laborforce_part_rate', 'bach', 'poverty_rate', 'income_rate')), rurality = factor(rurality, levels = c('nonmetro', 'metro', 'all'))) %>%
  drop_na(var)


plot1 = ggplot(viz) +
  geom_errorbar( aes(x=var, ymin=coef-(se*1.96), ymax=coef+(se*1.96), color=rurality), width=0.4, stat="identity", position = position_dodge(-.7), alpha=1.0, size=1.5) +
  ylim(-0.4, 0.53) +
  geom_hline(yintercept = 0) +
  # ggtitle("Retention") +
  ylab("Coefficents (standardized)") +
  xlab("Independent variables") +
  theme(axis.title.y = element_text(size = 10), axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1), plot.title = element_text(size = 10, face = "bold"), legend.position="bottom", plot.subtitle = element_text(size = 10)) +
  theme_pander() +
  scale_color_manual(values = c("#88CCEE", "#117733", "#332288")) 

plot1

```


```{r, fig.width=10}

viz = rbind(viz_agg, viz_regime) %>% mutate(rurality = ifelse(rurality=="agg","all",rurality), var = factor(var, levels = c('retention_calc', 'autonomy_calc', 'pct_ag', 'pct_mine', 'pct_mfg', 'laborforce_part_rate', 'bach', 'poverty_rate', 'income_rate', 'age', 'metro', 'uninsured')), rurality = factor(rurality, levels = c('nonmetro', 'metro', 'all'))) %>%
  drop_na(var)


plot1 = ggplot(viz) +
  geom_errorbar( aes(x=var, ymin=coef-(se*1.96), ymax=coef+(se*1.96), color=rurality), width=0.4, stat="identity", position = position_dodge(-.7), alpha=1.0, size=1.5) +
  ylim(-1.3, 1.9) +
  geom_hline(yintercept = 0) +
  # ggtitle("Retention") +
  ylab("Coefficents (standardized)") +
  xlab("Independent variables") +
  theme(axis.title.y = element_text(size = 10), axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1), plot.title = element_text(size = 10, face = "bold"), legend.position="bottom", plot.subtitle = element_text(size = 10)) +
  theme_pander() +
  scale_color_manual(values = c("#88CCEE", "#117733", "#332288")) 

plot1

```






#Old Code
<!-- # extra -->
<!-- ### partitioned SEM -->
<!-- #### metro -->
<!-- ```{r} -->
<!-- nb <- poly2nb(mi1, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->


<!-- slx_import = lmSLX(data = mi1, paam ~ retention_calc + autonomy_calc + pct_ag + pct_mine + pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + uninsured, lw, zero.policy=TRUE) -->

<!-- mi3 = mi1 %>% -->
<!--   mutate(lag.retention_calc = slx_import$model$lag.retention_calc, lag.autonomy_calc = slx_import$model$lag.autonomy_calc,  -->
<!--          lag.pct_ag = slx_import$model$lag.pct_ag, lag.pct_mine = slx_import$model$lag.pct_mine,  -->
<!--          lag.pct_mfg = slx_import$model$lag.pct_mfg, lag.laborforce_part_rate = slx_import$model$lag.laborforce_part_rate,  -->
<!--          lag.age = slx_import$model$lag.age, lag.bach = slx_import$model$lag.bach,  -->
<!--          lag.poverty_rate = slx_import$model$lag.poverty_rate, lag.income_rate = slx_import$model$lag.income_rate,  -->
<!--          lag.logpop = slx_import$model$lag.logpop,  -->
<!--          lag.uninsured = slx_import$model$lag.uninsured -->
<!--          ) -->

<!-- mi3_metro = mi3 %>% -->
<!--   filter(metro_nonmetro == "metro") -->

<!-- model6 <- ' -->
<!--   prosperity2 =~ laborforce_part_rate + poverty_rate + bach + income_rate -->

<!--   retention_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine -->
<!--   autonomy_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine -->
<!--   prosperity2 ~ pct_mfg + pct_ag + pct_mine + a*retention_calc + autonomy_calc + logpop + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop -->
<!--   paam ~ logpop + b*prosperity2 + pct_mfg + pct_ag + pct_mine + c*retention_calc + autonomy_calc + age + uninsured + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop + lag.laborforce_part_rate + lag.poverty_rate + lag.bach + lag.income_rate + lag.age + lag.uninsured -->

<!--   # indirect (a*b) -->
<!--   ab := a*b -->

<!--   # total -->
<!--   total := c + (a*b) -->

<!--   retention_calc ~~ autonomy_calc -->

<!-- ' -->

<!-- model6.fit <- sem(model6, data = mi3_metro)  -->
<!-- summary(model6.fit, rsq = TRUE, fit.measures = TRUE, standardized = TRUE)  -->

<!-- fit <- cfa(model6, data=mi3_metro) -->


<!-- ``` -->

<!-- #### nonmetro -->
<!-- ```{r} -->
<!-- nb <- poly2nb(mi1, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->


<!-- slx_import = lmSLX(data = mi1, paam ~ retention_calc + autonomy_calc + pct_ag + pct_mine + pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + uninsured, lw, zero.policy=TRUE) -->

<!-- mi3 = mi1 %>% -->
<!--   mutate(lag.retention_calc = slx_import$model$lag.retention_calc, lag.autonomy_calc = slx_import$model$lag.autonomy_calc,  -->
<!--          lag.pct_ag = slx_import$model$lag.pct_ag, lag.pct_mine = slx_import$model$lag.pct_mine,  -->
<!--          lag.pct_mfg = slx_import$model$lag.pct_mfg, lag.laborforce_part_rate = slx_import$model$lag.laborforce_part_rate,  -->
<!--          lag.age = slx_import$model$lag.age, lag.bach = slx_import$model$lag.bach,  -->
<!--          lag.poverty_rate = slx_import$model$lag.poverty_rate, lag.income_rate = slx_import$model$lag.income_rate,  -->
<!--          lag.logpop = slx_import$model$lag.logpop,  -->
<!--          lag.uninsured = slx_import$model$lag.uninsured -->
<!--          ) -->

<!-- mi3_nonmetro = mi3 %>% -->
<!--   filter(metro_nonmetro == "nonmetro") -->

<!-- model6 <- ' -->
<!--   prosperity2 =~ laborforce_part_rate + poverty_rate + bach + income_rate -->

<!--   retention_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine -->
<!--   autonomy_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine -->
<!--   prosperity2 ~ pct_mfg + pct_ag + pct_mine + a*retention_calc + autonomy_calc + logpop + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop -->
<!--   paam ~ logpop + b*prosperity2 + pct_mfg + pct_ag + pct_mine + c*retention_calc + autonomy_calc + age + uninsured + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop + lag.laborforce_part_rate + lag.poverty_rate + lag.bach + lag.income_rate + lag.age + lag.uninsured -->

<!--   # indirect (a*b) -->
<!--   ab := a*b -->

<!--   # total -->
<!--   total := c + (a*b) -->

<!--   retention_calc ~~ autonomy_calc -->

<!-- ' -->

<!-- model6.fit <- sem(model6, data = mi3_nonmetro)  -->
<!-- summary(model6.fit, rsq = TRUE, fit.measures = TRUE, standardized = TRUE)  -->

<!-- fit <- cfa(model6, data=mi3_nonmetro) -->
<!-- ``` -->



<!-- ## comparing covariance matrix setups -->
<!-- #### no covarance defined -->
<!-- ```{r} -->

<!-- nb <- poly2nb(mi1, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->


<!-- slx_import = lmSLX(data = mi1, paam ~ retention_calc + autonomy_calc + pct_ag + pct_mine + pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + uninsured, lw, zero.policy=TRUE) -->

<!-- mi3 = mi1 %>% -->
<!--   mutate(lag.retention_calc = slx_import$model$lag.retention_calc, lag.autonomy_calc = slx_import$model$lag.autonomy_calc,  -->
<!--          lag.pct_ag = slx_import$model$lag.pct_ag, lag.pct_mine = slx_import$model$lag.pct_mine,  -->
<!--          lag.pct_mfg = slx_import$model$lag.pct_mfg, lag.laborforce_part_rate = slx_import$model$lag.laborforce_part_rate,  -->
<!--          lag.age = slx_import$model$lag.age, lag.bach = slx_import$model$lag.bach,  -->
<!--          lag.poverty_rate = slx_import$model$lag.poverty_rate, lag.income_rate = slx_import$model$lag.income_rate,  -->
<!--          lag.logpop = slx_import$model$lag.logpop,  -->
<!--          lag.uninsured = slx_import$model$lag.uninsured -->
<!--          ) -->

<!-- model6 <- ' -->
<!--   prosperity2 =~ laborforce_part_rate + poverty_rate + bach + income_rate -->

<!--   retention_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine -->
<!--   autonomy_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine -->
<!--   prosperity2 ~ pct_mfg + pct_ag + pct_mine + a*retention_calc + autonomy_calc + logpop + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop -->
<!--   paam ~ logpop + b*prosperity2 + pct_mfg + pct_ag + pct_mine + c*retention_calc + autonomy_calc + age + uninsured + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop + lag.laborforce_part_rate + lag.poverty_rate + lag.bach + lag.income_rate + lag.age + lag.uninsured -->

<!--   # indirect (a*b) -->
<!--   ab := a*b -->

<!--   # total -->
<!--   total := c + (a*b) -->


<!-- ' -->

<!-- model6.fit <- sem(model6, data = mi3)  -->
<!-- summary(model6.fit, rsq = TRUE, fit.measures = TRUE, standardized = TRUE)  -->

<!-- fit <- cfa(model6, data=mi3) -->
<!-- ``` -->


<!-- #### only autonomy/retention -->

<!-- ```{r} -->

<!-- nb <- poly2nb(mi1, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->


<!-- slx_import = lmSLX(data = mi1, paam ~ retention_calc + autonomy_calc + pct_ag + pct_mine + pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + uninsured, lw, zero.policy=TRUE) -->

<!-- mi3 = mi1 %>% -->
<!--   mutate(lag.retention_calc = slx_import$model$lag.retention_calc, lag.autonomy_calc = slx_import$model$lag.autonomy_calc,  -->
<!--          lag.pct_ag = slx_import$model$lag.pct_ag, lag.pct_mine = slx_import$model$lag.pct_mine,  -->
<!--          lag.pct_mfg = slx_import$model$lag.pct_mfg, lag.laborforce_part_rate = slx_import$model$lag.laborforce_part_rate,  -->
<!--          lag.age = slx_import$model$lag.age, lag.bach = slx_import$model$lag.bach,  -->
<!--          lag.poverty_rate = slx_import$model$lag.poverty_rate, lag.income_rate = slx_import$model$lag.income_rate,  -->
<!--          lag.logpop = slx_import$model$lag.logpop,  -->
<!--          lag.uninsured = slx_import$model$lag.uninsured -->
<!--          ) -->

<!-- model6 <- ' -->
<!--   prosperity2 =~ laborforce_part_rate + poverty_rate + bach + income_rate -->

<!--   retention_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine -->
<!--   autonomy_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine -->
<!--   prosperity2 ~ pct_mfg + pct_ag + pct_mine + a*retention_calc + autonomy_calc + logpop + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop -->
<!--   paam ~ logpop + b*prosperity2 + pct_mfg + pct_ag + pct_mine + c*retention_calc + autonomy_calc + age + uninsured + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop + lag.laborforce_part_rate + lag.poverty_rate + lag.bach + lag.income_rate + lag.age + lag.uninsured -->

<!--   # indirect (a*b) -->
<!--   ab := a*b -->

<!--   # total -->
<!--   total := c + (a*b) -->

<!--   retention_calc ~~ autonomy_calc -->


<!-- ' -->

<!-- model6.fit <- sem(model6, data = mi3)  -->
<!-- summary(model6.fit, rsq = TRUE, fit.measures = TRUE, standardized = TRUE)  -->

<!-- fit <- cfa(model6, data=mi3) -->
<!-- ``` -->


<!-- #### retention/autonomy & logpop -->
<!-- ```{r} -->

<!-- nb <- poly2nb(mi1, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->


<!-- slx_import = lmSLX(data = mi1, paam ~ retention_calc + autonomy_calc + pct_ag + pct_mine + pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + uninsured, lw, zero.policy=TRUE) -->

<!-- mi3 = mi1 %>% -->
<!--   mutate(lag.retention_calc = slx_import$model$lag.retention_calc, lag.autonomy_calc = slx_import$model$lag.autonomy_calc,  -->
<!--          lag.pct_ag = slx_import$model$lag.pct_ag, lag.pct_mine = slx_import$model$lag.pct_mine,  -->
<!--          lag.pct_mfg = slx_import$model$lag.pct_mfg, lag.laborforce_part_rate = slx_import$model$lag.laborforce_part_rate,  -->
<!--          lag.age = slx_import$model$lag.age, lag.bach = slx_import$model$lag.bach,  -->
<!--          lag.poverty_rate = slx_import$model$lag.poverty_rate, lag.income_rate = slx_import$model$lag.income_rate,  -->
<!--          lag.logpop = slx_import$model$lag.logpop,  -->
<!--          lag.uninsured = slx_import$model$lag.uninsured -->
<!--          ) -->

<!-- model6 <- ' -->
<!--   prosperity2 =~ laborforce_part_rate + poverty_rate + bach + income_rate -->

<!--   retention_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine -->
<!--   autonomy_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine -->
<!--   prosperity2 ~ pct_mfg + pct_ag + pct_mine + a*retention_calc + autonomy_calc + logpop + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop -->
<!--   paam ~ logpop + b*prosperity2 + pct_mfg + pct_ag + pct_mine + c*retention_calc + autonomy_calc + age + uninsured + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop + lag.laborforce_part_rate + lag.poverty_rate + lag.bach + lag.income_rate + lag.age + lag.uninsured -->

<!--   # indirect (a*b) -->
<!--   ab := a*b -->

<!--   # total -->
<!--   total := c + (a*b) -->

<!--   logpop ~~ poverty_rate -->
<!--   logpop ~~ bach -->
<!--   logpop ~~ income_rate -->
<!--   logpop ~~ pct_mfg -->
<!--   logpop ~~ pct_ag -->
<!--   logpop ~~ pct_mine -->
<!--   logpop ~~ retention_calc -->
<!--   logpop ~~ autonomy_calc -->
<!--   logpop ~~ age -->
<!--   logpop ~~ uninsured -->
<!--   retention_calc ~~ autonomy_calc -->

<!-- ' -->

<!-- model6.fit <- sem(model6, data = mi3)  -->
<!-- summary(model6.fit, rsq = TRUE, fit.measures = TRUE, standardized = TRUE)  -->

<!-- fit <- cfa(model6, data=mi3) -->
<!-- ``` -->


<!-- ## latent covaraties -->
<!-- ```{r} -->

<!-- nb <- poly2nb(mi1, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->


<!-- slx_import = lmSLX(data = mi1, paam ~ retention_calc + autonomy_calc + pct_ag + pct_mine + pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + uninsured, lw, zero.policy=TRUE) -->

<!-- mi3 = mi1 %>% -->
<!--   mutate(lag.retention_calc = slx_import$model$lag.retention_calc, lag.autonomy_calc = slx_import$model$lag.autonomy_calc,  -->
<!--          lag.pct_ag = slx_import$model$lag.pct_ag, lag.pct_mine = slx_import$model$lag.pct_mine,  -->
<!--          lag.pct_mfg = slx_import$model$lag.pct_mfg, lag.laborforce_part_rate = slx_import$model$lag.laborforce_part_rate,  -->
<!--          lag.age = slx_import$model$lag.age, lag.bach = slx_import$model$lag.bach,  -->
<!--          lag.poverty_rate = slx_import$model$lag.poverty_rate, lag.income_rate = slx_import$model$lag.income_rate,  -->
<!--          lag.logpop = slx_import$model$lag.logpop,  -->
<!--          lag.uninsured = slx_import$model$lag.uninsured -->
<!--          ) -->

<!-- model6 <- ' -->
<!--   prosperity2 =~ laborforce_part_rate + poverty_rate + bach + income_rate -->
<!--   controls2 =~ age + uninsured + logpop -->

<!--   retention_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine -->
<!--   autonomy_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine -->
<!--   prosperity2 ~ pct_mfg + pct_ag + pct_mine + a*retention_calc + autonomy_calc + logpop + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop -->
<!--   paam ~ controls2 + b*prosperity2 + pct_mfg + pct_ag + pct_mine + c*retention_calc + autonomy_calc + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop + lag.laborforce_part_rate + lag.poverty_rate + lag.bach + lag.income_rate + lag.age + lag.uninsured -->

<!--   # indirect (a*b) -->
<!--   ab := a*b -->

<!--   # total -->
<!--   total := c + (a*b) -->

<!--   retention_calc ~~ autonomy_calc -->


<!-- ' -->

<!-- model6.fit <- sem(model6, data = mi3)  -->
<!-- summary(model6.fit, rsq = TRUE, fit.measures = TRUE, standardized = TRUE)  -->

<!-- fit <- cfa(model6, data=mi3) -->
<!-- ``` -->






<!-- # Clean models (interact) -->
<!-- ## OLS -->
<!-- ### retention & autonomy -->
<!-- #### 1.) industry > trade -->
<!-- ```{r} -->
<!-- ols1a1 = lm(data = mi1, retention_calc ~ pct_ag + pct_mine + pct_mfg + logpop + metro) -->
<!-- ols1a2 = lm(data = mi1, autonomy_calc ~ pct_ag + pct_mine + pct_mfg + logpop + metro) -->

<!-- summary(ols1a1) -->
<!-- summary(ols1a2) -->
<!-- ``` -->

<!-- #### 2.) industry + trade > prosperity -->
<!-- ```{r} -->

<!-- m1a  <- ' prosperity  =~ laborforce_part_rate + bach + poverty_rate + income_rate' -->

<!-- factor1 <- cfa(m1a, data=mi1,std.lv=TRUE) -->
<!-- summary(factor1) -->

<!-- PE <- parameterEstimates(factor1) %>% -->
<!--   filter(lhs == "prosperity") -->

<!-- loading.laborforce_part_rate = PE %>% -->
<!--   filter(rhs == "laborforce_part_rate") %>% -->
<!--   select(est) -->
<!-- loading.laborforce_part_rate = loading.laborforce_part_rate$est -->

<!-- loading.bach = PE %>% -->
<!--   filter(rhs == "bach") %>% -->
<!--   select(est) -->
<!-- loading.bach = loading.bach$est -->

<!-- loading.poverty_rate = PE %>% -->
<!--   filter(rhs == "poverty_rate") %>% -->
<!--   select(est) -->
<!-- loading.poverty_rate = loading.poverty_rate$est -->

<!-- loading.income_rate = PE %>% -->
<!--   filter(rhs == "income_rate") %>% -->
<!--   select(est) -->
<!-- loading.income_rate = loading.income_rate$est -->

<!-- mi2 = mi1 %>% -->
<!--   mutate(prosperity = ((laborforce_part_rate*loading.laborforce_part_rate)+(income_rate*loading.income_rate)+(poverty_rate*loading.poverty_rate)+(bach*loading.bach))/4, prosperity = (prosperity-mean(prosperity, na.rm=TRUE))/sd(prosperity, na.rm=TRUE)) -->


<!-- ols2a = lm(data = mi2, prosperity ~ retention_calc + autonomy_calc + pct_ag + pct_mine + pct_mfg + retention_calc*pct_ag + retention_calc*pct_mine + retention_calc*pct_mfg + autonomy_calc*pct_ag + autonomy_calc*pct_mine + autonomy_calc*pct_mfg + logpop + metro) -->

<!-- summary(ols2a) -->
<!-- ``` -->

<!-- #### 3.) full -->
<!-- ```{r} -->

<!-- ols3a = lm(data = mi1, paam ~ retention_calc + autonomy_calc + pct_ag + pct_mine + pct_mfg + retention_calc*pct_ag + retention_calc*pct_mine + retention_calc*pct_mfg + autonomy_calc*pct_ag + autonomy_calc*pct_mine + autonomy_calc*pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + metro + uninsured) -->

<!-- summary(ols3a) -->

<!-- # global and local autocorrelation -->
<!-- Q2ar = mi1 -->
<!-- Q2ar$r = ols3a$resid -->
<!-- nb <- poly2nb(Q2ar, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->
<!-- lw$weights[5] -->
<!-- moran.test(Q2ar$r,lw, zero.policy=TRUE) -->
<!-- w <- queen_weights(Q2ar) -->
<!-- lisa <- local_moran(w, Q2ar['r']) -->
<!-- lisa_colors <- lisa_colors(lisa) -->
<!-- lisa_labels <- lisa_labels(lisa) -->
<!-- lisa_clusters <- lisa_clusters(lisa) -->
<!-- plot(st_geometry(Q2ar),  -->
<!--      col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}),  -->
<!--      border = "#333333", lwd=0.2) -->
<!--  -->
<!--  -->
<!-- ``` -->

<!-- ### retention only -->
<!-- #### 1.) industry > trade -->
<!-- ```{r} -->
<!-- ols2a1 = lm(data = mi1, retention_calc ~ pct_ag + pct_mine + pct_mfg + logpop + metro) -->

<!-- summary(ols2a1) -->
<!-- ``` -->

<!-- #### 2.) industry + trade > prosperity -->
<!-- ```{r} -->

<!-- m1a  <- ' prosperity  =~ laborforce_part_rate + bach + poverty_rate + income_rate' -->

<!-- factor1 <- cfa(m1a, data=mi1,std.lv=TRUE) -->
<!-- summary(factor1) -->

<!-- PE <- parameterEstimates(factor1) %>% -->
<!--   filter(lhs == "prosperity") -->

<!-- loading.laborforce_part_rate = PE %>% -->
<!--   filter(rhs == "laborforce_part_rate") %>% -->
<!--   select(est) -->
<!-- loading.laborforce_part_rate = loading.laborforce_part_rate$est -->

<!-- loading.bach = PE %>% -->
<!--   filter(rhs == "bach") %>% -->
<!--   select(est) -->
<!-- loading.bach = loading.bach$est -->

<!-- loading.poverty_rate = PE %>% -->
<!--   filter(rhs == "poverty_rate") %>% -->
<!--   select(est) -->
<!-- loading.poverty_rate = loading.poverty_rate$est -->

<!-- loading.income_rate = PE %>% -->
<!--   filter(rhs == "income_rate") %>% -->
<!--   select(est) -->
<!-- loading.income_rate = loading.income_rate$est -->

<!-- mi2 = mi1 %>% -->
<!--   mutate(prosperity = ((laborforce_part_rate*loading.laborforce_part_rate)+(income_rate*loading.income_rate)+(poverty_rate*loading.poverty_rate)+(bach*loading.bach))/4, prosperity = (prosperity-mean(prosperity, na.rm=TRUE))/sd(prosperity, na.rm=TRUE)) -->


<!-- ols2a = lm(data = mi2, prosperity ~ retention_calc + pct_ag + pct_mine + pct_mfg + retention_calc*pct_ag + retention_calc*pct_mine + retention_calc*pct_mfg + logpop + metro) -->

<!-- summary(ols2a) -->
<!-- ``` -->

<!-- #### 3.) full -->
<!-- ```{r} -->

<!-- ols3a = lm(data = mi1, paam ~ retention_calc + pct_ag + pct_mine + pct_mfg + retention_calc*pct_ag + retention_calc*pct_mine + retention_calc*pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + metro + uninsured) -->

<!-- summary(ols3a) -->

<!-- # global and local autocorrelation -->
<!-- Q2ar = mi1 -->
<!-- Q2ar$r = ols3a$resid -->
<!-- nb <- poly2nb(Q2ar, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->
<!-- lw$weights[5] -->
<!-- moran.test(Q2ar$r,lw, zero.policy=TRUE) -->
<!-- w <- queen_weights(Q2ar) -->
<!-- lisa <- local_moran(w, Q2ar['r']) -->
<!-- lisa_colors <- lisa_colors(lisa) -->
<!-- lisa_labels <- lisa_labels(lisa) -->
<!-- lisa_clusters <- lisa_clusters(lisa) -->
<!-- plot(st_geometry(Q2ar),  -->
<!--      col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}),  -->
<!--      border = "#333333", lwd=0.2) -->
<!--  -->
<!--  -->
<!-- ``` -->



<!-- ### autonomy only -->
<!-- #### 1.) industry > trade -->
<!-- ```{r} -->
<!-- ols1a2 = lm(data = mi1, autonomy_calc ~ pct_ag + pct_mine + pct_mfg + logpop + metro) -->

<!-- summary(ols1a2) -->
<!-- ``` -->

<!-- #### 2.) industry + trade > prosperity -->
<!-- ```{r} -->

<!-- m1a  <- ' prosperity  =~ laborforce_part_rate + bach + poverty_rate + income_rate' -->

<!-- factor1 <- cfa(m1a, data=mi1,std.lv=TRUE) -->
<!-- summary(factor1) -->

<!-- PE <- parameterEstimates(factor1) %>% -->
<!--   filter(lhs == "prosperity") -->

<!-- loading.laborforce_part_rate = PE %>% -->
<!--   filter(rhs == "laborforce_part_rate") %>% -->
<!--   select(est) -->
<!-- loading.laborforce_part_rate = loading.laborforce_part_rate$est -->

<!-- loading.bach = PE %>% -->
<!--   filter(rhs == "bach") %>% -->
<!--   select(est) -->
<!-- loading.bach = loading.bach$est -->

<!-- loading.poverty_rate = PE %>% -->
<!--   filter(rhs == "poverty_rate") %>% -->
<!--   select(est) -->
<!-- loading.poverty_rate = loading.poverty_rate$est -->

<!-- loading.income_rate = PE %>% -->
<!--   filter(rhs == "income_rate") %>% -->
<!--   select(est) -->
<!-- loading.income_rate = loading.income_rate$est -->

<!-- mi2 = mi1 %>% -->
<!--   mutate(prosperity = ((laborforce_part_rate*loading.laborforce_part_rate)+(income_rate*loading.income_rate)+(poverty_rate*loading.poverty_rate)+(bach*loading.bach))/4, prosperity = (prosperity-mean(prosperity, na.rm=TRUE))/sd(prosperity, na.rm=TRUE)) -->


<!-- ols2a = lm(data = mi2, prosperity ~ autonomy_calc + pct_ag + pct_mine + pct_mfg + autonomy_calc*pct_ag + autonomy_calc*pct_mine + autonomy_calc*pct_mfg + logpop + metro) -->

<!-- summary(ols2a) -->
<!-- ``` -->

<!-- #### 3.) full -->
<!-- ```{r} -->

<!-- ols3a = lm(data = mi1, paam ~ autonomy_calc + pct_ag + pct_mine + pct_mfg + autonomy_calc*pct_ag + autonomy_calc*pct_mine + autonomy_calc*pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + metro + uninsured) -->

<!-- summary(ols3a) -->

<!-- # global and local autocorrelation -->
<!-- Q2ar = mi1 -->
<!-- Q2ar$r = ols3a$resid -->
<!-- nb <- poly2nb(Q2ar, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->
<!-- lw$weights[5] -->
<!-- moran.test(Q2ar$r,lw, zero.policy=TRUE) -->
<!-- w <- queen_weights(Q2ar) -->
<!-- lisa <- local_moran(w, Q2ar['r']) -->
<!-- lisa_colors <- lisa_colors(lisa) -->
<!-- lisa_labels <- lisa_labels(lisa) -->
<!-- lisa_clusters <- lisa_clusters(lisa) -->
<!-- plot(st_geometry(Q2ar),  -->
<!--      col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}),  -->
<!--      border = "#333333", lwd=0.2) -->
<!--  -->
<!--  -->
<!-- ``` -->



<!-- ## Sp Error -->

<!-- ### retention & autonomy -->
<!-- #### 1.) industry > trade -->
<!-- ```{r} -->
<!-- nb <- poly2nb(mi1, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->


<!-- ols1a1 = errorsarlm(data = mi1, retention_calc ~ pct_ag + pct_mine + pct_mfg + logpop + metro, -->
<!--                   lw, zero.policy = TRUE) -->
<!-- ols1a2 = errorsarlm(data = mi1, autonomy_calc ~ pct_ag + pct_mine + pct_mfg + logpop + metro, -->
<!--                   lw, zero.policy = TRUE) -->

<!-- summary(ols1a1) -->
<!-- summary(ols1a2) -->
<!-- ``` -->

<!-- #### 2.) industry + trade > prosperity -->
<!-- ```{r} -->

<!-- m1a  <- ' prosperity  =~ laborforce_part_rate + bach + poverty_rate + income_rate' -->

<!-- factor1 <- cfa(m1a, data=mi1,std.lv=TRUE) -->
<!-- summary(factor1) -->

<!-- PE <- parameterEstimates(factor1) %>% -->
<!--   filter(lhs == "prosperity") -->

<!-- loading.laborforce_part_rate = PE %>% -->
<!--   filter(rhs == "laborforce_part_rate") %>% -->
<!--   select(est) -->
<!-- loading.laborforce_part_rate = loading.laborforce_part_rate$est -->

<!-- loading.bach = PE %>% -->
<!--   filter(rhs == "bach") %>% -->
<!--   select(est) -->
<!-- loading.bach = loading.bach$est -->

<!-- loading.poverty_rate = PE %>% -->
<!--   filter(rhs == "poverty_rate") %>% -->
<!--   select(est) -->
<!-- loading.poverty_rate = loading.poverty_rate$est -->

<!-- loading.income_rate = PE %>% -->
<!--   filter(rhs == "income_rate") %>% -->
<!--   select(est) -->
<!-- loading.income_rate = loading.income_rate$est -->

<!-- mi2 = mi1 %>% -->
<!--   mutate(prosperity = ((laborforce_part_rate*loading.laborforce_part_rate)+(income_rate*loading.income_rate)+(poverty_rate*loading.poverty_rate)+(bach*loading.bach))/4, prosperity = (prosperity-mean(prosperity, na.rm=TRUE))/sd(prosperity, na.rm=TRUE)) -->

<!-- nb <- poly2nb(mi2, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->


<!-- ols2a = errorsarlm(data = mi2, prosperity ~ retention_calc + autonomy_calc + pct_ag + pct_mine + pct_mfg + retention_calc*pct_ag + retention_calc*pct_mine + retention_calc*pct_mfg + autonomy_calc*pct_ag + autonomy_calc*pct_mine + autonomy_calc*pct_mfg + logpop + metro, -->
<!--                   lw, zero.policy = TRUE) -->

<!-- summary(ols2a) -->
<!-- ``` -->

<!-- #### 3.) full -->
<!-- ```{r} -->

<!-- nb <- poly2nb(mi1, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->

<!-- ols3a = errorsarlm(data = mi1, paam ~ retention_calc + autonomy_calc + pct_ag + pct_mine + pct_mfg + retention_calc*pct_ag + retention_calc*pct_mine + retention_calc*pct_mfg + autonomy_calc*pct_ag + autonomy_calc*pct_mine + autonomy_calc*pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + metro + uninsured, -->
<!--                   lw, zero.policy = TRUE) -->

<!-- summary(ols3a) -->

<!-- # global and local autocorrelation -->
<!-- Q2ar = mi1 -->
<!-- Q2ar$r = ols3a$resid -->
<!-- nb <- poly2nb(Q2ar, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->
<!-- lw$weights[5] -->
<!-- moran.test(Q2ar$r,lw, zero.policy=TRUE) -->
<!-- w <- queen_weights(Q2ar) -->
<!-- lisa <- local_moran(w, Q2ar['r']) -->
<!-- lisa_colors <- lisa_colors(lisa) -->
<!-- lisa_labels <- lisa_labels(lisa) -->
<!-- lisa_clusters <- lisa_clusters(lisa) -->
<!-- plot(st_geometry(Q2ar),  -->
<!--      col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}),  -->
<!--      border = "#333333", lwd=0.2) -->
<!--  -->
<!--  -->
<!-- ``` -->

<!-- ### retention only -->
<!-- #### 1.) industry > trade -->
<!-- ```{r} -->
<!-- nb <- poly2nb(mi1, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->

<!-- ols2a1 = errorsarlm(data = mi1, retention_calc ~ pct_ag + pct_mine + pct_mfg + logpop + metro, -->
<!--                   lw, zero.policy = TRUE) -->

<!-- summary(ols2a1) -->
<!-- ``` -->

<!-- #### 2.) industry + trade > prosperity -->
<!-- ```{r} -->

<!-- m1a  <- ' prosperity  =~ laborforce_part_rate + bach + poverty_rate + income_rate' -->

<!-- factor1 <- cfa(m1a, data=mi1,std.lv=TRUE) -->
<!-- summary(factor1) -->

<!-- PE <- parameterEstimates(factor1) %>% -->
<!--   filter(lhs == "prosperity") -->

<!-- loading.laborforce_part_rate = PE %>% -->
<!--   filter(rhs == "laborforce_part_rate") %>% -->
<!--   select(est) -->
<!-- loading.laborforce_part_rate = loading.laborforce_part_rate$est -->

<!-- loading.bach = PE %>% -->
<!--   filter(rhs == "bach") %>% -->
<!--   select(est) -->
<!-- loading.bach = loading.bach$est -->

<!-- loading.poverty_rate = PE %>% -->
<!--   filter(rhs == "poverty_rate") %>% -->
<!--   select(est) -->
<!-- loading.poverty_rate = loading.poverty_rate$est -->

<!-- loading.income_rate = PE %>% -->
<!--   filter(rhs == "income_rate") %>% -->
<!--   select(est) -->
<!-- loading.income_rate = loading.income_rate$est -->

<!-- mi2 = mi1 %>% -->
<!--   mutate(prosperity = ((laborforce_part_rate*loading.laborforce_part_rate)+(income_rate*loading.income_rate)+(poverty_rate*loading.poverty_rate)+(bach*loading.bach))/4, prosperity = (prosperity-mean(prosperity, na.rm=TRUE))/sd(prosperity, na.rm=TRUE)) -->

<!-- nb <- poly2nb(mi2, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->


<!-- ols2a = errorsarlm(data = mi2, prosperity ~ retention_calc + pct_ag + pct_mine + pct_mfg + retention_calc*pct_ag + retention_calc*pct_mine + retention_calc*pct_mfg + logpop + metro, -->
<!--                   lw, zero.policy = TRUE) -->

<!-- summary(ols2a) -->
<!-- ``` -->

<!-- #### 3.) full -->
<!-- ```{r} -->

<!-- nb <- poly2nb(mi1, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->

<!-- ols3a = errorsarlm(data = mi1, paam ~ retention_calc + pct_ag + pct_mine + pct_mfg + retention_calc*pct_ag + retention_calc*pct_mine + retention_calc*pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + metro + uninsured, -->
<!--                   lw, zero.policy = TRUE) -->

<!-- summary(ols3a) -->

<!-- # global and local autocorrelation -->
<!-- Q2ar = mi1 -->
<!-- Q2ar$r = ols3a$resid -->
<!-- nb <- poly2nb(Q2ar, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->
<!-- lw$weights[5] -->
<!-- moran.test(Q2ar$r,lw, zero.policy=TRUE) -->
<!-- w <- queen_weights(Q2ar) -->
<!-- lisa <- local_moran(w, Q2ar['r']) -->
<!-- lisa_colors <- lisa_colors(lisa) -->
<!-- lisa_labels <- lisa_labels(lisa) -->
<!-- lisa_clusters <- lisa_clusters(lisa) -->
<!-- plot(st_geometry(Q2ar),  -->
<!--      col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}),  -->
<!--      border = "#333333", lwd=0.2) -->
<!--  -->
<!--  -->
<!-- ``` -->



<!-- ### autonomy only -->
<!-- #### 1.) industry > trade -->
<!-- ```{r} -->
<!-- nb <- poly2nb(mi1, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->

<!-- ols1a2 = errorsarlm(data = mi1, autonomy_calc ~ pct_ag + pct_mine + pct_mfg + logpop + metro, -->
<!--                   lw, zero.policy = TRUE) -->

<!-- summary(ols1a2) -->
<!-- ``` -->

<!-- #### 2.) industry + trade > prosperity -->
<!-- ```{r} -->

<!-- m1a  <- ' prosperity  =~ laborforce_part_rate + bach + poverty_rate + income_rate' -->

<!-- factor1 <- cfa(m1a, data=mi1,std.lv=TRUE) -->
<!-- summary(factor1) -->

<!-- PE <- parameterEstimates(factor1) %>% -->
<!--   filter(lhs == "prosperity") -->

<!-- loading.laborforce_part_rate = PE %>% -->
<!--   filter(rhs == "laborforce_part_rate") %>% -->
<!--   select(est) -->
<!-- loading.laborforce_part_rate = loading.laborforce_part_rate$est -->

<!-- loading.bach = PE %>% -->
<!--   filter(rhs == "bach") %>% -->
<!--   select(est) -->
<!-- loading.bach = loading.bach$est -->

<!-- loading.poverty_rate = PE %>% -->
<!--   filter(rhs == "poverty_rate") %>% -->
<!--   select(est) -->
<!-- loading.poverty_rate = loading.poverty_rate$est -->

<!-- loading.income_rate = PE %>% -->
<!--   filter(rhs == "income_rate") %>% -->
<!--   select(est) -->
<!-- loading.income_rate = loading.income_rate$est -->

<!-- mi2 = mi1 %>% -->
<!--   mutate(prosperity = ((laborforce_part_rate*loading.laborforce_part_rate)+(income_rate*loading.income_rate)+(poverty_rate*loading.poverty_rate)+(bach*loading.bach))/4, prosperity = (prosperity-mean(prosperity, na.rm=TRUE))/sd(prosperity, na.rm=TRUE)) -->

<!-- nb <- poly2nb(mi2, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->


<!-- ols2a = errorsarlm(data = mi2, prosperity ~ autonomy_calc + pct_ag + pct_mine + pct_mfg + autonomy_calc*pct_ag + autonomy_calc*pct_mine + autonomy_calc*pct_mfg + logpop + metro, -->
<!--                   lw, zero.policy = TRUE) -->

<!-- summary(ols2a) -->
<!-- ``` -->

<!-- #### 3.) full -->
<!-- ```{r} -->
<!-- nb <- poly2nb(mi1, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->

<!-- ols3a = errorsarlm(data = mi1, paam ~ autonomy_calc + pct_ag + pct_mine + pct_mfg + autonomy_calc*pct_ag + autonomy_calc*pct_mine + autonomy_calc*pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + metro + uninsured, -->
<!--                   lw, zero.policy = TRUE) -->

<!-- summary(ols3a) -->

<!-- # global and local autocorrelation -->
<!-- Q2ar = mi1 -->
<!-- Q2ar$r = ols3a$resid -->
<!-- nb <- poly2nb(Q2ar, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->
<!-- lw$weights[5] -->
<!-- moran.test(Q2ar$r,lw, zero.policy=TRUE) -->
<!-- w <- queen_weights(Q2ar) -->
<!-- lisa <- local_moran(w, Q2ar['r']) -->
<!-- lisa_colors <- lisa_colors(lisa) -->
<!-- lisa_labels <- lisa_labels(lisa) -->
<!-- lisa_clusters <- lisa_clusters(lisa) -->
<!-- plot(st_geometry(Q2ar),  -->
<!--      col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}),  -->
<!--      border = "#333333", lwd=0.2) -->
<!--  -->
<!--  -->
<!-- ``` -->




<!-- ## Regime - metro/non -->
<!-- ```{r} -->
<!-- nb <- poly2nb(mi1, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->

<!-- sr_data = mi1 %>% mutate(sr = metro_nonmetro) -->

<!-- sr2a = errorsarlm(data = sr_data, paam ~ 0 + sr/(retention_calc + autonomy_calc + pct_mfg + pct_ag + laborforce_part_rate + pct_mine + age + bach + poverty_rate + income_rate + logpop + uninsured), -->
<!--                   lw, zero.policy = TRUE) -->

<!-- ``` -->

<!-- ### retention & autonomy -->
<!-- #### 1.) industry > trade -->
<!-- ```{r} -->
<!-- nb <- poly2nb(mi1, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->

<!-- sr_data = mi1 %>% mutate(sr = metro_nonmetro) -->

<!-- ols1a1 = errorsarlm(data = sr_data, retention_calc ~ 0 + sr/(pct_ag + pct_mine + pct_mfg + logpop + metro), -->
<!--                   lw, zero.policy = TRUE) -->
<!-- ols1a2 = errorsarlm(data = sr_data, autonomy_calc ~ 0 + sr/(pct_ag + pct_mine + pct_mfg + logpop + metro), -->
<!--                   lw, zero.policy = TRUE) -->

<!-- summary(ols1a1) -->
<!-- summary(ols1a2) -->
<!-- ``` -->

<!-- #### 2.) industry + trade > prosperity -->
<!-- ```{r} -->

<!-- m1a  <- ' prosperity  =~ laborforce_part_rate + bach + poverty_rate + income_rate' -->

<!-- factor1 <- cfa(m1a, data=mi1,std.lv=TRUE) -->
<!-- summary(factor1) -->

<!-- PE <- parameterEstimates(factor1) %>% -->
<!--   filter(lhs == "prosperity") -->

<!-- loading.laborforce_part_rate = PE %>% -->
<!--   filter(rhs == "laborforce_part_rate") %>% -->
<!--   select(est) -->
<!-- loading.laborforce_part_rate = loading.laborforce_part_rate$est -->

<!-- loading.bach = PE %>% -->
<!--   filter(rhs == "bach") %>% -->
<!--   select(est) -->
<!-- loading.bach = loading.bach$est -->

<!-- loading.poverty_rate = PE %>% -->
<!--   filter(rhs == "poverty_rate") %>% -->
<!--   select(est) -->
<!-- loading.poverty_rate = loading.poverty_rate$est -->

<!-- loading.income_rate = PE %>% -->
<!--   filter(rhs == "income_rate") %>% -->
<!--   select(est) -->
<!-- loading.income_rate = loading.income_rate$est -->

<!-- mi2 = mi1 %>% -->
<!--   mutate(prosperity = ((laborforce_part_rate*loading.laborforce_part_rate)+(income_rate*loading.income_rate)+(poverty_rate*loading.poverty_rate)+(bach*loading.bach))/4, prosperity = (prosperity-mean(prosperity, na.rm=TRUE))/sd(prosperity, na.rm=TRUE)) -->

<!-- sr_data = mi2 %>% mutate(sr = metro_nonmetro) -->

<!-- nb <- poly2nb(mi2, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->


<!-- ols2a = errorsarlm(data = sr_data, prosperity ~ 0 + sr/(retention_calc + autonomy_calc + pct_ag + pct_mine + pct_mfg + retention_calc*pct_ag + retention_calc*pct_mine + retention_calc*pct_mfg + autonomy_calc*pct_ag + autonomy_calc*pct_mine + autonomy_calc*pct_mfg + logpop + metro), -->
<!--                   lw, zero.policy = TRUE) -->

<!-- summary(ols2a) -->
<!-- ``` -->

<!-- #### 3.) full -->
<!-- ```{r} -->

<!-- nb <- poly2nb(mi1, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->

<!-- sr_data = mi1 %>% mutate(sr = metro_nonmetro) -->

<!-- ols3a = errorsarlm(data = sr_data, paam ~ 0 + sr/(retention_calc + autonomy_calc + pct_ag + pct_mine + pct_mfg + retention_calc*pct_ag + retention_calc*pct_mine + retention_calc*pct_mfg + autonomy_calc*pct_ag + autonomy_calc*pct_mine + autonomy_calc*pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + metro + uninsured), -->
<!--                   lw, zero.policy = TRUE) -->

<!-- summary(ols3a) -->

<!-- # global and local autocorrelation -->
<!-- Q2ar = mi1 -->
<!-- Q2ar$r = ols3a$resid -->
<!-- nb <- poly2nb(Q2ar, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->
<!-- lw$weights[5] -->
<!-- moran.test(Q2ar$r,lw, zero.policy=TRUE) -->
<!-- w <- queen_weights(Q2ar) -->
<!-- lisa <- local_moran(w, Q2ar['r']) -->
<!-- lisa_colors <- lisa_colors(lisa) -->
<!-- lisa_labels <- lisa_labels(lisa) -->
<!-- lisa_clusters <- lisa_clusters(lisa) -->
<!-- plot(st_geometry(Q2ar),  -->
<!--      col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}),  -->
<!--      border = "#333333", lwd=0.2) -->
<!--  -->
<!--  -->
<!-- ``` -->

<!-- ### retention only -->
<!-- #### 1.) industry > trade -->
<!-- ```{r} -->
<!-- nb <- poly2nb(mi1, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->

<!-- sr_data = mi1 %>% mutate(sr = metro_nonmetro) -->

<!-- ols2a1 = errorsarlm(data = sr_data, retention_calc ~ 0 + sr/(pct_ag + pct_mine + pct_mfg + logpop + metro), -->
<!--                   lw, zero.policy = TRUE) -->

<!-- summary(ols2a1) -->
<!-- ``` -->

<!-- #### 2.) industry + trade > prosperity -->
<!-- ```{r} -->

<!-- m1a  <- ' prosperity  =~ laborforce_part_rate + bach + poverty_rate + income_rate' -->

<!-- factor1 <- cfa(m1a, data=mi1,std.lv=TRUE) -->
<!-- summary(factor1) -->

<!-- PE <- parameterEstimates(factor1) %>% -->
<!--   filter(lhs == "prosperity") -->

<!-- loading.laborforce_part_rate = PE %>% -->
<!--   filter(rhs == "laborforce_part_rate") %>% -->
<!--   select(est) -->
<!-- loading.laborforce_part_rate = loading.laborforce_part_rate$est -->

<!-- loading.bach = PE %>% -->
<!--   filter(rhs == "bach") %>% -->
<!--   select(est) -->
<!-- loading.bach = loading.bach$est -->

<!-- loading.poverty_rate = PE %>% -->
<!--   filter(rhs == "poverty_rate") %>% -->
<!--   select(est) -->
<!-- loading.poverty_rate = loading.poverty_rate$est -->

<!-- loading.income_rate = PE %>% -->
<!--   filter(rhs == "income_rate") %>% -->
<!--   select(est) -->
<!-- loading.income_rate = loading.income_rate$est -->

<!-- mi2 = mi1 %>% -->
<!--   mutate(prosperity = ((laborforce_part_rate*loading.laborforce_part_rate)+(income_rate*loading.income_rate)+(poverty_rate*loading.poverty_rate)+(bach*loading.bach))/4, prosperity = (prosperity-mean(prosperity, na.rm=TRUE))/sd(prosperity, na.rm=TRUE)) -->

<!-- nb <- poly2nb(mi2, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->

<!-- sr_data = mi2 %>% mutate(sr = metro_nonmetro) -->


<!-- ols2a = errorsarlm(data = sr_data, prosperity ~ 0 + sr/(retention_calc + pct_ag + pct_mine + pct_mfg + retention_calc*pct_ag + retention_calc*pct_mine + retention_calc*pct_mfg + logpop + metro), -->
<!--                   lw, zero.policy = TRUE) -->

<!-- summary(ols2a) -->
<!-- ``` -->

<!-- #### 3.) full -->
<!-- ```{r} -->

<!-- nb <- poly2nb(mi1, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->

<!-- sr_data = mi1 %>% mutate(sr = metro_nonmetro) -->

<!-- ols3a = errorsarlm(data = sr_data, paam ~ 0 + sr/(retention_calc + pct_ag + pct_mine + pct_mfg + retention_calc*pct_ag + retention_calc*pct_mine + retention_calc*pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + metro + uninsured), -->
<!--                   lw, zero.policy = TRUE) -->

<!-- summary(ols3a) -->

<!-- # global and local autocorrelation -->
<!-- Q2ar = mi1 -->
<!-- Q2ar$r = ols3a$resid -->
<!-- nb <- poly2nb(Q2ar, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->
<!-- lw$weights[5] -->
<!-- moran.test(Q2ar$r,lw, zero.policy=TRUE) -->
<!-- w <- queen_weights(Q2ar) -->
<!-- lisa <- local_moran(w, Q2ar['r']) -->
<!-- lisa_colors <- lisa_colors(lisa) -->
<!-- lisa_labels <- lisa_labels(lisa) -->
<!-- lisa_clusters <- lisa_clusters(lisa) -->
<!-- plot(st_geometry(Q2ar),  -->
<!--      col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}),  -->
<!--      border = "#333333", lwd=0.2) -->
<!--  -->
<!--  -->
<!-- ``` -->



<!-- ### autonomy only -->
<!-- #### 1.) industry > trade -->
<!-- ```{r} -->
<!-- nb <- poly2nb(mi1, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->

<!-- sr_data = mi1 %>% mutate(sr = metro_nonmetro) -->

<!-- ols1a2 = errorsarlm(data = sr_data, autonomy_calc ~ 0 + sr/(pct_ag + pct_mine + pct_mfg + logpop + metro), -->
<!--                   lw, zero.policy = TRUE) -->

<!-- summary(ols1a2) -->
<!-- ``` -->

<!-- #### 2.) industry + trade > prosperity -->
<!-- ```{r} -->

<!-- m1a  <- ' prosperity  =~ laborforce_part_rate + bach + poverty_rate + income_rate' -->

<!-- factor1 <- cfa(m1a, data=mi1,std.lv=TRUE) -->
<!-- summary(factor1) -->

<!-- PE <- parameterEstimates(factor1) %>% -->
<!--   filter(lhs == "prosperity") -->

<!-- loading.laborforce_part_rate = PE %>% -->
<!--   filter(rhs == "laborforce_part_rate") %>% -->
<!--   select(est) -->
<!-- loading.laborforce_part_rate = loading.laborforce_part_rate$est -->

<!-- loading.bach = PE %>% -->
<!--   filter(rhs == "bach") %>% -->
<!--   select(est) -->
<!-- loading.bach = loading.bach$est -->

<!-- loading.poverty_rate = PE %>% -->
<!--   filter(rhs == "poverty_rate") %>% -->
<!--   select(est) -->
<!-- loading.poverty_rate = loading.poverty_rate$est -->

<!-- loading.income_rate = PE %>% -->
<!--   filter(rhs == "income_rate") %>% -->
<!--   select(est) -->
<!-- loading.income_rate = loading.income_rate$est -->

<!-- mi2 = mi1 %>% -->
<!--   mutate(prosperity = ((laborforce_part_rate*loading.laborforce_part_rate)+(income_rate*loading.income_rate)+(poverty_rate*loading.poverty_rate)+(bach*loading.bach))/4, prosperity = (prosperity-mean(prosperity, na.rm=TRUE))/sd(prosperity, na.rm=TRUE)) -->

<!-- nb <- poly2nb(mi2, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->

<!-- sr_data = mi2 %>% mutate(sr = metro_nonmetro) -->

<!-- ols2a = errorsarlm(data = sr_data, prosperity ~ 0 + sr/(autonomy_calc + pct_ag + pct_mine + pct_mfg + autonomy_calc*pct_ag + autonomy_calc*pct_mine + autonomy_calc*pct_mfg + logpop + metro), -->
<!--                   lw, zero.policy = TRUE) -->

<!-- summary(ols2a) -->
<!-- ``` -->

<!-- #### 3.) full -->
<!-- ```{r} -->
<!-- nb <- poly2nb(mi1, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->

<!-- sr_data = mi1 %>% mutate(sr = metro_nonmetro) -->

<!-- ols3a = errorsarlm(data = sr_data, paam ~ 0 + sr/(autonomy_calc + pct_ag + pct_mine + pct_mfg + autonomy_calc*pct_ag + autonomy_calc*pct_mine + autonomy_calc*pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + metro + uninsured), -->
<!--                   lw, zero.policy = TRUE) -->

<!-- summary(ols3a) -->

<!-- # global and local autocorrelation -->
<!-- Q2ar = mi1 -->
<!-- Q2ar$r = ols3a$resid -->
<!-- nb <- poly2nb(Q2ar, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->
<!-- lw$weights[5] -->
<!-- moran.test(Q2ar$r,lw, zero.policy=TRUE) -->
<!-- w <- queen_weights(Q2ar) -->
<!-- lisa <- local_moran(w, Q2ar['r']) -->
<!-- lisa_colors <- lisa_colors(lisa) -->
<!-- lisa_labels <- lisa_labels(lisa) -->
<!-- lisa_clusters <- lisa_clusters(lisa) -->
<!-- plot(st_geometry(Q2ar),  -->
<!--      col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}),  -->
<!--      border = "#333333", lwd=0.2) -->
<!--  -->
<!--  -->
<!-- ``` -->


<!-- ## Structural equation (interact) -->
<!-- ### retention & autonomy -->
<!-- #### 1.) aspatial, no residual covariances -->
<!-- ```{r} -->

<!-- model5 <- ' -->
<!--   prosperity2 =~ laborforce_part_rate + poverty_rate + bach + income_rate -->

<!--   retention_calc ~ pct_mfg + pct_ag + pct_mine -->
<!--   autonomy_calc ~ pct_mfg + pct_ag + pct_mine -->
<!--   prosperity2 ~ pct_mfg + pct_ag + pct_mine + a*retention_calc + autonomy_calc + logpop -->
<!--   paam ~ logpop + b*prosperity2 + pct_mfg + pct_ag + pct_mine + c*retention_calc + autonomy_calc + retention_calc:pct_mfg + retention_calc:pct_ag + retention_calc:pct_mine + autonomy_calc:pct_mfg + autonomy_calc:pct_ag + autonomy_calc:pct_mine  + age + metro + uninsured -->

<!--   # indirect (a*b) -->
<!--   ab := a*b -->

<!--   # total -->
<!--   total := c + (a*b) -->
<!-- ' -->

<!-- model5.fit <- sem(model5, data = mi1)  -->
<!-- summary(model5.fit, rsq = TRUE, fit.measures = TRUE, standardized = TRUE)  -->

<!-- fit <- cfa(model5, data=mi1) -->



<!-- ``` -->


<!-- #### 2.) aspatial, residual covariances -->
<!-- ```{r} -->
<!-- model5 <- ' -->
<!--   prosperity2 =~ laborforce_part_rate + poverty_rate + bach + income_rate -->

<!--   retention_calc ~ pct_mfg + pct_ag + pct_mine -->
<!--   autonomy_calc ~ pct_mfg + pct_ag + pct_mine -->
<!--   prosperity2 ~ pct_mfg + pct_ag + pct_mine + a*retention_calc + autonomy_calc + logpop -->
<!--   paam ~ logpop + b*prosperity2 + pct_mfg + pct_ag + pct_mine + c*retention_calc + autonomy_calc + retention_calc:pct_mfg + retention_calc:pct_ag + retention_calc:pct_mine + autonomy_calc:pct_mfg + autonomy_calc:pct_ag + autonomy_calc:pct_mine + age + metro + uninsured -->

<!--   # indirect (a*b) -->
<!--   ab := a*b -->

<!--   # total -->
<!--   total := c + (a*b) -->

<!--   metro ~~ poverty_rate -->
<!--   metro ~~ bach -->
<!--   metro ~~ income_rate -->
<!--   metro ~~ pct_mfg -->
<!--   metro ~~ pct_ag -->
<!--   metro ~~ pct_mine -->
<!--   metro ~~ retention_calc -->
<!--   metro ~~ autonomy_calc -->
<!--   metro ~~ logpop -->
<!--   metro ~~ age -->
<!--   metro ~~ uninsured -->
<!--   logpop ~~ poverty_rate -->
<!--   logpop ~~ bach -->
<!--   logpop ~~ income_rate -->
<!--   logpop ~~ pct_mfg -->
<!--   logpop ~~ pct_ag -->
<!--   logpop ~~ pct_mine -->
<!--   logpop ~~ retention_calc -->
<!--   logpop ~~ autonomy_calc -->
<!--   logpop ~~ age -->
<!--   logpop ~~ uninsured -->
<!--   retention_calc ~~ autonomy_calc -->


<!-- ' -->

<!-- model5.fit <- sem(model5, data = mi1)  -->
<!-- summary(model5.fit, rsq = TRUE, fit.measures = TRUE, standardized = TRUE)  -->

<!-- fit <- cfa(model5, data=mi2) -->
<!-- ``` -->


<!-- #### 3.) SLX, no residual covariances -->

<!-- ```{r} -->
<!-- nb <- poly2nb(mi1, queen=TRUE) -->
<!-- lw <- nb2listw(nb, style="W", zero.policy=TRUE) -->


<!-- slx_import = lmSLX(data = mi1, paam ~ retention_calc + autonomy_calc + pct_ag + pct_mine + pct_mfg + laborforce_part_rate + age + bach + poverty_rate + income_rate + logpop + metro + uninsured, lw, zero.policy=TRUE) -->

<!-- mi3 = mi1 %>% -->
<!--   mutate(lag.retention_calc = slx_import$model$lag.retention_calc, lag.autonomy_calc = slx_import$model$lag.autonomy_calc,  -->
<!--          lag.pct_ag = slx_import$model$lag.pct_ag, lag.pct_mine = slx_import$model$lag.pct_mine,  -->
<!--          lag.pct_mfg = slx_import$model$lag.pct_mfg, lag.laborforce_part_rate = slx_import$model$lag.laborforce_part_rate,  -->
<!--          lag.age = slx_import$model$lag.age, lag.bach = slx_import$model$lag.bach,  -->
<!--          lag.poverty_rate = slx_import$model$lag.poverty_rate, lag.income_rate = slx_import$model$lag.income_rate,  -->
<!--          lag.logpop = slx_import$model$lag.logpop,  -->
<!--          lag.uninsured = slx_import$model$lag.uninsured -->
<!--          ) -->

<!-- model6 <- ' -->
<!--   prosperity2 =~ laborforce_part_rate + poverty_rate + bach + income_rate -->

<!--   retention_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine -->
<!--   autonomy_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine -->
<!--   prosperity2 ~ pct_mfg + pct_ag + pct_mine + a*retention_calc + autonomy_calc + logpop + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop -->
<!--   paam ~ logpop + b*prosperity2 + pct_mfg + pct_ag + pct_mine + c*retention_calc + autonomy_calc + retention_calc:pct_mfg + retention_calc:pct_ag + retention_calc:pct_mine + autonomy_calc:pct_mfg + autonomy_calc:pct_ag + autonomy_calc:pct_mine  + age + metro + uninsured + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop + lag.laborforce_part_rate + lag.poverty_rate + lag.bach + lag.income_rate + lag.age  + lag.uninsured -->

<!--   # indirect (a*b) -->
<!--   ab := a*b -->

<!--   # total -->
<!--   total := c + (a*b) -->
<!-- ' -->

<!-- model6.fit <- sem(model6, data = mi3)  -->
<!-- summary(model6.fit, rsq = TRUE, fit.measures = TRUE, standardized = TRUE)  -->

<!-- fit <- cfa(model6, data=mi3) -->





<!-- ``` -->




<!-- #### 4.) SLX, residual covariances -->
<!-- ```{r} -->
<!-- model6 <- ' -->
<!--   prosperity2 =~ laborforce_part_rate + poverty_rate + bach + income_rate -->

<!--   retention_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine -->
<!--   autonomy_calc ~ pct_mfg + pct_ag + pct_mine + lag.pct_mfg + lag.pct_ag + lag.pct_mine -->
<!--   prosperity2 ~ pct_mfg + pct_ag + pct_mine + a*retention_calc + autonomy_calc + logpop + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop -->
<!--   paam ~ logpop + b*prosperity2 + pct_mfg + pct_ag + pct_mine + c*retention_calc + autonomy_calc + retention_calc:pct_mfg + retention_calc:pct_ag + retention_calc:pct_mine + autonomy_calc:pct_mfg + autonomy_calc:pct_ag + autonomy_calc:pct_mine  + age + metro + uninsured + lag.pct_mfg + lag.pct_ag + lag.pct_mine + lag.retention_calc + lag.autonomy_calc + lag.logpop + lag.laborforce_part_rate + lag.poverty_rate + lag.bach + lag.income_rate + lag.age  + lag.uninsured -->

<!--   # indirect (a*b) -->
<!--   ab := a*b -->

<!--   # total -->
<!--   total := c + (a*b) -->


<!--   metro ~~ poverty_rate -->
<!--   metro ~~ bach -->
<!--   metro ~~ income_rate -->
<!--   metro ~~ pct_mfg -->
<!--   metro ~~ pct_ag -->
<!--   metro ~~ pct_mine -->
<!--   metro ~~ retention_calc -->
<!--   metro ~~ autonomy_calc -->
<!--   metro ~~ logpop -->
<!--   metro ~~ age -->
<!--   metro ~~ uninsured -->
<!--   logpop ~~ poverty_rate -->
<!--   logpop ~~ bach -->
<!--   logpop ~~ income_rate -->
<!--   logpop ~~ pct_mfg -->
<!--   logpop ~~ pct_ag -->
<!--   logpop ~~ pct_mine -->
<!--   logpop ~~ retention_calc -->
<!--   logpop ~~ autonomy_calc -->
<!--   logpop ~~ age -->
<!--   logpop ~~ uninsured -->
<!--   retention_calc ~~ autonomy_calc -->

<!-- ' -->

<!-- model6.fit <- sem(model6, data = mi3)  -->
<!-- summary(model6.fit, rsq = TRUE, fit.measures = TRUE, standardized = TRUE)  -->

<!-- fit <- cfa(model6, data=mi3) -->


<!-- ``` -->




<!-- #### print results  -->
<!-- Write regime retention & autonomy results to excel file  -->

<!-- ```{r} -->

<!-- # install.packages("broom") -->
<!-- # install.packages("writexl") -->
<!-- library(broom) -->
<!-- library(writexl) -->

<!-- # Tidy the results of each model -->
<!-- tidy_ols1 <- tidy(ols1a1) -->
<!-- tidy_ols2 <- tidy(ols1a2) -->
<!-- tidy_ols3 <- tidy(ols1a3) -->
<!-- tidy_ols4 <- tidy(ols2a) -->
<!-- tidy_ols5 <- tidy(ols2a1) -->
<!-- tidy_ols6 <- tidy(ols3a) -->


<!-- # Add a column to identify the model -->

<!-- tidy_ols1$model <- "Retention-Industry" -->
<!-- tidy_ols2$model <- "Autonomy-Industry" -->
<!-- tidy_ols3$model <- "PAAM-Industry" -->
<!-- tidy_ols4$model <- "Prosp-Trade-Industry" -->
<!-- tidy_ols5$model <- "PAAM-Trade-Industry" -->
<!-- tidy_ols6$model <- "FULL" -->

<!-- # Combine the tidy results into a single data frame -->
<!-- tidy_results <- bind_rows(tidy_ols1, tidy_ols2, tidy_ols3, tidy_ols4, tidy_ols5, tidy_ols6) -->


<!-- # Create a list of data frames to be written to different sheets -->
<!-- results_list <- list( -->
<!-- "Retention-Industry" = tidy_ols1, -->
<!-- "Autonomy-Industry" = tidy_ols2, -->
<!-- "PAAM-Industry" = tidy_ols3, -->
<!-- "Prosp-Trade-Industry" = tidy_ols4, -->
<!-- "PAAM-Trade-Industry" = tidy_ols5,  -->
<!-- "FULL" = tidy_ols6 -->
<!-- ) -->

<!-- # Write the list of data frames to an Excel file -->
<!-- write_xlsx(results_list, path = "SR_regression_results.xlsx") -->


<!-- ``` -->

<!-- #### print results  -->
<!-- Write SE retention & autonomy results to excel file  -->

<!-- ```{r} -->

<!-- # install.packages("broom") -->
<!-- # install.packages("writexl") -->
<!-- library(broom) -->
<!-- library(writexl) -->

<!-- # Tidy the results of each model -->
<!-- tidy_ols1 <- tidy(ols1a1) -->
<!-- tidy_ols2 <- tidy(ols1a2) -->
<!-- tidy_ols3 <- tidy(ols1a3) -->
<!-- tidy_ols4 <- tidy(ols2a) -->
<!-- tidy_ols5 <- tidy(ols2a1) -->
<!-- tidy_ols6 <- tidy(ols3a) -->


<!-- # Add a column to identify the model -->

<!-- tidy_ols1$model <- "Retention-Industry" -->
<!-- tidy_ols2$model <- "Autonomy-Industry" -->
<!-- tidy_ols3$model <- "PAAM-Industry" -->
<!-- tidy_ols4$model <- "Prosp-Trade-Industry" -->
<!-- tidy_ols5$model <- "PAAM-Trade-Industry" -->
<!-- tidy_ols6$model <- "FULL" -->

<!-- # Combine the tidy results into a single data frame -->
<!-- tidy_results <- bind_rows(tidy_ols1, tidy_ols2, tidy_ols3, tidy_ols4, tidy_ols5, tidy_ols6) -->


<!-- # Create a list of data frames to be written to different sheets -->
<!-- results_list <- list( -->
<!-- "Retention-Industry" = tidy_ols1, -->
<!-- "Autonomy-Industry" = tidy_ols2, -->
<!-- "PAAM-Industry" = tidy_ols3, -->
<!-- "Prosp-Trade-Industry" = tidy_ols4, -->
<!-- "PAAM-Trade-Industry" = tidy_ols5,  -->
<!-- "FULL" = tidy_ols6 -->
<!-- ) -->

<!-- # Write the list of data frames to an Excel file -->
<!-- write_xlsx(results_list, path = "SE_regression_results.xlsx") -->


<!-- ``` -->

<!-- #### print results  -->
<!-- Write OLS retention & autonomy results to excel file  -->

<!-- ```{r} -->

<!-- # install.packages("broom") -->
<!-- # install.packages("writexl") -->
<!-- library(broom) -->
<!-- library(writexl) -->

<!-- # Tidy the results of each model -->
<!-- tidy_ols1 <- tidy(ols1a1) -->
<!-- tidy_ols2 <- tidy(ols1a2) -->
<!-- tidy_ols3 <- tidy(ols1a3) -->
<!-- tidy_ols4 <- tidy(ols2a) -->
<!-- tidy_ols5 <- tidy(ols2a1) -->
<!-- tidy_ols6 <- tidy(ols3a) -->


<!-- # Add a column to identify the model -->

<!-- tidy_ols1$model <- "Retention-Industry" -->
<!-- tidy_ols2$model <- "Autonomy-Industry" -->
<!-- tidy_ols3$model <- "PAAM-Industry" -->
<!-- tidy_ols4$model <- "Prosp-Trade-Industry" -->
<!-- tidy_ols5$model <- "PAAM-Trade-Industry" -->
<!-- tidy_ols6$model <- "FULL" -->

<!-- # Combine the tidy results into a single data frame -->
<!-- tidy_results <- bind_rows(tidy_ols1, tidy_ols2, tidy_ols3, tidy_ols4, tidy_ols5, tidy_ols6) -->


<!-- # Create a list of data frames to be written to different sheets -->
<!-- results_list <- list( -->
<!-- "Retention-Industry" = tidy_ols1, -->
<!-- "Autonomy-Industry" = tidy_ols2, -->
<!-- "PAAM-Industry" = tidy_ols3, -->
<!-- "Prosp-Trade-Industry" = tidy_ols4, -->
<!-- "PAAM-Trade-Industry" = tidy_ols5,  -->
<!-- "FULL" = tidy_ols6 -->
<!-- ) -->

<!-- # Write the list of data frames to an Excel file -->
<!-- write_xlsx(results_list, path = "OLS_regression_results.xlsx") -->


<!-- ``` -->


```{r}

truelove#Truelove lowland datafile
plantcomp #plant competition datafile
alexfiord #alexandra fiord datafile

# Note that if you are using the script files provided in the appendices to Lamb et al 2014
# you will need to copy the data and script files to files to your working directory, and use the following scripts to load them:
	truelove <- read.csv("data/rawdata_truelove.csv") # read Truelove lowland datafile
 	alexfiord <- read.csv("data/rawdata_Alexfiord.csv")# read Alexandra Fiord datafile
	plantcomp <- read.csv("data/rawdata_plantcomp.csv")# read Plant Competition datafile

#Step 2 calculate distance matrix and specify lag distance bin sizes

	# function calc.dist(datafile) calculates and stores the distance matrix for all X-Y pairs
	#	requires a dataset where the first two columns are x and y coordinates

truelovedist<-calc.dist(truelove)
alexfiorddist<-calc.dist(alexfiord)
plantcompdist<-calc.dist(plantcomp)

	# Need to specify 2 vectors for bin sizes:
	#	binsize is a vector of lag distances starting at 0. The following values are the upper limits of each distance bin
	#		binsize should have n+1 elements where n is the number of lag distance bins desired
	#	bin.name is a vector of unique names for each lag distance bin. there should be n elements, one for each bin

	# Bin sizes and names can be specified manually or using function make.bin

#make.bin(dist.mat,type="ALL",p.dist=50,n.bins=10,s.size=100)

	# generates cut off values for lag distance bins and corresponding bin names
	# The function has three default parameter values available, if user does not want to specify:
		#Inference distance as a percentage(p.dist) = 50%
		#Number of bins (n.bins) = 10
		#Sample size (s.size) = 100
	#dist.mat is a distance matrix produced by calc.dist
	#Can use type="ALL","n.bins" OR "s.size" to control parameter values.
	#The function produces a list object containing (1.)binsize and (2.)binname
	#These two vectors (binsize and binname) will be used by make.covar to calculate variance covariance matrices for each lag distance bin
	
	#Special note:
	#User specified number of lag distance bins OR sample size 
	#will be used to calculate initial cutoff value of each lag distance bin.
	#However, if the cutoff point is in between a lag distance bin, 
	#real cutoff will apply at the upper margin of the particular bin. 
	#Therefore, resulting number of bins are less than or equal AND 
	#resulting sample sizes are greater than or equal to the value specified by the user.
	
# function make.bin to generate all possible bins the Truelove lowland dataset to a maximum inference distance of 50%

#	note the need to extract sizes and names from the bin size object as shown below

Truelove_bins<-make.bin(truelovedist,type="ALL") #inference distance=50% AND number of bins=ALL
truebinsize<-Truelove_bins[1][[1]] #truelove lowland bin sizes
truebinname<-Truelove_bins[2][[1]] #truelove lowland bin names

# plotbin(distancematrix,binsize) provides a histogram of all pairs in the distance matrix and a plot of sample 
# 	size for the selected bin size.
	
plotbin(truelovedist,truebinsize)

	
# manual bin sizes for the Alexandra Fiord dataset
#	note that the bin name vector must have one less element than bin size
	
alexbinsize = c(0,1,2,2.2,4,5,8,16,32,64,96,128,160) #alex fiord bin sizes
alexbinname=c("Bin1","Bin2","Bin3","Bin4","Bin5","Bin6","Bin7","Bin8","Bin9","Bin10","Bin11","Bin12")#alex fiord Bin names

plotbin(alexfiorddist,alexbinsize)

# function make.bin to generate bins with 200 samples each to a maximum inference distance of 50% 
#	for the Plant Competition dataset

#	note the need to extract sizes and names from the bin size object as shown below

Plant_bins<-make.bin(plantcompdist,type="s.size",s.size=200) #inference distance=50% AND sample size=200
plantbinsize<-Plant_bins[1][[1]] #plant competition bin sizes
plantbinname<-Plant_bins[2][[1]] #plant competition bin names

plotbin(plantcompdist,plantbinsize)

	#User can use type="ALL","n.bins" OR "s.size"
	#make.covar uses binsize and binname, only if attibutes=NULL and is.vector=TRUE.


#Step 3 Calculate covariance matrices
	
	# function make.covar(datafile,distancematrix,binsize,binname) calculates variance covariance matrices
	#	for each lag distance bin and for a flat (non-spatial) bin
	#	Values in the bin summary include the low and high cut points for each bin and the count "aa.lagcnt" of 
	#	samples in each bin
	
	# this step can be computationally time consuming; the resulting object can be saved for later sesem analysis
	
truelove_covar<-make.covar(truelove,truelovedist,truebinsize,truebinname)
alex_covar<-make.covar(alexfiord,alexfiorddist,alexbinsize,alexbinname)
plant_covar<-make.covar(plantcomp,plantcompdist,plantbinsize,plantbinname)


# Step 4 Run Models

# function runModels()  
# 	lavaan library must be installed. 
#   need to specifify path model using lavaan syntax. 
#	See http://cran.r-project.org/web/packages/lavaan/lavaan.pdf for details
#	list object created by runModels() used in subsequent steps

#Truelove  and Alexandra Fiord Path Models
spatial_model<-'
	Gram ~ Moisture
	N_Fix ~ Bryoph + Lich + SoilCrust
	SoilCrust ~ Bryoph + Lich + Gram + Shrubs + Forbs	
	Bryoph ~ Gram + Shrubs + Forbs + Moisture
	Lich ~ Moisture + Forbs + Gram + Shrubs + Bryoph
	Forbs ~ Moisture
	Gram ~~ Forbs
	Shrubs ~ Moisture	
	Gram ~~ Shrubs
	Shrubs ~~ Forbs
	'

#Plant Competition Path Model
spatial_model_plant<-'
	SoilMoist ~ Topog.Pos
	ShootBio ~ TotalN + Topog.Pos + SoilMoist
	RootBio ~ TotalN + Topog.Pos + SoilMoist
	ShootBio ~~ RootBio
	LightInt ~ ShootBio + Topog.Pos
	Comp.Intensity ~ LightInt + RootBio + TotalN + SoilMoist
	SpRich ~ Comp.Intensity + SoilMoist + RootBio + ShootBio + Topog.Pos
	'

library(lavaan)

spatial_model_results_true<-runModels(spatial_model,truelove_covar)
spatial_model_results_alex<-runModels(spatial_model,alex_covar)
spatial_model_results_plant<-runModels(spatial_model_plant,plant_covar)

# Step 5 Extract analysis results

	# modelsummary() extracts basic model summary information from the object
	# created by runModels in a readable format
	
modelsummary(spatial_model_results_true)
modelsummary(spatial_model_results_alex)
modelsummary(spatial_model_results_plant)

# bin.results(spatial_model_results,bin="binflat") 
#	extracts path coefficients, standard errors, and standardized coefficients for a particular bin in a readable format

bin.results(spatial_model_results_true,bin="Bin2")# prints results for bin2 
bin.results(spatial_model_results_alex,bin="binflat") # prints results for flat (nonspatial) bin


# bin.rsquare(spatial_model_results,bin="binflat") 
#	extracts r-square values for each dependent variable for a particular bin

bin.rsquare(spatial_model_results_plant,bin="binflat")

# Step 6a plot model fit results

#	plotmodelfit(spatial_model_results,plots="all",add.line="none",rmsea_err=T,pch=16,lwd=2,lty=1)
#	model fit plotting with optional lines, and formatting

#	spatial_model_results = object output by runModels
#	plots = options for selecting fit indices to plot
#		"all" indicats all of chi square, cfi, rmsea, and srmr to be plotted 
#		"chi", "cfi", "rmsea", "srmr" select individual metrics for plotting
#	add.lines. options for plotting a fit line 
#		"none" indicates no line
#		"step" plots straight line segments between points
#		"smooth" plots a smoothed curve fit using function lowess. Smoothed lines do not include the flat model (lag distance zero)
#	rmsea_err should confidence limits for rmsea be plotted?
#	pch, lwd, lty options for formatting points and fit lines.
library(gplots)
plotmodelfit(spatial_model_results_true) # plots all metrics without lines and with rmsea errors
											# note that warnings will arise from the plotting of rmsea errors with zero length
											#these can be ignored
plotmodelfit(spatial_model_results_alex,add.line="step",rmsea_err=F,lwd=2) # plots stepped fit line
plotmodelfit(spatial_model_results_plant,add.line="smooth",rmsea_err=F,pch=16,lty=1) # plots smoothed fit line

plotmodelfit(spatial_model_results_true,plot="cfi",add.line="smooth",pch=16,lty=1,lwd=4,cex.lab=1.5,cex=2,cex.axis=1.5) #plots only cfi

# Step 6b plot path coefficent changes with lag distances

#	plotpath(spatial_model_results,path.type="directed",add.line="none",rmsea_err=T,pch=16,lwd=2,lty=1)
#   
#	spatial_model_results = object output by runModels
#	path.type= options for selecting which paths to plot
#		"directed" = only directed paths plotted
#		"undirected" = only undirected correlations plotted
#		"both" = all paths plotted
#		"user" = allows user to specify particular paths and a particular order for plotting
#			argument selectpath must also be provided with path.type="user"
#	selectpath = required when path.type="user"
#		usage is selectpath==c(5,18,16,23,29) where values refer to path numbers
#		path numbers can be obtained using spatial_model_results[2]
#	add.lines = options for plotting a fit line 
#		"none" indicates no line
#		"step" plots straight line segments between points
#		"smooth" plots a smoothed curve fit using function lowess
#	add.error = should standard error bars be added for each path coefficient
#	pcut = p-value cutoff above which points with non significant p-values are shaded grey
#		set pcut=1 to have all points black
#	pch, lwd, lty cex, cex.lab, cex.axis, cex.main options for formatting points and fit lines.

library(gplots)
plotpath(spatial_model_results_true,pch=11) # plots 
plotpath(spatial_model_results_plant,pch=16,path.type="directed",add.line="smooth")
plotpath(spatial_model_results_alex,path.type="both",add.error=F,add.line="step",pcut=0.01,lwd=1)
plotpath(spatial_model_results_true,path.type="user",selectpath=c(5,18,16,23,29),add.error=F,add.line="smooth",pcut=0.01,lwd=1)

#
#Step 6c plot changes in path coefficents using generalized additive models

#	gam.path(spatial_model_results,path.type="directed",selectpath="none selected",
#		plot.points=T,se.plot=T,lwd.pred=2,lty.pred=1,lwd.se=2,lty.se=3,cex=1,cex.axis=1,cex.lab=1
#		,xlab="Lag Distance",ylab="Unst. Path Coeff.",yaxt="s",xaxt="s")
#
#	library "mgcv" is required
   
#	This function prints some of the gam results for each path in the model as well as producing figures
   
#	spatial_model_results = object output by runModels
#	path.type= options for selecting which paths to plot
#		"directed" = only directed paths plotted
#		"undirected" = only undirected correlations plotted
#		"both" = all paths plotted
#		"user" = allows user to specify particular paths and a particular order for plotting
#			argument selectpath must also be provided with path.type="user"
#	selectpath = required when path.type="user"
#		usage is selectpath==c(5,18,16,23,29) where values refer to path numbers
#		path numbers can be obtained using spatial_model_results[2]
#	plot.points = should points be plotted on figure
#	se.plot = should standard errors for the prediction lines be printed
#	additional arguments formatting figure

#displays gam relationships for all directed paths in model

library(mgcv)

par(mar=c(2.5,2.5,1.5,1))
gam.path(spatial_model_results_true,plot.points=F,se.plot=T)

#displays gam relationships for a selection of paths in model
gam.path(spatial_model_results_plant,path.type="user",selectpath=c(5,18,16,14,7),plot.points=T,se.plot=T)

gam.path(spatial_model_results_alex,path.type="user",selectpath=c(5,18,16,14,7),plot.points=F,se.plot=F,lwd.pred=2,ylab="",xlab="",yaxt="n",xaxt="n")


#Step 7. Optimize model

# avg.modindices() extracts modification indices for all models in the object produced by runModels() 
# 		and summarizes the mod indices by taking the mean for each possible additional path
#		across all lag distance bins. The flat model is not included in these calculations
#	 modcut eliminates printing of average MI values below the cutoff. The default is 4
# 
# Based on the modification indices create a new lavaan path model description and return to step 4.


avg.modindices(spatial_model_results_true,modcut=3)# display modindices
avg.modindices(spatial_model_results_alex)# display modindices
avg.modindices(spatial_model_results_plant,modcut=1)# display modindices

```


