---
title: "Circularity paper results"
format:
  html:
    toc: true
    toc-depth: 3
    embed-resources: true
    code-fold: true
---


# Libraries and sourced files

```{r, message=FALSE}
# estimation
library(estimatr)
# library(multcomp) # referenced explicitly in code
library(spdep)
library(spatialreg)

# Formatting output
library(skimr)
library(RColorBrewer)
library(ggthemes)
library(huxtable)
library(gtsummary)
library(modelsummary)
library(cardx)

# Mapping libraries
library(sf)
library(tmap)
library(tigris)

# attach last to mask functions from other libraries
library(tidyverse)
library(broom)


# scripts
source("R/geography.R", local = (geography <- new.env()))
source("R/place_io.R", local = (place_io <- new.env()))
source("R/circularity.R", local = (circularity <- new.env()))
source("R/dataprep_cbp.R", local = (cbp <- new.env()))
source("R/pubdatapy.R", local = (pubdatapy <- new.env()))

source("projects/circ_paper/dataprep.R", local = (dataprep = new.env()))
```


```{r}

#' Arrange data frame treating selected variables as ordered
#' Pass "..." arguments as "var_name = order_values" pairs.
#' Use "asis" to maintain order as values appear in rows.
#' Examples:
#' arrange in non-alphabetical order
#' df %>% arrange_ord(outcome = c("est", "emp", "pay"))
#' arrange by outcome, then by rurality, in default order
#' df %>% arrange_ord(outcome = "asis", rurality = "asis")
arrange_ord = function(df, ...) {
  vars = list(...)
  for (var in names(vars)) {
    lvls = vars[[var]]
    if (length(lvls) == 1 && lvls == "asis") {
      lvls = unique(df[[var]])
    }
    df[[paste0(var, "_ordered")]] = ordered(df[[var]], levels = lvls)
  }
  vars_ord = paste0(names(vars), "_ordered")
  df %>%
    arrange(pick(all_of(vars_ord))) %>%
    select(!all_of(vars_ord))
}
```


# Analysis parameters

```{r}
# data parameters and other global variables
params = list(
  shapefile_year = 2013,
  cbsa_year = 2013, # (Delineations available for years 2003:2009, 2013, 2015, 2017, 2018, 2020),
  
  circularity_data = "cbp_imp",
  circularity_year = 2012,
  circ_indicators = c("production_capacity", "trade_capacity", "retention", 
                      "production_dependency", "trade_dependency", "autonomy", 
                      "trade_balance", "trade_openness"),
  base_year = 2010,
  end_year = 2019,
  outcome_vars = c("establishment_gr", "employment_gr", "payroll_gr", "wage_gr"),
  control_vars = c("log_pop", "sh_ag", "sh_mine", "sh_mfg", "sh_fire", "sh_prof"),
  control_sup_vars = c("sup_ag", "sup_mine", "sup_mfg", "sup_fire", "sup_prof"),
  rural = "m",
  spreg = TRUE # estimate spatial regression models (slow)
)

# Rural Definitions
#  mmn: Metro/Micro/Non-core
#    m: Metro/Non-metro
#    c: Core/Non-core

```

# Data cache

```{r}
# uncomment and run manually as needed
if (FALSE) {

  source("R/basic_utilities.R", local = (util <- new.env()))
  
  # list of all specific data files used in the code
  ipath = c(
    pubdatapy$opath$price_index,
    pubdatapy$opath$population,
    glue(geography$opath$county_, year = params$shapefile_year, scale = "20m", geometry = TRUE),
    glue(geography$opath$state_, scale = "20m", geometry = FALSE),
    glue(geography$opath$cbsa_delin_, year = params$cbsa_year),
    glue(place_io$opath$outsupdem_, year = params$circularity_year, ilevel = "det", bus_data = params$circularity_data),
    glue(cbp$opath$cbp_, geo = "county", year = params$base_year:params$end_year, imputed = FALSE)
  )
  
  # create zip file with cache
  # util$zip_pack("tmp/cache_circ_paper_results_v250123.zip", ipath)
  # unpack cache from zip file
  # util$zip_unpack("tmp/cache_circ_paper_results_v250123.zip", overwrite = TRUE)
}
```


# Analytical datasets

```{r}

df_geo <- geography$call_geog(params$shapefile_year, scale = "20m") %>%
  rename_with(tolower)


# pubdatapy$build_price_index()
df_price_idx = pubdatapy$opath$price_index %>%
  read_parquet() %>%
  arrange(year) %>%
  mutate(price_idx = gdp_price_index / last(gdp_price_index)) %>%
  select(year, price_idx)

deflate_price = function(year, x) {
  data.frame(year, x) %>%
    left_join(df_price_idx, "year") %>%
    mutate(y = x / price_idx) %>%
    pull(y)
}


df_outsupdem <- place_io$outsupdem(params$circularity_year, "det", params$circularity_data) %>%
  mutate(
    across(c(output, supply, demand), \(x) deflate_price(params$circularity_year, x)),
    exsup = pmax(0, supply - demand), exdem = pmax(0, demand - supply))

df_circ <- circularity$circularity_indicators(params$circularity_year, params$circularity_data)

# business activity growth rates
df_busdata <- list()
for (period in c("base", "end")) {
  year <- params[[paste0(period, "_year")]]
  df_busdata[[period]] <- cbp$opath$cbp_ %>%
    glue(geo = "county", year = year, imputed = FALSE) %>%
    open_dataset() %>%
    filter(naics == "") %>%
    select(est, emp, ap, place) %>%
    collect() %>%
    mutate(
      ap = deflate_price(year, ap),
      wage = 1000 * ap / emp) %>%
    rename(
      establishments = est,
      employment = emp,
      payroll = ap)
}

df_busdata <- inner_join(df_busdata$end, df_busdata$base, by = "place", suffix = c(".current", ".base")) %>%
  filter(if_all(c(ends_with("base"), ends_with("current")), ~ . > 0)) |> 
  mutate(
    establishment_gr = (establishments.current - establishments.base) / (.5 * establishments.current + .5 * establishments.base),
    employment_gr = (employment.current - employment.base) / (.5 * employment.current + .5 * employment.base),
    payroll_gr = (payroll.current - payroll.base) / (.5 * payroll.current + .5 * payroll.base),
    wage_gr = (wage.current - wage.base) / (.5 * wage.current + .5 * wage.base)
  )

# CBSA data for metro/non-metro definitions
df_cbsa <- geography$pubdata$get_cbsa_delin_df(params$cbsa_year) %>%
  rename_with(tolower) %>%
  select(state_code, county_code, metro_micro)

# county population
# pubdatapy$build_population()
df_population <- pubdatapy$opath$population %>%
  read_parquet() %>%
  filter(year == 2012, cty != "000") %>%
  mutate(place = paste0(st, cty), log_pop = log10(pop)) %>%
  select(place, pop, log_pop)

# GDP sector shares
df_sector <-
  dataprep$gdp_by_sector() %>%
  filter(sector != "tot") %>%
  {inner_join(
    pivot_wider(., id_cols = place, names_from = sector, names_prefix = "sh_", values_from = share),
    pivot_wider(., id_cols = place, names_from = sector, names_prefix = "sup_", values_from = suppressed),
    by = "place"
  )}
  

# full cross-sectional dataframe 
df_full <- df_geo %>%
  right_join(df_circ, "place") %>%
  left_join(df_busdata, "place") %>% 
  left_join(df_cbsa, join_by(state_code, county_code)) %>%
  left_join(df_population, "place") %>%
  left_join(df_sector, "place")

# rural definitions
df_full <- df_full %>%
  mutate(
    rural_mmn = if_else(is.na(metro_micro), "non-core", metro_micro),
    rural_m = if_else(rural_mmn == "metro", "metro", "non-metro"),
    rural_c = if_else(rural_mmn %in% c("metro", "micro"), "core", "non-core")
  )
df_full[["rural"]] <- df_full[[paste0("rural_", params$rural)]]

# Main analytical dataframe: all variables non-missing
df_main <- df_full %>%
  st_drop_geometry() %>%
  select(place, starts_with("rural"), all_of(c(params$outcome_vars, params$circ_indicators, params$control_vars, params$control_sup_vars))) %>%
  drop_na()

df_full[["smp_main"]] <- (df_full$place %in% df_main$place)

# spatial weights for Moran's I statistic and spatial regressions
sp_lw = df_full %>%
  filter(place %in% df_main$place) %>%
  poly2nb(queen = TRUE) %>%
  nb2listw(style = "W", zero.policy = TRUE)


```


## county-year panel

For time trend plots


```{r}

df_buspanel <- list()
for (year in params$base_year:params$end_year) {
  df_buspanel[[as.character(year)]] <- cbp$opath$cbp_ %>%
    glue(geo = "county", year = year, imputed = FALSE) %>%
    open_dataset() %>%
    filter(naics == "") %>%
    select(place, est, emp, ap) %>%
    collect()
}
df_buspanel <- bind_rows(df_buspanel, .id = "year") %>%
  mutate(year = as.numeric(year)) %>%
  # only keep counties without suppression
  filter(min(emp) > 0, .by = "place") %>%
  mutate(pay = deflate_price(year, ap))


```


# Examples

```{r}
# Dairy and Cheese 
commodities = c("112120", "311513")
counties = c("55117","55081")

# Animal Feed and Dairy
# commodities = c("311119", "112120")
# counties = c("17001", "17027")

# Plastics and Medical Device Manufacturing
# commodities = c("^3261", "339112")
# counties = c("27053","27025")

x <- df_outsupdem %>%
  filter(com_code %in% commodities, place %in% counties) %>%
  left_join(df_geo, "place") %>%
  mutate(
    locally_met = pmin(supply, demand),
    id = paste(name, "county,", state, "(", place, ")"),
    across(where(is.numeric), round)
  ) %>%
  arrange(place, com_code)
  
select(x, id, com_code, output, supply, demand)
select(x, id, com_code, output, supply, demand, locally_met, exsup, exdem)


for (com in commodities) {
  x <- df_outsupdem %>%
    filter(com_code == {{com}}) %>%
    left_join(df_geo, "place") %>%
    mutate(log_supdem = sign(exsup - exdem) * log10(1 + pmax(exsup, exdem))) %>%
    st_as_sf() %>%
    shift_geometry()
  com_name <- x %>% pull(com_name) %>% unique()
  x_st <- x %>%
    group_by(state_code) %>%
    summarise()
  
  p <- tm_shape(x) +
    tm_polygons(
      title = com_name,
      col = "log_supdem",
      border.alpha = 0.0,
      style = "cont",
      midpoint = 0,
      breaks = seq(-10, 10, 2),
      palette = rev(brewer.pal(9, "PRGn"))) +
    tm_shape(x_st) +
    tm_layout(
      legend.title.size = .8,
      legend.text.size = .5,
      legend.position = c("LEFT", "TOP"),
      frame = F,
      fontface = 2 ) +
    tm_borders(lwd = 1.5)
  
  print(p)
} 

    
```

# Nationwide Analysis

## Descriptives table

### full dataset

All counties with some data availability.

```{r, message=FALSE}
#| paged.print: FALSE

df_full %>%
  st_drop_geometry() %>%
  mutate(across(starts_with("rural"), as.factor)) %>%
  select(all_of(colnames(df_main))) %>%
  skim()
```

### complete non-missing observations

Main analysis datasets: excluding counties with missing growth or industry share data.

```{r, message=FALSE}
#| paged.print: FALSE

df_main %>%
  mutate(across(starts_with("rural"), as.factor)) %>%
  skim()
```

### first and last year

Levels of economic outcomes.

```{r, message=FALSE}
#| paged.print: FALSE
# first and last year economic outcome levels
df_full %>%
  st_drop_geometry() %>%
  filter(smp_main) %>%
  select(any_of(c(ends_with("base"), ends_with("current")))) %>%
  skim()
```


## Circularity histograms

```{r}
#| warning: false

# density distributions for all 8 circularity indicators

for (circ_measure in params$circ_indicators) {
  n <- str_replace_all(circ_measure, "_", " ") %>% str_to_title()
  (ggplot(df_main) +
    geom_histogram(aes(x = .data[[circ_measure]]), fill = "#88CCEE", binwidth = 0.01) +
    theme_pander() +
    theme(legend.position = "none") +
    ggtitle(n) +
    xlim(ifelse(circ_measure == "trade_balance", -1, 0), ifelse(circ_measure == "trade_openness", 2, 1)) +
    ylab("Count") +
    xlab(n) ) %>%
    print()
}


```


## Spatial distributions

Maps show spatial clustering.


```{r}
# maps for all 8 circularity indicators

df_full %>% 
  shift_geometry() %>% {(
  for (circ_measure in params$circ_indicators) {(
      tm_shape(.) +
        tm_polygons(
          title = str_replace_all(circ_measure, "_", " ") %>% str_to_title(),
          col = circ_measure,
          border.alpha = 0.0,
          style = "cont",
          midpoint = 0,
          breaks = switch(
            circ_measure,
            "trade_balance" = seq(-.5, .5, .1),
            "trade_openness" = seq(0, 1.25, 0.25),
            seq(0, 1, 0.25)),
          palette = rev(brewer.pal(9, "RdBu"))) +
        group_by(., state_code) %>% summarise() %>% tm_shape() +
        tm_layout(
          legend.title.size = .8,
          legend.text.size = .5,
          legend.position = c("LEFT", "TOP"),
          frame = F,
          fontface = 2 ) +
        tm_borders(lwd = 1.5) ) %>% 
      print()
  })
} 

```


## Spatial autocorrelation

All circularity indicators, outcomes and control variables have strong spatial autocorrelation.


```{r}
#| tbl-cap: "Global Univariate Moran's I of Variables"

c(params$circ_indicators, params$outcome_vars, params$control_vars) %>%
  set_names() %>%
  map(function(var_name) {
    x = df_main[[var_name]]
    x1 = moran.test(x, sp_lw, zero.policy = TRUE)
    x2 = tidy(x1)
    colnames(x2)[1:3] = names(x1$estimate)
    x2 %>% mutate(n = length(x), .before = 1)
  }) %>%
  bind_rows(.id = "variable") %>%
  select(variable, n, morans_i = "Moran I statistic", pval = p.value) %>%
  hux() %>%
  set_background_color(evens, everywhere, "grey95") %>% 
  set_all_padding(4) %>% 
  set_outer_padding(0) %>% 
  set_number_format(col = c("morans_i", "pval"), value = 3) %>%
  set_bold(row = 1, col = everywhere) %>% 
  set_bottom_border(row = 1, col = everywhere) %>%
  set_bottom_border(row = 9, col = everywhere) %>%
  set_bottom_border(row = 13, col = everywhere) %>%
  set_width(0.4)

```



## Correlates of Circularity

- Bigger counties have higher circularity and more imports than exports.
- Industry shares are highly statistically significant predictors of circularity indicators.
- Industry effects are difficult to interpret, because each has both demand and supply effects on circularity calculation.
But this exercise justifies including industry shares as controls in the main analysis.


```{r}
result_regcirc = expand_grid(
  circularity = params$circ_indicators,
  sup = c(FALSE, TRUE)
) %>%
  pmap(function(...) {
    row = list(...)
    f = paste0(
      row$circularity,
      " ~ ",
      paste(params$control_vars, collapse = " + "),
      if (row$sup) paste(c("", params$control_sup_vars), collapse = " + ") else ""
    )
    m = lm_robust(as.formula(f), data = df_main)
    # return single-row table with specs, formula and model object
    tibble(..., formula = f, model = list(m))
  }) %>%
  bind_rows()

result_regcirc %>%
  filter(!sup) %>%
  pull(model, name = circularity) %>%
  huxreg(statistics = c(N = "nobs", R2 = "r.squared"))

```

### suppression controls

- Suppression indicators sometimes have significant effect, in the same direction as the share.
This is expected as suppressed counties have positive shares.
- Share coefficients do not differ significantly with or without suppression controls.


```{r}
result_regcirc %>%
  filter(circularity %in% c("production_capacity", "trade_capacity", "retention")) %>%
  pull(model, name = circularity) %>%
  huxreg(statistics = c(N = "nobs", R2 = "r.squared"))

result_regcirc %>%
  filter(circularity %in% c("production_dependency", "trade_dependency", "autonomy")) %>%
  pull(model, name = circularity) %>%
  huxreg(statistics = c(N = "nobs", R2 = "r.squared"))

result_regcirc %>%
  filter(circularity %in% c("trade_balance", "trade_openness")) %>%
  pull(model, name = circularity) %>%
  huxreg(statistics = c(N = "nobs", R2 = "r.squared"))
  
```


## Correlations

- Share of intermediates is negatively correlated with est, emp and pay growth.
  - As outputs (production capacity) and as inputs (production dependency).
- Circularity is positively correlated with establishment, employment and payroll growth.
  - Negative coefficients on trade capacity, dependency and openness.
  - Positive coefficients on retention and autonomy.
- Interestingly, correlations with wage growth are all opposite from est, emp and pay growth.


```{r}
#| output: false

result_corr_pool =
  expand_grid(
    circularity = params$circ_indicators,
    outcome = params$outcome_vars
  ) %>%
  pmap(function(...) {
    row = list(...)
    df_main %>%
      summarize(
        cor.test(.data[[row$outcome]], .data[[row$circularity]]) %>%
          tidy()
      ) %>%
      bind_cols(row, .)
  }) %>%
  bind_rows() 

result_corr_pool %>% head()
```


```{r}
params$outcome_vars %>%
  set_names() %>%
  map(function(v_out) {
    x = result_corr_pool %>%
      filter(outcome == v_out) %>%
      mutate(term = circularity)
    y = list(tidy = x)
    class(y) = "modelsummary_list"
    y
  }) %>%
  modelsummary(output = "huxtable", stars = TRUE, statistic = NULL)

```

```{r}
result_corr_pool %>%
  mutate(`Economic growth` = str_sub(outcome, 1, -4)) %>%
  mutate(circularity = ordered(
    str_replace(circularity, "_", " "),
    levels = str_replace(params$circ_indicators, "_", " ")
  )) %>%
  ggplot(aes(x = circularity, color = `Economic growth`, group = `Economic growth`)) +
  geom_point(aes(y = estimate, shape = `Economic growth`), size = 2, position = position_dodge(0.5)) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = 0.2, position = position_dodge(0.5)) +
  geom_hline(yintercept = 0, linetype = 2) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), axis.title = element_blank())

```




# Urban-Rural Analysis

## Descriptives table

- Urban counties grow faster in size (establishments, employment, payroll), but slower in wage.
- Share of intermediates is lower and circularity is higher in urban than in rural.
- Rural are net exporters and urban net importers, although difference is small in magnitude.
- No pattern in variance: in some variables rural is bigger, in others urban.


```{r, message=FALSE}
#| paged.print=FALSE

# For review

df_full %>%
  st_drop_geometry() %>%
  filter(smp_main) %>%
  mutate(log_excess_supply = log(exsup), 
         log_excess_demand = log(exdem), 
         log_local_supply = log(supply - exsup), 
         log_local_demand = log(demand - exdem)) %>% 
  select(c("rural", "log_excess_supply", "log_excess_demand", "log_local_supply", "log_local_demand", all_of(params$outcome_vars), params$circ_indicators)) %>%
    tbl_summary(
      by = rural,
      statistic = ~ "{mean} ({sd}) [{min}-{max}]",
      missing = "ifany"
      )|> 
  add_p () |> 
  modify_spanning_header(all_stat_cols() ~ "**Urban-Rural Category**")

# For reporting

df_full %>%
  st_drop_geometry() %>%
  filter(smp_main) %>%
  select(c("rural", all_of(params$outcome_vars), params$circ_indicators)) %>%
    tbl_summary(
      by = rural,
      statistic = ~ "{mean} ({sd})",
      missing = "no"
      )|> 
  add_p () |> 
  modify_spanning_header(all_stat_cols() ~ "**Urban-Rural Category**") |> 
  modify_caption(paste("Comparing attributes by urban-rural category:", params$base_year, "to", params$end_year, sep =" "))

```



## Density distributions

- Same interpretation as descriptive tables.

```{r}
# density distributions controlling for rurality
df_main %>%
  {(
    for (circ_measure in params$circ_indicators) {
      n <- str_replace_all(circ_measure, "_", " ") %>% str_to_title()
      (
        ggplot(.) +
          geom_density(aes(x = .data[[circ_measure]], fill = rural), alpha = 0.4) +
          theme_pander() +
          xlim(ifelse(circ_measure == "trade_balance", -1, 0), ifelse(circ_measure == "trade_openness", 2, 1)) +
          scale_fill_manual(values = c("black","#88CCEE")) +
          theme(legend.position = "top") +
          labs(
            fill = "urban-rural category",
            y = "Density",
            x = n,
            title = n
          )
      ) %>% print()
    }
  )}
```


### Comparing rural definitions

- All circularity indicators and outcomes change monotonically with rurality, values for micro lie between metro and non-core.

```{r}
#| warning: false

result_desc_rurdef = list()
for (definition in c("mmn", "m", "c")) {
  v_rur = paste0("rural_", definition)
  result_desc_rurdef[[definition]] = 
    df_main %>%
    select(all_of(c(v_rur, params$outcome_vars, params$circ_indicators))) %>%
    tbl_summary(
      by = v_rur,
      statistic = ~ "{mean} ({sd})",
      missing = "no"
      ) %>%
    add_p () %>%
    modify_spanning_header(all_stat_cols() ~ "**Urban-Rural Category**") %>%
    modify_caption(paste("Comparing attributes by urban-rural category:", params$base_year, "to", params$end_year, sep =" "))
}

result_desc_rurdef$mmn
result_desc_rurdef$m
result_desc_rurdef$c

```




## Time trends

Visual way to demonstrate the magnitude of the explanatory power that the circularity indicators provide.
Rural counties with high circularity often grow almost as fast urban areas with low circularity, i.e. being circular is as good as being urban for growth.


```{r, fig.height=6, fig.width = 8}

for (v_circ in params$circ_indicators) {
  
  x = df_main %>%
    mutate(
      rank = percent_rank(.data[[v_circ]]),
      circ_bin = case_when(
        rank < 0.25 ~ "low",
        rank > 0.75 ~ "high",
        .default = "med"
      ),
      .by = "rural"
    ) %>%
    select(place, rural, {{v_circ}}, circ_bin)
  
  df <- df_buspanel %>%
    left_join(x, "place") %>%
    summarize(counties = n(), across(c(est, emp, pay), sum), .by = c(year, rural, circ_bin)) %>%
    filter(!is.na(rural)) %>%
    mutate(wage = 1000 * pay / emp) %>%
    pivot_longer(c(est, emp, pay, wage)) %>%
    relocate(rural, circ_bin, name, year, value) %>%
    arrange(rural, circ_bin, name, year) %>%
    mutate(val_y0 = first(if_else(year == params$circularity_year, value, NA), na_rm = TRUE), .by = c("rural", "circ_bin", "name")) %>%
    mutate(val_gr = value / val_y0)
  
  p <- df %>%
    filter(circ_bin != "med") %>%
    mutate(name = ordered(name, c("est", "emp", "pay", "wage"))) %>%
    ggplot() +
    geom_line(aes(year, val_gr, color = circ_bin, linetype = rural)) +
    facet_wrap("name", ncol = 2, scales = "free_y") +
    theme_minimal() +
    theme(legend.position = "bottom") +
    labs(title = paste("Economic growth of counties in the top and bottom quartiles of", v_circ)) +
    scale_x_continuous(breaks = seq(params$base_year, params$end_year, 2)) +
    ylab(NULL)
  
  print(p)
}
```

## Correlations

- Correlations are weaker in rural counties, especially for establishment and employment growth.

```{r}
#| output: false

result_corr_rur =
  expand_grid(
    circularity = params$circ_indicators,
    outcome = params$outcome_vars,
    rural = unique(df_main$rural)
  ) %>%
  pmap(function(...) {
    row = list(...)
    df = df_main %>%
      filter(rural == row$rural)
    df %>%
      summarize(
        cor.test(.data[[row$outcome]], .data[[row$circularity]]) %>%
          tidy()
      ) %>%
      bind_cols(row, nobs = nrow(df), .)
  }) %>%
  bind_rows() 

result_corr_rur %>% head()
```


```{r}
for (v_out in params$outcome_vars) {
  unique(df_main$rural) %>%
    set_names() %>%
    map(function(v_rur) {
      x = result_corr_rur %>%
        filter(rural == v_rur, outcome == v_out) %>%
        mutate(term = circularity)
      nobs = unique(x$nobs)
      y = list(
        tidy = x,
        glance = data.frame(N = nobs)
      )
      class(y) = "modelsummary_list"
      y
    }) %>%
    modelsummary(output = "huxtable", stars = TRUE, statistic = NULL) %>%
    set_caption(paste("Outcome:", v_out)) %>%
    print()
}

```


```{r, fig.width=6, fig.height=8}
result_corr_rur %>%
  # filter(outcome != "payroll_gr") %>%
  mutate(circularity = ordered(
    str_replace(circularity, "_", " "),
    levels = str_replace(params$circ_indicators, "_", " ")
  )) %>%
  mutate(`Economic growth` = str_sub(outcome, 1, -4)) %>%
  ggplot(aes(x = circularity, color = rural, group = rural)) +
    geom_point(aes(y = estimate, shape = rural), size = 2, position = position_dodge(0.5)) +
    geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = 0.2, position = position_dodge(0.5)) +
    geom_hline(yintercept = 0, linetype = 2) +
    facet_wrap(vars(`Economic growth`), ncol = 1) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1), axis.title = element_blank(), legend.position = "top")

```



### Comparing rural definitions  

- Establihsment and employment correlation weaker in rural, using either metro/non-metro or core/non-core definitions.

```{r}


for (definition in c("mmn", "m", "c")) {
  v_rur = paste0("rural_", definition)
  df_temp = df_main %>%
    mutate(rural = .data[[v_rur]])

  correlations <- list()
  
  for (economic_measure in params$outcome_vars) {
    correlations_measure <- matrix(nrow = (length(params$circ_indicators) + 1), ncol = 0)
    for (category in unique(df_temp$rural)){
      df_corr <- df_temp |> filter(rural == category)
      temp_correlations = matrix(nrow=3, ncol=0)
      for (circularity_measure in params$circ_indicators) {
          test=cor.test(x = df_corr[[circularity_measure]], y=df_corr[[economic_measure]])
          c_temp = round(c(test$estimate, test$p.value, nrow(df_corr)-sum(is.na(df_corr$economic_measure)|is.na(df_corr$circularity_measure))), 3)
          temp_correlations = cbind(temp_correlations, c_temp)
      }
      rownames(temp_correlations) = c("correlation", "p_value", "obs")
      temp_correlations <- data.frame(t(temp_correlations)) |> 
        mutate(
          sig = if_else(p_value<.01, "**", if_else(p_value<.05,"*","")),
          result = paste0(correlation, sig)
        ) |> 
        select(result, obs)
      temp_correlations <- rbind(temp_correlations, min(temp_correlations$obs)) |> 
        select(result)
      rownames(temp_correlations) = c(params$circ_indicators, "obs")
      correlations_measure <- cbind(correlations_measure, temp_correlations)
    }
    colnames(correlations_measure) <- unique(df_temp$rural)
    correlations[[economic_measure]] <- cbind(correlations_measure, economic_measure)
  }
  
  print(correlations)
}
```

# Regression analysis

```{r}
df_main %>%
  ggplot(aes(x = retention, y = employment_gr, group = rural)) +
  geom_point(size = 0.1) +
  geom_smooth(aes(color = rural), formula = "y ~ x", method = "lm")

```

## Estimation


```{r}
#| output: false

# bulk estimation:
# construct table of regression specifications, estimate and save model objects in a data frame

result_reg =
  # create a table of estimation specification combinations
  expand_grid(
    outcome = params$outcome_vars,
    circularity = params$circ_indicators,
    rurality = c(FALSE, TRUE),
    controls = c(FALSE, TRUE),
    stringsAsFactors = FALSE
  ) %>%
  # iterate over spec table rows, construct model formula and estimate
  pmap(function(...) {
    row = list(...)
    f = paste0(
      row$outcome,
      " ~ ",
      row$circularity,
      if (row$rurality) " * rural" else "",
      if (row$controls) paste(c("", params$control_vars), collapse = " + ") else ""
    )
    m = lm_robust(as.formula(f), data = df_main)
    # return single-row table with specs, formula and model object
    tibble(..., formula = f, model = list(m))
  }) %>%
  bind_rows()

result_reg$model[[1]] %>% summary()
```




```{r}
#| output: false

# Collect circularity coefficients for rural, urban and pooled effects

result_regcoef = result_reg %>%
  pmap(function(rurality, circularity, model, ...) {
    if (rurality) {
      # urban effect = circularity coefficient without interaction
      x1 = model %>%
        tidy(conf.int = FALSE) %>%
        filter(term == circularity) %>%
        select(estimate, std.error, statistic, p.value) %>%
        mutate(rural = "urban", .before = 1)
      
      # rural effect = circularity coef + interaction coef
      # use liner hypothesis test to generate standard error of the sum of coefs
      x2 = model %>%
        multcomp::glht(linfct = glue("{circularity} + `{circularity}:ruralnon-metro` = 0")) %>%
        tidy(conf.int = FALSE) %>%
        select(estimate, std.error, statistic, p.value = adj.p.value) %>%
        mutate(rural = "rural", .before = 1)
      
      x = bind_rows(x1, x2)
    } else {
      # effect in the pooled model
      x = model %>%
        tidy(conf.int = FALSE) %>%
        filter(term == circularity) %>%
        select(estimate, std.error, statistic, p.value) %>%
        mutate(rural = "pooled", .before = 1)
    }
    bind_cols(tibble(circularity = circularity, ..., rurality = rurality), x)
  }) %>%
  bind_rows()

result_regcoef %>% head()
```


## Circularity coefs

In the full model with population and industry controls:

- Retention and autonomy are the most significant coefficients out of all circularity indicators.
- Retention and autonomy have positive effect on all outcomes
  - Only insignificant is autonomy for employment growth, still positive.
  - No significant difference between magnitude of the effect in rural vs urban areas.
- Trade capacity, dependency and openness, when significant, have the same direction of the effect as retention and autonomy (more circularity = more growth).
- Trade balance is insignificant for all outcomes.
- Production capacity (share of intermediates in output) is negative, but almost never significant.
- Production dependency (share of intermediates in input) has negative effect on establishment growth in urban, but positive effect on wage growth in rural.

Models without controls have a lot more significance for circularity coefficients.
Notably, the effect of retention and autonomy on wage growth is negative as seen in pairwise correlations above.


### with controls

```{r}

r = list()
for (var_out in params$outcome_vars) {
  x = list()
  for (var_circ in params$circ_indicators) {
    x1 = result_regcoef %>%
      filter(controls, outcome == var_out, circularity == var_circ) %>%
      rename(term = rural)
    x1 = list(tidy = x1)
    class(x1) = "modelsummary_list"
    x[[sub("_", " ", var_circ)]] = x1
  }
  r[[var_out]] = msummary(x, output = "huxtable", stars = TRUE) %>%
    set_caption(var_out)
}

r$establishment_gr
r$employment_gr
r$payroll_gr
r$wage_gr

```


### without controls

```{r}

r = list()
for (var_out in params$outcome_vars) {
  x = list()
  for (var_circ in params$circ_indicators) {
    x1 = result_regcoef %>%
      filter(!controls, outcome == var_out, circularity == var_circ) %>%
      rename(term = rural)
    x1 = list(tidy = x1)
    class(x1) = "modelsummary_list"
    x[[sub("_", " ", var_circ)]] = x1
  }
  r[[var_out]] = msummary(x, output = "huxtable", stars = TRUE) %>%
    set_caption(var_out)
}

r$establishment_gr
r$employment_gr
r$payroll_gr
r$wage_gr

```


## Side-by-side models

### controls

This example illustrates the significant effect that population and industry share controls have on results.
With controls, retention effect on employment growth becomes weaker, while effect on wage growth changes from negative to positive.


```{r}
x = result_reg %>%
  filter(outcome %in% c("employment_gr", "wage_gr"), circularity == "retention", !rurality) %>%
  arrange_ord(outcome = "asis", rurality = "asis", controls = "asis") %>%
  pull(model, name = outcome)

# order coefficients
x1 = local({
  all_coefs = x %>%
    map(\(m) names(m$coefficients)) %>%
    reduce(union)
  const = "(Intercept)"
  circ_coefs = all_coefs %>%
    keep(\(x) grepl(paste(params$circ_indicators, collapse = "|"), x))
  rural_coefs = all_coefs %>%
    keep(\(x) grepl("rural", x)) %>%
    discard(\(x) x %in% circ_coefs)
  other_coefs = all_coefs %>%
    discard(\(x) x %in% c(const, circ_coefs, rural_coefs))
  ordered_coefs = c(const, rural_coefs, circ_coefs, other_coefs)
  names(ordered_coefs) = sub("rural", "", ordered_coefs)
  ordered_coefs
})

x %>%
  huxreg(coefs = x1, statistics = c(N = "nobs", R2 = "r.squared"))
```

### circularity by outcome

For reference.

```{r}
for (circ_var in params$circ_indicators) {
  result_reg %>%
    filter(rurality, controls, circularity == circ_var) %>%
    pull(model, name = outcome) %>%
    huxreg(statistics = c(N = "nobs", R2 = "r.squared")) %>%
    set_caption(paste("Circularity indicator: ", circ_var)) %>%
    print()
}

```


### outcome by circularity

For reference.

```{r}
r = list()
for (v_out in params$outcome_vars) {
  r[[v_out]] = 
    result_reg %>%
    filter(rurality, controls, outcome == v_out) %>%
    pull(model, name = circularity) %>%
    map(function(m) {
      m$term = m$term %>%
        sub(paste(params$circ_indicators, collapse = "|"), "circularity", .) %>%
        sub("rural", "", .)
      m
    }) %>%
    huxreg(coefs = c("(Intercept)", "non-metro", "circularity", "circularity:non-metro", params$control_vars),
           statistics = c(N = "nobs", R2 = "r.squared")) %>%
    set_caption(paste("Outcome: ", v_out))
}

r$establishment_gr
r$employment_gr
r$payroll_gr
r$wage_gr


```

## Industry share suppression

Including suppression controls in the regressions does not meaningfully affect main coefficient estimates.

```{r}
x1 = result_reg %>%
  filter(rurality, controls)

x2 = x1 %>%
  select(!model) %>%
  pmap(function(formula, ...) {
    f = paste(formula, paste(c("", params$control_sup_vars), collapse = " + "))
    m = lm_robust(as.formula(f), data = df_main)
    tibble(formula = f, ..., model = list(m))
  }) %>%
  bind_rows()

result_regsup =
  bind_rows(
    list(`FALSE` = x1, `TRUE` = x2),
    .id = "sup")

result_regsup %>%
  arrange_ord(outcome = "asis", sup = c(FALSE, TRUE)) %>%
  # choose which models to show
  filter(circularity == "retention") %>%
  pull(model, name = outcome) %>%
  huxreg(statistics = c(N = "nobs", R2 = "r.squared"))
```




## Spatial model

```{r}
#| output: false

if (params$spreg) {
  result_spreg = result_reg %>%
    select(!model) %>%
    # filter out models to reduce the runtime of the spatial estimation
    # filter(controls, !rurality, circularity %in% c("retention", "autonomy")) %>%
    filter(controls, !rurality, circularity %in% c("retention", "autonomy"), outcome %in% c("employment_gr", "wage_gr")) %>%
    pmap(function(formula, ...) {
      m = errorsarlm(formula, data = df_main, listw = sp_lw, zero.policy = TRUE)
      tibble(formula = formula, ..., model = list(m))
    }, .progress = TRUE) %>%
    bind_rows()
  
  result_spreg$model[[1]] %>% summary()
}

```


```{r}
if (params$spreg) {
  # models to compare
  ms = result_reg %>%
    right_join(
      result_spreg %>% filter(circularity == "retention"),
      by = c("outcome", "circularity", "rurality", "controls", "formula"),
      suffix = c("", " SP")) %>%
    pivot_longer(c(model, `model SP`), names_to = "spatial", names_prefix = "model", values_to = "model") %>%
    mutate(lbl = paste0(sub("_gr", "", outcome), spatial))
  
  # residual Moran's I test, combined into a huxtable
  x = ms %>%
    pmap(function(outcome, model, ...) {
      # residuals are available for lm() and errorsarlm(), but must be calculated for lm_robust()
      resi = model$residuals
      if (is.null(resi)) {
        resi = df_main[[outcome]] - model$fitted.values
      }
      
      x1 = moran.test(resi, sp_lw, zero.policy = TRUE)
      x2 = tidy(x1) %>%
        mutate(term = "Residual MI") %>%
        rename(estimate = estimate1)
      x2 = list(tidy = x2)
      class(x2) = "modelsummary_list"
      x2
    }) %>%
    msummary(output = "huxtable", stars = TRUE, statistic = NULL)
  
  # models with appended MI statistic row
  ms %>%
    pull(model, name = lbl) %>%
    huxreg() %>%
    add_rows(x[2, ], after = nrow(.) - 1)
}
```


## Rural definitions

For reference.


```{r}
#| output: false

result_rureg = expand.grid(
  outcome = params$outcome_vars,
  circularity = params$circ_indicators,
  rural_def = c("m", "c", "mmn"),
  stringsAsFactors = FALSE
) %>%
  pmap(function(...) {
    row = list(...)
    f = paste0(
      row$outcome, " ~ ", row$circularity, " * rural_", row$rural_def, 
      paste(c("", params$control_vars), collapse = " + "))
    m = lm_robust(as.formula(f), data = df_main)
    tibble(..., formula = f, model = list(m))
  }) %>%
  bind_rows()

result_rureg$model[[1]] %>% summary()

```




```{r}

for (var_circ in params$circ_indicators) {
  result_rureg %>%
    filter(circularity == var_circ) %>%
    arrange_ord(outcome = "asis", rural_def = "asis") %>%
    mutate(lbl = paste(substr(outcome, 1, 4), rural_def)) %>%
    pull(model, name = lbl) %>%
    map(function(m) {
      names(m$coefficients) = gsub("rural_(mmn|m|c)", "", names(m$coefficients))
      m
    }) %>%
    huxreg(omit_coefs = c("(Intercept)", params$control_vars, "non-metro", "non-core", "micro")) %>%
    set_caption(var_circ) %>%
    print()
}

```



# Share of intermediates


```{r}
df_pcd = df_main %>%
  st_drop_geometry() %>%
  mutate(
    pc_rank = percent_rank(production_capacity),
    pc_bin = case_when(
      pc_rank < 0.25 ~ "low",
      pc_rank > 0.75 ~ "high",
      .default = "med"
    ) %>% ordered(c("low", "med", "high")),
    pd_rank = percent_rank(production_dependency),
    pd_bin = case_when(
      pd_rank < 0.25 ~ "low",
      pd_rank > 0.75 ~ "high",
      .default = "med"
    ) %>% ordered(c("low", "med", "high"))
  )
```


## distribution

- Distribution of trade capacity and retention is very different for high and low levels of production capacity.
- Counties with higher share of intermediates in their output (high PC) tend to export larger share of their output (high trade capacity) and use smaller share of locally produced intermediates (low retention)

```{r}
ggplot(df_pcd) +
  geom_point(aes(production_capacity, trade_capacity), size = 0.1)
ggplot(df_pcd) +
  geom_histogram(aes(trade_capacity, fill = pc_bin), position = "dodge", bins = 10)
ggplot(df_pcd) +
  geom_point(aes(production_capacity, retention), size = 0.1)
ggplot(df_pcd) +
  geom_histogram(aes(retention, fill = pc_bin), position = "dodge", bins = 10)

```
## correlations

```{r}
result_pcd_cor = expand_grid(
  bin_var = c("production_capacity", "production_dependency"),
  circularity = c("trade_capacity", "retention", "trade_dependency", "autonomy"),
  outcome = params$outcome_vars
) %>%
  # keep only relevant combinations
  filter(
    (bin_var == "production_capacity" & circularity %in% c("trade_capacity", "retention"))
    | (bin_var == "production_dependency" & circularity %in% c("trade_dependency", "autonomy"))
  ) %>%
  pmap(function(...) {
    row = list(...)
    df_pcd %>%
      mutate(bin = .data[[switch(row$bin_var, production_capacity = "pc_bin", production_dependency = "pd_bin")]]) %>%
      summarize(
        cor.test(.data[[row$outcome]], .data[[row$circularity]]) %>%
          tidy(),
        .by = "bin"
      ) %>%
      bind_cols(row, .)
  }) %>%
  bind_rows() 



```



```{r}
for (v_bin in c("production_capacity", "production_dependency")) {
  result_pcd_cor %>%
    filter(bin_var == v_bin) %>%
    arrange_ord(outcome = "asis", circularity = "asis") %>%
    mutate(term = paste(outcome, circularity, sep = " x ")) %>%
    base::split(.$bin) %>%
    map(function(x) {
      y = list(tidy = x)
      class(y) = "modelsummary_list"
      y
    }) %>%
    modelsummary(output = "huxtable", stars = TRUE, statistic = NULL) %>%
    huxtable::set_contents(1, 1, v_bin) %>%
    print()
}

```


## regressions




```{r}
#| output: false

result_intreg = expand_grid(
  share_var = c("production_capacity", "production_dependency"),
  circularity = c("trade_capacity", "retention", "trade_dependency", "autonomy"),
  interact = c(FALSE, TRUE),
  outcome = params$outcome_vars
) %>%
  # keep only relevant combinations
  filter(
    (share_var == "production_capacity" & circularity %in% c("trade_capacity", "retention"))
    | (share_var == "production_dependency" & circularity %in% c("trade_dependency", "autonomy"))
  ) %>%
  pmap(function(...) {
    row = list(...)
    f = paste0(
      row$outcome,
      " ~ ",
      row$circularity,
      if (row$interact) paste0(" * ", row$share_var) else "",
      paste(c("", params$control_vars), collapse = " + ")
    )
    m = lm_robust(as.formula(f), data = df_main)
    tibble(..., formula = f, model = list(m))
  }) %>%
  bind_rows()

result_intreg$model[[1]] %>% huxreg()
```


```{r}
r = list()
for (v_circ in c("trade_capacity", "retention", "trade_dependency", "autonomy")) {
  r[[v_circ]] =
    result_intreg %>%
    filter(circularity == v_circ) %>%
    arrange_ord(outcome = "asis", interact = c(FALSE, TRUE)) %>%
    pull(model, name = outcome) %>%
    huxreg(statistics = c(N = "nobs", R2 = "r.squared"), omit_coefs = c("(Intercept)", params$control_vars)) %>%
    set_caption(paste("Circularity variable:", v_circ))
}

r$trade_capacity
r$retention
r$trade_dependency
r$autonomy
```





