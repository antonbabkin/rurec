---
title: "Circularity paper results"
format:
  html:
    toc: true
    toc-depth: 2
    embed-resources: true
    code-fold: true
---
  

```{r}

# additional library list
library(logger)
library(tidyverse)
library(correlation)
library(modelsummary)
library(kableExtra)
library(broom)
library(patchwork)
library(ggthemes)
library(ggridges)
library(viridis)
library(tmap)
library(tigris)
library(skimr)
library(gtsummary)
library(RColorBrewer)

# scripts
source("R/basic_utilities.R", local = (util <- new.env()))
source("R/dataprep.R", local = (dataprep <- new.env()))
source("R/geography.R", local = (geography <- new.env()))
source("R/place_io.R", local = (place_io <- new.env()))
source("R/circularity.R", local = (circularity <- new.env()))

# data parameters
params = list(
  circularity_year = 2012,
  shapefile_year = 2013,
  base_year = 2012,
  end_year = 2016,
  bus_data = "cbp_imp",
  cbsa_year = 2013, # (Delineations available for years 2003:2009, 2013, 2015, 2017, 2018, 2020)
  circ_indicators = c("production_capacity", "trade_capacity", "retention", "production_dependency", "trade_dependency", "autonomy", "trade_balance", "trade_openness"),
  outcomes = c("employment_gr", "payroll_gr", "wage_gr") 
)

```

# Data cache

```{r}
ipath <- c(dataprep$opath, geography$opath, place_io$opath)
# create zip file with cache
# util$zip_pack("tmp/cache_circ_paper_results_v241126.zip", ipath)
# unpack cache from zip file
# util$zip_unpack("tmp/cache_circ_paper_results_v241126.zip", overwrite = TRUE)
```


# Analytical datasets

```{r}
df_geo <- geography$call_geog(params$shapefile_year)
df_outsupdem <- place_io$outsupdem(params$circularity_year, "det", params$bus_data) %>%
  mutate(exsup = pmax(0, supply - demand), exdem = pmax(0, demand - supply))
df_circ <- circularity$circularity_indicators(params$circularity_year, params$bus_data)

# business growth rates
df_busdata <- list()
for (period in c("base", "end")) {
  year <- params[[paste0(period, "_year")]]
  pay <- dataprep$call_county_payroll(year, params$bus_data)
  df_busdata[[period]] <- dataprep$call_county_employment(year, params$bus_data) %>%
    inner_join(pay, by = "place") %>%
    mutate(wage = 1000 * payroll / employment)
}
df_busdata <- inner_join(df_busdata$end, df_busdata$base, by = "place", suffix = c(".current", ".base")) %>%
  mutate(
    employment_gr = (employment.current - employment.base) / (.5 * employment.current + .5 * employment.base),
    payroll_gr = (payroll.current - payroll.base) / (.5 * payroll.current + .5 * payroll.base),
    wage_gr = (wage.current - wage.base) / (.5 * wage.current + .5 * wage.base),
  )

# CBSA data for metro/non-metro definitions
df_cbsa <- geography$pubdata$get_cbsa_delin_df(params$cbsa_year)%>%
  select(STATE_CODE, COUNTY_CODE, METRO_MICRO) 

df_main <- df_geo %>%
  right_join(df_circ, "place") %>%
  left_join(df_busdata, "place") %>% 
  left_join(df_cbsa, by = join_by(STATE_CODE, COUNTY_CODE)) %>%
  mutate(cbsa_rural_category = if_else(METRO_MICRO == "metro", FALSE, TRUE, missing = TRUE))

df_main %>% head()
```



# Examples

```{r}
# Dairy and Cheese 
commodities = c("112120", "311513")
counties = c("55117","55081")

# Animal Feed and Dairy
# commodities = c("311119", "112120")
# counties = c("17001", "17027")

# Plastics and Medical Device Manufacturing
# commodities = c("^3261", "339112")
# counties = c("27053","27025")

x <- df_outsupdem %>%
  filter(com_code %in% commodities, place %in% counties) %>%
  left_join(df_geo, "place") %>%
  mutate(
    locally_met = pmin(supply, demand),
    id = paste(NAME, "county,", STATE, "(", place, ")"),
    across(where(is.numeric), round)
  ) %>%
  arrange(place, com_code)
  
select(x, id, com_code, output, supply, demand)
select(x, id, com_code, output, supply, demand, locally_met, exsup, exdem)


for (com in commodities) {
  x <- df_outsupdem %>%
    filter(com_code == {{com}}) %>%
    left_join(df_geo, "place") %>%
    mutate(log_supdem = sign(exsup - exdem) * log10(1 + pmax(exsup, exdem))) %>%
    st_as_sf() %>%
    shift_geometry()
  com_name <- x %>% pull(com_name) %>% unique()
  x_st <- x %>%
    group_by(STATE_CODE) %>%
    summarise()
  
  p <- tm_shape(x) +
    tm_polygons(
      title = com_name,
      col = "log_supdem",
      border.alpha = 0.0,
      style = "cont",
      midpoint = 0,
      breaks = seq(-10, 10, 2),
      palette = rev(brewer.pal(9, "RdBu"))) +
    tm_shape(x_st) +
    tm_layout(
      legend.title.size = .8,
      legend.text.size = .5,
      legend.position = c("LEFT", "TOP"),
      frame = F,
      fontface = 2 ) +
    tm_borders(lwd = 1.5)
  
  print(p)
} 

    
```


# Descriptives table

```{r, message=FALSE}
#| paged.print=FALSE

df_main %>%
  st_drop_geometry() %>%
  select(c(params$outcomes, params$circ_indicators)) %>%
  skim()
```

# Density distributions

```{r}
#| warning: false

# density distributions for all 8 circularity indicators

for (circ_measure in params$circ_indicators) {
  n <- str_replace_all(circ_measure, "_", " ") %>% str_to_title()
  (ggplot(df_main) +
    # geom_density(aes(x = .data[[circ_measure]]), fill = "#88CCEE", alpha = 0.4) +
    geom_histogram(aes(x = .data[[circ_measure]]), fill = "#88CCEE", binwidth = 0.01) +
    theme_pander() +
    theme(legend.position = "none") +
    ggtitle(n) +
    xlim(ifelse(circ_measure == "trade_balance", -1, 0), ifelse(circ_measure == "trade_openness", 2, 1)) +
    ylab("Count") +
    xlab(n) ) %>%
    print()
}


```


# Spatial distributions



```{r}
# maps for all 8 circularity indicators


df_main %>% 
  shift_geometry() %>% {(
  for (circ_measure in params$circ_indicators) {(
      tm_shape(.) +
        tm_polygons(
          title = str_replace_all(circ_measure, "_", " ") %>% str_to_title(),
          col = circ_measure,
          border.alpha = 0.0,
          style = "cont",
          midpoint = 0,
          breaks = switch(
            circ_measure,
            "trade_balance" = seq(-.5, .5, .1),
            "trade_openness" = seq(0, 1.25, 0.25),
            seq(0, 1, 0.25)),
          palette = rev(brewer.pal(9, "RdBu"))) +
        group_by(., STATE_CODE) %>% summarise() %>% tm_shape() +
        tm_layout(
          legend.title.size = .8,
          legend.text.size = .5,
          legend.position = c("LEFT", "TOP"),
          frame = F,
          fontface = 2 ) +
        tm_borders(lwd = 1.5) ) %>% 
      print()
  })
} 

```

# Rural divide 
```{r, message=FALSE}
#| paged.print=FALSE


# repeat all tables and density plots above with a rurality bifurcation

# motivation: “rural places might be disadvantaged by their place in the supply chain”
# does this support the hypothesis that values of metro and nonmetro are the same or not?
# can the indicators be associated with economic outcomes? and across rurality?

if (FALSE) {
  print("Non-metro:")
  df_main %>%
    st_drop_geometry() %>%
    filter(cbsa_rural_category == TRUE) %>%
    select(params$circ_indicators) %>%
    summary()
  print("Metro:")
  df_main %>%
    st_drop_geometry() %>%
    filter(cbsa_rural_category == FALSE) %>%
    select(params$circ_indicators) %>%
    summary()
} else {
df_main %>%
  st_drop_geometry() %>%
  group_by(cbsa_rural_category) %>%
  mutate(log_excess_supply = log(exsup), 
         log_excess_demand = log(exdem), 
         log_local_supply = log(supply - exsup), 
         log_local_demand = log(demand - exdem)) %>% 
  select(c("log_excess_supply", "log_excess_demand", "log_local_supply", "log_local_demand", params$outcomes, params$circ_indicators)) %>%
  skim()
}



```


```{r}
# density distributions controlling for rurality

df_main %>%
  mutate(metro_status = ifelse(cbsa_rural_category == TRUE, "non-metro", 
                               ifelse(cbsa_rural_category == FALSE, "metro", NA) )) %>% {
  
    (for (circ_measure in params$circ_indicators) {
      n <- str_replace_all(circ_measure, "_", " ") %>% str_to_title()
      (
        ggplot(.) +
          geom_density(aes(x = .data[[circ_measure]], fill = metro_status), alpha = 0.4) +
          theme_pander() +
          xlim(ifelse(circ_measure == "trade_balance", -1, 0), ifelse(circ_measure == "trade_openness", 2, 1)) +
          scale_fill_manual(values = c("black","#88CCEE")) +
          theme(legend.position = "top") +
          labs(
            fill = "CBSA status",
            y = "Density",
            x = n,
            title = n
          )
      ) %>% print()
    })
  }


```



# Correlation tables
```{r}

# 8 by 8 
# be sparing, limit overlap with Sara/Clayton results elsewhere
# add employment growth, payroll growth, wage growth against the 8 circularity indicators
# look for association of circularity with positive economic outcomes beyond random chance

correlations <- matrix(nrow = length(params$circ_indicators) + 1, ncol = 0)
for (economic_measure in params$outcomes) {
  temp_correlations = matrix(nrow=3, ncol=0)
  for (circularity_measure in params$circ_indicators) {
    test=cor.test(x = df_main[[circularity_measure]], y=df_main[[economic_measure]])
    c_temp = round(c(test$estimate, test$p.value, nrow(df_main)-sum(is.na(df_main$economic_measure)|is.na(df_main$circularity_measure))), 3)
    temp_correlations = cbind(temp_correlations, c_temp)
  }
  rownames(temp_correlations) = c("correlation", "p_value","obs")
  temp_correlations <- data.frame(t(temp_correlations)) |> 
    mutate(
      sig = if_else(p_value<.01, "**", if_else(p_value<.05,"*","")),
      result = paste0(correlation, sig)
    ) |> 
    select(result, obs)
  temp_correlations <- rbind(temp_correlations, min(temp_correlations$obs)) |> 
    select(result)
  correlations <- cbind(correlations, temp_correlations)
}
rownames(correlations) = c(params$circ_indicators, "obs")
colnames(correlations) <- params$outcomes
correlations



```
## figure for slides


```{r}
correlations <- data.frame()
for (economic_measure in params$outcomes) {
  for (circularity_measure in params$circ_indicators) {
    correlations <- cor.test(x = df_main[[circularity_measure]], y=df_main[[economic_measure]]) %>%
      broom::tidy() %>%
      select(estimate, conf.low, conf.high) %>%
      mutate(economic_measure = economic_measure, circularity_measure = circularity_measure, .before = 1) %>%
      rbind(correlations, .)
  }
}

p <- correlations %>%  
  mutate(circularity_measure = ordered(
    str_replace(circularity_measure, "_", " "),
    levels = str_replace(params$circ_indicators, "_", " ")
  )) %>%
  mutate(`Economic growth` = str_sub(economic_measure, 1, -4)) %>%
  ggplot(aes(x = circularity_measure, color = `Economic growth`, group = `Economic growth`)) +
  geom_point(aes(y = estimate, shape = `Economic growth`), size = 2, position = position_dodge(0.5)) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = 0.2, position = position_dodge(0.5)) +
  geom_hline(yintercept = 0, linetype = 2) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), axis.title = element_blank())

p
```




# Correlation tables Rurality
```{r}

# repeat as above with rural divide 
# what are the policy implications and discrepancies?
# what indicators are relevant to the rural vs nonrural counties?

correlations <- list()

for (economic_measure in params$outcomes) {
  correlations_measure <- matrix(nrow = (length(params$circ_indicators) + 1), ncol = 0)
  for (rural in c(TRUE, FALSE)){
    df_corr <- df_main |> filter(cbsa_rural_category == rural)
    temp_correlations = matrix(nrow=3, ncol=0)
  for (circularity_measure in params$circ_indicators) {
      test=cor.test(x = df_corr[[circularity_measure]], y=df_corr[[economic_measure]])
      c_temp = round(c(test$estimate, test$p.value, nrow(df_corr)-sum(is.na(df_corr$economic_measure)|is.na(df_corr$circularity_measure))), 3)
      temp_correlations = cbind(temp_correlations, c_temp)
    }
    rownames(temp_correlations) = c("correlation", "p_value", "obs")
    temp_correlations <- data.frame(t(temp_correlations)) |> 
      mutate(
        sig = if_else(p_value<.01, "**", if_else(p_value<.05,"*","")),
        result = paste0(correlation, sig)
      ) |> 
      select(result, obs)
    temp_correlations <- rbind(temp_correlations, min(temp_correlations$obs)) |> 
      select(result)
    rownames(temp_correlations) = c(params$circ_indicators, "obs")
    correlations_measure <- cbind(correlations_measure, temp_correlations)
  }
  colnames(correlations_measure) <- c(paste0("rural =", c(TRUE, FALSE)))
  correlations[[economic_measure]] <- cbind(correlations_measure, economic_measure)
}

correlations


```


## figure for slides



```{r}
correlations <- data.frame()
for (economic_measure in params$outcomes) {
  for (circularity_measure in params$circ_indicators) {
    for (rural in c(TRUE, FALSE)) {
      correlations <- df_main %>%
        filter(cbsa_rural_category == rural) %>%
        {cor.test(x = .[[circularity_measure]], y = .[[economic_measure]])} %>%
        broom::tidy() %>%
        select(estimate, conf.low, conf.high) %>%
        mutate(
          economic_measure = economic_measure,
          circularity_measure = circularity_measure,
          rural = rural,
          .before = 1
        ) %>%
        rbind(correlations, .)
    }
  }
}

(
  p <- correlations %>%
  filter(economic_measure != "payroll_gr") %>%
  mutate(rural = case_match(rural, TRUE ~ "non-metro", FALSE ~ "metro")) %>%
  mutate(circularity_measure = ordered(
    str_replace(circularity_measure, "_", " "),
    levels = str_replace(params$circ_indicators, "_", " ")
  )) %>%
  mutate(`Economic growth` = str_sub(economic_measure, 1, -4)) %>%
  ggplot(aes(x = circularity_measure, color = rural, group = rural)) +
  geom_point(aes(y = estimate, shape = rural), size = 2, position = position_dodge(0.5)) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = 0.2, position = position_dodge(0.5)) +
  geom_hline(yintercept = 0, linetype = 2) +
  facet_wrap(vars(`Economic growth`), ncol = 1) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), axis.title = element_blank())
)
```

# Different level of capacity

```{r}



# How does retention and economic outcomes vary across high and low production capacity places?

temp = df_main %>% st_drop_geometry() %>% summarize(
  p25 = quantile(production_capacity, c(.25), na.rm = TRUE),
  p75 = quantile(production_capacity, c(.75), na.rm = TRUE)
)

pc_p25 = sum(temp$p25)
pc_p75 = sum(temp$p75)

# Low production capacity
df_lowPC = df_main %>% filter(production_capacity < pc_p25)
indicators = df_lowPC %>%
  st_drop_geometry() %>%
  select('retention', 'trade_capacity') %>%
  colnames()
indicators2 = c("wage_gr", "payroll_gr", "employment_gr")
for (a in indicators2) {
  for (i in indicators) {
    test = cor.test(x = df_lowPC[[i]], y = df_lowPC[[a]])
    assign(paste0("est_", i), unlist(unname(test$estimate)))
    assign(paste0("pval_", i), unlist(unname(test$p.value)))

  }
    temp2 = c(est_retention, est_trade_capacity)
    temp3 = c(pval_retention, pval_trade_capacity)
    t4 = as.data.frame(list(
      name = indicators,
      est = temp2,
      pval = temp3
    ))
    assign(paste0("cor_", a), t4)
}
cor_employment_gr %>% rename("LOW P.C. employment_gr" = "name")
cor_wage_gr %>% rename("LOW P.C. wage_gr" = "name")
cor_payroll_gr %>% rename("LOW P.C. payroll_gr" = "name")

# Mid production capacity
df_lowPC = df_main %>% filter(production_capacity >= pc_p25 &
                           production_capacity < pc_p75)
indicators = df_lowPC %>%
  st_drop_geometry() %>%
  select('retention', 'trade_capacity') %>%
  colnames()
indicators2 = c("wage_gr", "payroll_gr", "employment_gr")
for (a in indicators2) {
  for (i in indicators) {
    test = cor.test(x = df_lowPC[[i]], y = df_lowPC[[a]])
    assign(paste0("est_", i), unlist(unname(test$estimate)))
    assign(paste0("pval_", i), unlist(unname(test$p.value)))

  }
    temp2 = c(est_retention, est_trade_capacity)
    temp3 = c(pval_retention, pval_trade_capacity)
    t4 = as.data.frame(list(
      name = indicators,
      est = temp2,
      pval = temp3
    ))
    assign(paste0("cor_", a), t4)
}
cor_employment_gr %>% rename("MID P.C. employment_gr" = "name")
cor_wage_gr %>% rename("MID P.C. wage_gr" = "name")
cor_payroll_gr %>% rename("MID P.C. payroll_gr" = "name")

# High production capacity
df_lowPC = df_main %>% filter(production_capacity >= pc_p75)
indicators = df_lowPC %>%
  st_drop_geometry() %>%
  select('retention', 'trade_capacity') %>%
  colnames()
indicators2 = c("wage_gr", "payroll_gr", "employment_gr")
for (a in indicators2) {
  for (i in indicators) {
    test = cor.test(x = df_lowPC[[i]], y = df_lowPC[[a]])
    assign(paste0("est_", i), unlist(unname(test$estimate)))
    assign(paste0("pval_", i), unlist(unname(test$p.value)))

  }
    temp2 = c(est_retention, est_trade_capacity)
    temp3 = c(pval_retention, pval_trade_capacity)
    t4 = as.data.frame(list(
      name = indicators,
      est = temp2,
      pval = temp3
    ))
    assign(paste0("cor_", a), t4)
}
cor_employment_gr %>% rename("HIGH P.C. employment_gr" = "name")
cor_wage_gr %>% rename("HIGH P.C. wage_gr" = "name")
cor_payroll_gr %>% rename("HIGH P.C. payroll_gr" = "name")

# How does autonomy and economic outcomes vary across high and low production dependency places?
temp = df_main %>% st_drop_geometry() %>% summarize(
  p25 = quantile(production_dependency, c(.25), na.rm = TRUE),
  p75 = quantile(production_dependency, c(.75), na.rm = TRUE)
)

pd_p25 = sum(temp$p25)
pd_p75 = sum(temp$p75)

# Low production dependency
df_lowPD = df_main %>% filter(production_dependency < pd_p25)
indicators = df_lowPD %>%
  st_drop_geometry() %>%
  select('autonomy', 'trade_dependency') %>%
  colnames()
indicators2 = c("wage_gr", "payroll_gr", "employment_gr")
for (a in indicators2) {
  for (i in indicators) {
    test = cor.test(x = df_lowPD[[i]], y = df_lowPD[[a]])
    assign(paste0("est_", i), unlist(unname(test$estimate)))
    assign(paste0("pval_", i), unlist(unname(test$p.value)))
  }
  temp2 = c(est_autonomy, est_trade_dependency)
  temp3 = c(pval_autonomy, pval_trade_dependency)
  t4 = as.data.frame(list(
    name = indicators,
    est = temp2,
    pval = temp3
  ))
  assign(paste0("cor_", a), t4)
}
cor_employment_gr %>% rename("LOW P.D. employment_gr" = "name")
cor_wage_gr %>% rename("LOW P.D. wage_gr" = "name")
cor_payroll_gr %>% rename("LOW P.D. payroll_gr" = "name")

# Mid production dependency
df_lowPD = df_main %>% filter(production_dependency >= pd_p25 &
                           production_dependency < pd_p75)
indicators = df_lowPD %>%
  st_drop_geometry() %>%
  select('autonomy', 'trade_dependency') %>%
  colnames()
indicators2 = c("wage_gr", "payroll_gr", "employment_gr")
for (a in indicators2) {
  for (i in indicators) {
    test = cor.test(x = df_lowPD[[i]], y = df_lowPD[[a]])
    assign(paste0("est_", i), unlist(unname(test$estimate)))
    assign(paste0("pval_", i), unlist(unname(test$p.value)))
  }
  temp2 = c(est_autonomy, est_trade_dependency)
  temp3 = c(pval_autonomy, pval_trade_dependency)
  t4 = as.data.frame(list(
    name = indicators,
    est = temp2,
    pval = temp3
  ))
  assign(paste0("cor_", a), t4)
}
cor_employment_gr %>% rename("MID P.D. employment_gr" = "name")
cor_wage_gr %>% rename("MID P.D. wage_gr" = "name")
cor_payroll_gr %>% rename("MID P.D. payroll_gr" = "name")

# High production dependency
df_lowPD = df_main %>% filter(production_dependency >= pd_p75)
indicators = df_lowPD %>%
  st_drop_geometry() %>%
  select('autonomy', 'trade_dependency') %>%
  colnames()
indicators2 = c("wage_gr", "payroll_gr", "employment_gr")
for (a in indicators2) {
  for (i in indicators) {
    test = cor.test(x = df_lowPD[[i]], y = df_lowPD[[a]])
    assign(paste0("est_", i), unlist(unname(test$estimate)))
    assign(paste0("pval_", i), unlist(unname(test$p.value)))
  }
  temp2 = c(est_autonomy, est_trade_dependency)
  temp3 = c(pval_autonomy, pval_trade_dependency)
  t4 = as.data.frame(list(
    name = indicators,
    est = temp2,
    pval = temp3
  ))
  assign(paste0("cor_", a), t4)
}
cor_employment_gr %>% rename("HIGH P.D. employment_gr" = "name")
cor_wage_gr %>% rename("HIGH P.D. wage_gr" = "name")
cor_payroll_gr %>% rename("HIGH P.D. payroll_gr" = "name")


```





