---
title: "Maps and IO Similarity Index: Iowa"
author: "Austin Sandler"
date: "2022-09-03"
format:
  html:
    self-contained: true
    page-layout: full
    code-fold: true
    code-tools: true
    code_download: yes
    latex_engine: pdflatex
---


```{r preamble, include = FALSE}
# When you click the **Render** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document.
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 

#For nonscientific notation
options(scipen=999)

```


```{r packages and libraries, include = FALSE}
# Load and attach necessary packages
library(rprojroot)
library(tidyr)
library(Matrix)
library(dplyr)
library(reshape2)
library(ggplot2)
library(ggiraph)
library(glue)
library(magrittr)
library(ggforce)
library(cowplot)
library(tibble)
library(sf)
library(ggpattern)


# library(dash)
# library(dlm)
# library(DT)
# library(gtools)
# library(knitr)
# library(plotly)
# library(scales)
# library(tools)

#Load custom functions
#source(file.path(find_rstudio_root_file(), "nbs", "rural_typology_r_data_generation.R"))
source(file.path(find_rstudio_root_file(), "nbs", "rural_typology_r_functions.R"))



```

```{r load data, include=FALSE}
# Load previously generated datafiles
importr(TIGER_RUCC)
#importr(Queego)
#importr(Queeg_relo)
importr(Output_mat)
importr(Impede_mat)
#importr(Input_mat_exp)
#importr(Input_mat_imp)
#importr(Input_mat_expo)
#importr(Input_mat_impo)
importr(Direct_mat)

# importr(Total_mat)
# importr(Xpay_mat)
# #importr(D_mat)

industry_levels  <-  c("Sector", "Summary", "Detail")

# Queeg_listo <- list(Queego, Queeg_relo)
# names(Queeg_listo) <- c("Queego",  "Queeg_relo")

data_dir = file.path(find_rstudio_root_file(), "data", "robjs")

```


This document attempts to map the various topological similarity index relationships for Iowa counties.

::: {.panel-tabset}


### Methods

I-O analysis, or inter-industry analysis, is an economic tool that measures the relationships between industries in the economy. The framework measures flows of products from each of the sectors (as a producer/seller) to each of the sectors (as a purchaser/buyer); these interindustry flows, or transactions are measured for a particular time period and in monetary terms.  

We categorize the economy into $n$ sectors and let $x_{i}$ denote the total output of sector $i$. We denote $f_{i}$ as *final demand*, which represents all sales that are *exogenous* to the industrial sectors (e.g., households, government, and foreign trade). Taken together, we specify sector  $i$'s *output* with an accounting  identity $x_{i} = \sum^{n}_{j=1}z_{ij} + f_{i}$ that describes the way in which sector $i$ distributes its product to other sectors and to final demand, here the $z_{ij}$ terms represent *interindustry* sales by sector $i$ to all $j$ sectors in $n$. 

Let the *total output* of all sectors be summarized by: 
$$\mathbf{x} = \mathbf{Zi} + \mathbf{f}$$
where $\mathbf{i}$ represent a column vector of 1’s. 

We define the *input coefficient*, $a_{ij} = z_{ij}/x_{j}$ to be the quantity of the output of sector $i$ absorbed by sector $j$ per unit of its total output. This ratio is also known as the *technical coefficient*; the *input–output coefficient*;  or the *direct input coefficient*, specifies the required amount of industry $i$’s commodity used to produce of one unit of industry $j$’s commodity. 

Let the $n \times n$ *technical coefficient matrix* by summarized by:  
$$\mathbf{A} = \mathbf{Z\hat{x}^{-1}}$$
where the “hat” over a vector denotes a diagonal matrix. Therefore, given a set of fixed technical coefficients, $\mathbf{x} = \mathbf{Ax} + \mathbf{f}$ denotes the accounting equation for the distribution of total output to all sectors and final demand. Note the inherent production functions of this system are isoquant “curves” that exhibit constant output. Such *Leontief* production functions require inputs in fixed proportions, where a fixed amount of each input is required to produce one unit of output.  

If $(\mathbf{I} - \mathbf{A})$ is non-singular, where $\mathbf{I}$ is the identity matrix, then rearranging gives, $\mathbf{x} = \left(\mathbf{I} - \mathbf{A}\right)^{-1}\mathbf{f}$. Let the *Leontief* inverse or the *total requirements matrix* be given by:
$$\mathbf{L} = \left(\mathbf{I} - \mathbf{A}\right)^{-1}$$ 
Finally, in much the same way that subscript $i$ denotes an industry sector, we let superscript $r$ designate subnational geographies. Thus, $\mathbf{x^{r}}$ denotes the vector of gross output of all industries  in region $r$.


In  practice, we derive a national-level, industry-by-industry direct requirements matrix, $\mathbf{A}$ from the national-level, industry-by-industry total requirements matrix, $\mathbf{L}$ available from the U.S. Bureau of Economic Analysis (BEA) at three levels of industry specificity  (i.e.,  Sector,  Summary, and Detail). We construct the location specific total output vector, 𝐱rfrom a payroll and labor share quotient using  Census Bureau County Business Patterns  (CBP) or FSRDC depending on the desired spatial scale. With these two inputs we construct location specific metrics of industry input needs.

**Location specific metrics of industry inputs**

First, we specify the place specific *input needs vector* as: 
$$\mathbf{Ax^{r}}$$
In addition, we define the *net import shortage vector* as: 
$$\text{NIS}^{r} = \max \{\mathbf{Ax^{r}} - \mathbf{x^{r}}, 0\}$$ 

Similarly, we define the *net input excess vector* as: 
$$\text{NIE}^{r} = \max \{\mathbf{x^{r} - \mathbf{Ax^{r}}}, 0\}$$

**Cross location industry compatibility**

To elucidate the industrial compatibility across locations, we construct a *similarity index*. In general, it is defined on the metric space $(\mathfrak{X}, \mathfrak{D})$ where $\mathfrak{X}$ is a set of vectors $\{\mathbf{x}_{i} \in \mathbb{R} : i \in \{1, \dots, n \}\}$ and $\mathfrak{D}:\mathfrak{X} \times \mathfrak{X}	\rightarrow \mathbb{R}$ is a distance function.  

We first define an *absorption* vector between exporting location $r$ and importing location $s$ as: 
$$\min\{\text{NIE}^{r}, \text{NIS}^{s} \}$$

Finally, to match geographies through their supply chain capacitance we specify the novel *Queeg* distance as: 
$$\arg \max_{l} \{\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}\}~ \forall ~ r,s \in l$$ 

Places with net input excesses will have capacity to export their commodities to places with net shortage capacity. The pair of geographies with the largest overall economic capacity overlap are matched together. In practice $s$ places enter as pre-specified non-rural cores and all other rural places $r$ are matched to them. 

To restrict the capacitance magnitudes we specify the *Relative Queeg* distance as: 
$$\arg \max_{l} \{\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}/\mathbf{i'}\text{NIE}^{r}\}~ \forall ~ r,s \in l$$
Note: Contrary to the other similarity indices the *Queeg* measure is not a "distance" where the $\arg \min$ matches two places. But rather the *Queeg* specification is a congruence or compatibility metric where the $\arg \max$  matches two places.

**Spatial considerations**

In addition, we weight the economic capacitance metric by a *geographical impedance function*, $\mathbf{Q}$.  For example, in practice the geographical impedance between locations $r$ and $s$ may be defined as: the Inverse Square Function $Q^{rs} = 1/(d^{rs})^2$, the Exponential Decay Function $Q^{rs} = e^{-d^{rs}}$, or the Hyperbolic Secant Function $Q^{rs} = 2 / (e^{-d^{rs}} +e^{d^{rs}})$, where $d^{rs}$ is the great-circle distance between the two locations. Specifically, 
$d^{rs}  = R \cdot \arccos(\sin(\phi_{r})\sin(\phi_{s}) + \cos(\phi_{r})\cos(\phi_{s})\cos(\vert \lambda_{r} - \lambda_{s} \vert))$, where $\lambda_{r}, \phi_{r}$ and $\lambda_{s}, \phi_{r}$ are the longitude and latitude of locations $r$ and $s$, and $R$ is the radius of the reference sphere, which in this case is the *mean earth radius* from the WGS84 ellipsoid. 


Let the novel *Spatial Queeg* distance between exporting locations $r$ and importing location $s$ be given by:
$$\arg \max_{l} \{(\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}) * Q^{rs} \}~ \forall ~ r,s \in l$$ 
And similarly, let the *Spatial Relative Queeg* distance be given by: 
$$\arg \max_{l} \{(\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}/\mathbf{i'}\text{NIE}^{r}) * Q^{rs}  \}~ \forall ~ r,s \in l$$
Alternative specifications of the spatial distance are possible. One possibility is to discretize the impedance matrix as a binary proximity operator which is one when two locations share a boundary (or vertex) and zero otherwise.  





### Natural Matching


```{r}
#Specify regional extent and possible (MSA) clusters

metro <- c("19193", 
           "19085",
           "19155",
           "19129",
           "19121",
           "19181",
           "19077",
           "19049",
           "19153",
           "19099",
           "19015",
           "19169",
           "19017",
           "19075",
           "19013",
           "19061",
           "19011",
           "19113",
           "19105",
           "19103",
           "19183",
           "19163")

micro <- c("19059", 
           "19041",
           "19021",
           "19027",
           "19187",
           "19195",
           "19033",
           "19127",
           "19125",
           "19123",
           "19179",
           "19101",
           "19045",
           "19139",
           "19057",
           "19111")


Desmoines <- c("19153",
               "19121",
               "19181",
               "19077",
               "19049",
               "19099")

Ames <- c("19169",
          "19015")

Siouxcity <- c("19193",
               "46127",
               "31043",
               "31051")

Omaha  <- c("19155",
            "19085",
            "19129",
            "31177",
            "31055",
            "31153",
            "31025",
            "31155")

Wateloo <- c("19013",
             "19017",
             "19075")

Cedarrrapids <- c("19113",
                  "19011",
                  "19105")

Iowacity <-  c("19103",
               "19183")

Davenport <- c("19163",
               "17161",
               "17073",
               "17131")

Masoncity <- c("19033",
               "19195")

Burlington <- c("19057",
                "17071")

Keokuk  <- c("19111",
             "17067",
             "29045")

```


```{r}

#Produce new clustered total output matrix from matched cores

macc <- grep("^19", rownames(TIGER_RUCC), value=TRUE)
singcc <- grep("^19", rownames(TIGER_RUCC), value=TRUE)
ext <- NA
industry_levels <-industry_levels

trimr(specname=Output_mat_H1, macc=macc, singcc=singcc, ext=NA, industry_levels=industry_levels, o_mat=Output_mat)

```


```{r}
###First level calc

############ Input Needs
Input_Needs(specname=Input_mat_H1, o_mat=Output_mat_H1, industry_levels=industry_levels)

############ Import Input Needs
Import_Needs(specname=Input_mat_imp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Net Exports
Export_Needs(specname=Input_mat_exp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Relative Queeg specification
Rel_Queeg(specname=Queeg_rel_H1, o_mat=Output_mat_H1, im_mat=Input_mat_imp_H1, ex_mat=Input_mat_exp_H1, industry_levels=industry_levels)

```



```{r}
#Produce new clustered total output matrix from matched cores

###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#geographical impedance (used here for breaking ties)
imp_mat <- Impede_mat[[4]]

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, th_iso=th_iso, nomatch_core_out=nomatch_core_out, queeg_mat=Queeg_rel_H1, imp_mat=Impede_mat[[4]], macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=0.05)
```


```{r}
##Top absorption overlaps by core for each non-core
im_mat=Input_mat_imp_H1
ex_mat=Input_mat_exp_H1
#impind <- colnames(CoreMatch[[l]])
impind <- c("19113", "19103", "19021")
macc <- grep("^19", rownames(TIGER_RUCC), value=TRUE)

absorbr(top_absorb=top_absorb, all_absorb=all_absorb, in_core=in_core, im_mat=Input_mat_imp_H1, ex_mat=Input_mat_exp_H1, impind=impind, macc=macc, industry_levels=industry_levels)



###Custom Graph colors for import county bubbles
  values = c("#ffffb3",  "#fccde5",  "#80b1d3")
  #values = c("#e31a1c",  "#1f78b4",  "#33a02c", "#ff7f00", "#6a3d9a", "#ffff99",  "#b15928", "#fb9a99",  "#b2df8a", "#fdbf6f",  "#cab2d6", "#a6cee3",  "#1b9e77",  "#d95f02",  "#7570b3",  "#e7298a", "#66a61e", "#e6ab02", "#8dd3c7", "#ffffb3",  "#bebada", "#fb8072", "#80b1d3")
   my_pal_graph <- c()
      for(m in 1:length(unique(union(in_core[[1]]$core_fips, union(in_core[[2]]$core_fips, in_core[[3]]$core_fips))))){
        my_pal_graph[m] =  values[m]
      }
  names(my_pal_graph) <- sort(unique(union(in_core[[1]]$core_fips, union(in_core[[2]]$core_fips, in_core[[3]]$core_fips))))


  
 ###Graphs of import and export absorption
graphr(specname=ggtop, top_absorb=top_absorb, TIGER_RUCC=TIGER_RUCC, my_pal=my_pal_graph, macc=macc, industry_levels=industry_levels)


```



```{r, warning=FALSE}

####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- .05
  # ext <- list(Masoncity = Masoncity,
  #             Burlington = Burlington,
  #             Keokuk  = Keokuk,
  #             Desmoines = Desmoines,
  #             Ames = Ames,
  #             Siouxcity = Siouxcity,
  #             Omaha = Omaha,
  #             Wateloo = Wateloo,
  #             Cedarrrapids = Cedarrrapids,
  #             Iowacity = Iowacity,
  #             Davenport = Davenport)
  #macc <- colnames(Queeg_rel_H1[[3]])
 ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=Impede_mat[[4]]) 

#####Custom colors 
 values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
 placenames = h1m[[3]]$lab
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)
 

####Mapping Economic and Spatial cluster matching with isolation
  mapr2(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
      
```


```{r, warning=FALSE}

  ### Maps for multiple industry  levels 
  # gplot = plot_grid(p[[1]] + theme(legend.position = 'none'), 
  #                   p[[2]] + theme(legend.position = 'none'), 
  #                   p[[3]] + theme(legend.position = 'none'),
  #                       labels = c("Sector", "Summary", "Detail"),
  #                       nrow = 1,
  #                       label_x = 0, label_y = .75,
  #                       hjust = -0.5
  #     )
  #     
  #     gleg = get_legend(p[[3]] +
  #                         guides(color = guide_legend(nrow = 1)) +
  #                         theme(legend.position = "bottom", 
  #                               legend.key.size = unit(.2, "cm"))
  #     )
  #     
  #     gall = gplot + draw_grob(gleg, x = 0, y = 0, width = 1, height = .5, scale = .5)
  #     
  #     g <- girafe(ggobj = gall, 
  #                      options = list(opts_hover(css = "stroke:gray;r:20pt;"),
  #                                     opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
  #                      )
  #     )
  #     
  #     
  
      
      
```




Location specific total output vector specified by annual industry payroll is adjusted for labor share quotient.

Note: matching made by the maximum of within *minimum* as such large outliers do not necessarily hold sway over connectedness.     

Note: maps or even metrics do not show what is. We do have  have actual inter-industry to expense reports. But better yet we show where the greatest opportunities lie. That is, we are able to provide a product to entrepreneurs and local small business in rural place and across all industry types,where  and  how far is their greatest opportunity to serve an in demand product to a needs market.



Consider Audubon IA, a small rural county with a total population of 5,635 in the west central part of the state. 38% of its excess production matches with Dallas County, which is part of West Des Moines and is the fastest growing county in Iowa and one of the fastest growing in the country. 

Most of the strength of this interconnectedness is driven by:

550000 (Management of Companies and Enterprises), 

811100 (Automotive Mechanical and Electrical Repair and Maintenance),  

and 811300 (Commercial and Industrial Machinery and Equipment (except Automotive and Electronic) Repair and Maintenance).

```{r}
#print(ggtop[[3]]$`19009`)
girafe(ggobj =ggtop[[3]]$`19009`,
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;")
                       ))

```



Consider Adair County IA, a small rural county with a total population of 7,496 in the south-west of the state. *A priori* one might assume based on geographical distance alone that Adair is best connected with either Des Moines or Omaha. However, 20% of its excess production matches with Buena Vista County, where the Tyson meat and poultry processing plant happens to be located. 

Their interconnectedness is driven by absorption of:  
484000 (Truck Transportation), 

811300 (Commercial and Industrial Machinery and Equipment (except Automotive and Electronic) Repair and Maintenance), 

and 541940 (Veterinary Services).

```{r}
#print(ggtop[[3]]$`19001`)
girafe(ggobj =ggtop[[3]]$`19001`,
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;")
                       ))

```

On the other hand, consider the rural Clayton County with a population of 16,998 in the North-east of the state. *A priori* one might assume based on geographical distance alone that Clayton is best connected with either Dubuque or Waterloo. However, Clayton County is economically isolated, with at most only 2% of its excess production matching with Black Hawk County (Waterloo).


```{r}
#print(ggtop[[3]]$`19043`)
girafe(ggobj =ggtop[[3]]$`19043`,
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;")
                       ))

```


**Maps of Natural Matching: no *ex ante* core matching restrictions or county clustering**

All counties can match to all counties, and no clusters (e.g., MSAs) are prespecified.

If maximum "connectedness" is below 5% a county is isolated. 

If a county is matched with another because it has the maximum relative absorption of all possible net input shortage counties, then it is a cluster core. 
  
Matching is done using "Spatial Relative Queeg distance": $\arg \max_{l} \{(\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}/\mathbf{i'}\text{NIE}^{r}) * Q^{rs}\}~ \forall ~ r,s \in l$. However, the impedance factor in this example $Q^{rs}$ is only a very mild spatial tax, used principally for making assignments between counties withotherwise tied maximum absorption values. 

```{r}
girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )
```
This map shows that even with no prior specification of which counties are cores and which are not, and treating all counties as isolated (i.e., not accounting for multicounty cores), our connectedness metric identifies most of the places one would expect as being cores: MSAs. That is errors of omission and commission are low despite the overly naive specification.








**Maps of Natural Matching, with Metro and Micro core aggregate clusters, but no core matching restrictions**


```{r, warning=FALSE}

#Produce new clustered total output matrix from matched cores


#All metro and micro clusters
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)

#All metro and micro core county representative
shoname <- sapply(ext, function(x) x[1])

#All non-metro, non-micro counties
macc <- grep("^19", rownames(TIGER_RUCC), value=TRUE) %>% setdiff(., metro) %>% setdiff(., micro)

#All metro and micro that are not the representative core county
singcc <- setdiff(union(micro, metro), setdiff(unlist(ext), shoname)) 



trimr(specname=Output_mat_H1, macc=macc, singcc=singcc, ext=ext, industry_levels=industry_levels, o_mat=Output_mat)

```


```{r}
###First level calc

############ Input Needs
Input_Needs(specname=Input_mat_H1, o_mat=Output_mat_H1, industry_levels=industry_levels)

############ Import Input Needs
Import_Needs(specname=Input_mat_imp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Net Exports
Export_Needs(specname=Input_mat_exp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Relative Queeg specification
Rel_Queeg(specname=Queeg_rel_H1, o_mat=Output_mat_H1, im_mat=Input_mat_imp_H1, ex_mat=Input_mat_exp_H1, industry_levels=industry_levels)

```



```{r }
#Produce new clustered total output matrix from matched cores

###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#geographical impedance (used here for breaking ties)
imp_mat <- Impede_mat[[4]]

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=Impede_mat[[4]], macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=0.05)
```


```{r, warning=FALSE}

####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- .05
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  #ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=Impede_mat[[4]]) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = h1m[[3]]$lab
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)
 

####Mapping Economic and Spatial cluster matching with isolation
  mapr2(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
      
```



All counties/clusters can match to all counties/clusters.

If "connectedness" is below 5% a county is isolated. 

```{r}
girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )
```


This map shows how clustering causes more absorption from the larger with-in cluster economies. 




**Maps of Restricted Core Matching to all Metro and Micro Stat Areas, with Metro and Micro core aggregation**


```{r, warning=FALSE}

#Produce new clustered total output matrix from matched cores


#All metro and micro clusters
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)

#All metro and micro core county representative
shoname <- sapply(ext, function(x) x[1])

#All non-metro, non-micro counties
macc <- grep("^19", rownames(TIGER_RUCC), value=TRUE) %>% setdiff(., metro) %>% setdiff(., micro)

#All metro and micro that are not the representative core county
singcc <- setdiff(union(micro, metro), setdiff(unlist(ext), shoname)) 


trimr(specname=Output_mat_H1, macc=macc, singcc=singcc, ext=ext, industry_levels=industry_levels, o_mat=Output_mat)

```


```{r}
###First level calc

############ Input Needs
Input_Needs(specname=Input_mat_H1, o_mat=Output_mat_H1, industry_levels=industry_levels)

############ Import Input Needs
Import_Needs(specname=Input_mat_imp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Net Exports
Export_Needs(specname=Input_mat_exp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Relative Queeg specification
Rel_Queeg(specname=Queeg_rel_H1, o_mat=Output_mat_H1, im_mat=Input_mat_imp_H1, ex_mat=Input_mat_exp_H1, industry_levels=industry_levels)

```



```{r}
#Produce new clustered total output matrix from matched cores

###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#geographical impedance (used here for breaking ties)
imp_mat <- Impede_mat[[4]]

#exporting "row" counties
macc <- grep("^19", rownames(TIGER_RUCC), value=TRUE) %>% setdiff(., metro) %>% setdiff(., micro)

#importing "column" counties
singcc <- union(setdiff(union(micro, metro), unlist(ext)), shoname) 

#total industry output by county matrix
out_mat <- Output_mat_H1

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=Impede_mat[[4]], macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=0.05)
```


```{r, warning=FALSE}

####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust <- vector(mode='list', length=length(industry_levels))
  names(spec_clust) <- industry_levels

    for (l in 1:length(industry_levels)){
      spec_clust[[l]] = data.frame(matrix(nrow = 1, ncol = length(union(colnames(th_iso[[l]]), union(setdiff(union(micro, metro), unlist(ext)), shoname)) )))
      colnames(spec_clust[[l]] ) <- union(colnames(th_iso[[l]]), union(setdiff(union(micro, metro), unlist(ext)), shoname)) 
    }

  qdf <- Queeg_rel_H1
  isolation_th <- .05
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  
  



hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=Impede_mat[[4]]) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = h1m[[3]]$lab
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)
 

####Mapping Economic and Spatial cluster matching with isolation
  mapr2(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
      
```



All counties/clusters can match to only CBSAs.

If "connectedness" is below 5% a county is isolated. 

```{r}
girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )
```








**Maps of Restricted Core Matching to only Metro Stat Areas, with Metro and Micro core aggregation**


```{r, warning=FALSE}

#Produce new clustered total output matrix from matched cores


#All metro and micro clusters
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)

#All metro and micro core county representative
shoname <- sapply(ext, function(x) x[1])

#All non-metro, non-micro counties
macc <- grep("^19", rownames(TIGER_RUCC), value=TRUE) %>% setdiff(., metro) %>% setdiff(., micro)

#All metro and micro that are not the representative core county
singcc <- setdiff(union(micro, metro), setdiff(unlist(ext), shoname)) 


trimr(specname=Output_mat_H1, macc=macc, singcc=singcc, ext=ext, industry_levels=industry_levels, o_mat=Output_mat)

```


```{r}
###First level calc

############ Input Needs
Input_Needs(specname=Input_mat_H1, o_mat=Output_mat_H1, industry_levels=industry_levels)

############ Import Input Needs
Import_Needs(specname=Input_mat_imp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Net Exports
Export_Needs(specname=Input_mat_exp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Relative Queeg specification
Rel_Queeg(specname=Queeg_rel_H1, o_mat=Output_mat_H1, im_mat=Input_mat_imp_H1, ex_mat=Input_mat_exp_H1, industry_levels=industry_levels)

```



```{r }
#Produce new clustered total output matrix from matched cores

###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#geographical impedance (used here for breaking ties)
imp_mat <- Impede_mat[[4]]

#exporting "row" counties
macc <- grep("^19", rownames(TIGER_RUCC), value=TRUE) %>% setdiff(., metro) %>% setdiff(.,intersect(setdiff(unlist(ext), shoname), micro))

#importing "column" counties
singcc <- union(setdiff(metro, unlist(ext)), intersect(shoname, metro)) 

#total industry output by county matrix
out_mat <- Output_mat_H1

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=Impede_mat[[4]], macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=0.05)
```


```{r, warning=FALSE}

####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  #spec_clust  <- union(setdiff(metro, unlist(ext)), intersect(shoname, metro)) 

  spec_clust <- vector(mode='list', length=length(industry_levels))
  names(spec_clust) <- industry_levels

    for (l in 1:length(industry_levels)){
      spec_clust[[l]] = data.frame(matrix(nrow = 1, ncol = length(union(colnames(th_iso[[l]]), union(setdiff(metro, unlist(ext)), shoname)) )))
      colnames(spec_clust[[l]] ) <- union(colnames(th_iso[[l]]), union(setdiff(metro, unlist(ext)), shoname)) 
    }

  qdf <- Queeg_rel_H1
  isolation_th <- .05
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  #ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=Impede_mat[[4]]) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = h1m[[3]]$lab
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)
 

####Mapping Economic and Spatial cluster matching with isolation
  mapr2(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
      
```



All counties/clusters can match only to Metro Stat Areas.

If "connectedness" is below 5% a county is isolated. 

```{r}
girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )
```
















### Hierarchical



```{r, warning=FALSE}

#Produce new clustered total output matrix from matched cores


#All metro and micro clusters
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)

#All metro and micro core county representative
shoname <- sapply(ext, function(x) x[1])

#All non-metro, non-micro counties
macc <- grep("^19", rownames(TIGER_RUCC), value=TRUE) %>% setdiff(., metro) %>% setdiff(., micro)

#All metro and micro that are   (not) the representative core county
singcc <- setdiff(union(micro, metro), setdiff(unlist(ext), shoname)) 



trimr(specname=Output_mat_H1, macc=macc, singcc=singcc, ext=ext, industry_levels=industry_levels, o_mat=Output_mat)

```


```{r}
###First level calc

############ Input Needs
Input_Needs(specname=Input_mat_H1, o_mat=Output_mat_H1, industry_levels=industry_levels)

############ Import Input Needs
Import_Needs(specname=Input_mat_imp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Net Exports
Export_Needs(specname=Input_mat_exp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Relative Queeg specification
Rel_Queeg(specname=Queeg_rel_H1, o_mat=Output_mat_H1, im_mat=Input_mat_imp_H1, ex_mat=Input_mat_exp_H1, industry_levels=industry_levels)

```



```{r}
#Produce new clustered total output matrix from matched cores

###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#geographical impedance (used here for breaking ties)
imp_mat <- Impede_mat[[4]]

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=Impede_mat[[4]], macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=0.05)



```



```{r, warning=FALSE}

####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- .05
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  #ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=Impede_mat[[4]]) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = h1m[[3]]$lab
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)
 

####Mapping Economic and Spatial cluster matching with isolation
  mapr2(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
       
```


**Level 1 Natural Matching**

All counties/clusters can match to all counties/clusters.

If "connectedness" is below 5% a county is isolated. 

```{r}

#####Mapping Natural Matches
girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )
```




**Level 1 ECA's**

```{r}

####Mapping ECAs
 placenames = h1m[[3]]$eca
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)
 
    maprECA(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)

girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )
```




```{r}




###All previously isolated counties
macc <- h1m[[3]]$place[h1m[[3]]$eca == "Isolated"]


###All new ECA clusters
tdf <-  data.frame(place = c(h1m[[3]]$place[h1m[[3]]$NAME %in% (setdiff(unique(h1m[[3]]$eca) , "Isolated"))]), 
                   NAME = c(h1m[[3]]$NAME[h1m[[3]]$NAME %in% (setdiff(unique(h1m[[3]]$eca) , "Isolated"))]))
  
  
#Each new core cluster
df <- vector(mode='list', length=length(setdiff(unique(h1m[[3]]$eca) , "Isolated")))
  names(df) <- h1m[[3]]$NAME[h1m[[3]]$NAME %in% (setdiff(unique(h1m[[3]]$eca) , "Isolated"))]
  
for(i in 1:length(df)){
  df[[i]] <- c(tdf[i,1])
}

for(i in 1:length(df)){
  df[[i]] <- c(df[[i]],  setdiff(h1m[[3]]$place[h1m[[3]]$eca %in% names(df[i])], df[[i]]))
}
  

ext <- df
#shoname <- sapply(df, function(x) x[1])
singcc <- sapply(ext, function(x) x[1])


trimr(specname=Output_mat_H3, macc=macc, singcc=singcc, ext=ext, industry_levels=industry_levels, o_mat=Output_mat_H2)



```





```{r}
###First level calc

############ Input Needs
Input_Needs(specname=Input_mat_H2, o_mat=Output_mat_H3, industry_levels=industry_levels)

############ Import Input Needs
Import_Needs(specname=Input_mat_imp_H2, o_mat=Output_mat_H3, i_mat=Input_mat_H2,  industry_levels=industry_levels)

############ Net Exports
Export_Needs(specname=Input_mat_exp_H2, o_mat=Output_mat_H3, i_mat=Input_mat_H2,  industry_levels=industry_levels)

############ Relative Queeg specification
Rel_Queeg(specname=Queeg_rel_H2, o_mat=Output_mat_H3, im_mat=Input_mat_imp_H2, ex_mat=Input_mat_exp_H2, industry_levels=industry_levels)

```



```{r }
#Produce new clustered total output matrix from matched cores

###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H2

#geographical impedance (used here for breaking ties)
imp_mat <- Impede_mat[[4]]

#exporting "row" counties
macc <- colnames(Queeg_rel_H2[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H2[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

Queeg_selectr(specname=Output_mat_H4, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H2, imp_mat=Impede_mat[[4]], macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H3, isolation_th=0.05)
```



```{r, warning=FALSE}

####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H2
  isolation_th <- .05
  
  
  macc <- h1m[[3]]$place[h1m[[3]]$eca == "Isolated"]
  
  #All metro and micro clusters
  df <- list("Cerro Gordo" = Masoncity,
              "Des Moines" = Burlington,
              "Lee"  = Keokuk,
              "Polk" = Desmoines,
              "Story" = Ames,
              "Woodbury" = Siouxcity,
              "Pottawattamie" = Omaha,
              "Black Hawk" = Wateloo,
              "Linn" = Cedarrrapids,
              "Johnson" = Iowacity,
              "Scott" = Davenport)
  
  
  
  
  #############BAD Brute FORCE
  
  n <- df[setdiff(names(df), names(ext))][sapply(df[setdiff(names(df), names(ext))], function(x) x[1]) %in% unlist(ext)]
  
      # #vis
      # for(i in 1:length(ext)){
      #      print(unlist(ext[i]) %in% unlist(n))
      # }
  
          test <- c()
        for (i in 1:length(ext)){
          test[i] <- any(unlist(ext[i]) %in% unlist(n))
        }
          
          # #vis
          # ext[names(ext[test])]
          # 
        
            ext$Johnson <- union(unlist(ext$Johnson), unlist(n$`Des Moines`))  
            ext$Johnson <- union(unlist(ext$Johnson), unlist(n$Woodbury))  
            ext$Pottawattamie <- union(unlist(ext$Pottawattamie), unlist(n$Lee))  
  
                  ##All old clusters overlap with newly clusted CSAs
                  
                    # t <- vector(mode='list', length=length(setdiff(names(df), names(ext))) )
                    #     names(t) <- setdiff(names(df), names(ext))
                    # for (i in 1:length(t) ) {
                    #    t[[i]] <- union(unlist(ext[intersect(names(df), names(ext))][i]), 
                    #                    unlist(df[intersect(names(df), names(ext))][i]))
                    #    names(t[i]) <- df[i]
                    # }
                        
    ###############  
  
  
  
  ##All overlapping new clusters and old 
  t <- vector(mode='list', length=length(intersect(names(df), names(ext))) )
  names(t) <- intersect(names(df), names(ext))
  
  for (i in 1:length(t) ) {
       t[[i]] <- union(unlist(ext[intersect(names(df), names(ext))][i]), 
                       unlist(df[intersect(names(df), names(ext))][i]))
       names(t[i]) <- df[i]
    }

  ##All new clusters that are not old clusters
  k <- ext[setdiff(names(ext) , names(df))]
  
  ##All new clusters that do and do not overlap with old clusters 
  m <- c(t , k)
  
  ##All clusters
  exta <- m
  
  
  
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=exta, isolation_th=isolation_th, imp_mat=Impede_mat[[4]]) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = h1m[[3]]$lab
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)
 

####Mapping Economic and Spatial cluster matching with isolation
  mapr2(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
       
```



**Level 2 Natural Matching**

If "connectedness" is below 5% a county is isolated. 

```{r}
girafe(ggobj = p[[3]],
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;")
                       )
      )
```





**Level 2 ECA's**

```{r}

####Mapping ECAs
 placenames = h1m[[3]]$eca
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)
 
    maprECA(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)

girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )
```





### ALT










### NOTES

Note: Corner Cases.
Story county has a maximum total absorption with Johnson along with 15 other counties 
Allamakee has a maximum total absorption with Story and so would be matched to Story,making Story a cluster core.  However, 

5 Counties that are the only match  for that county
Allamakee to Story
BuenaVista to Scott
 Carrol  to  Linn
 Hardin to Dubuque
Johnson to Woodburry

Of these 5 there are 3 (BuenaVista, Carrol, Johnson) which have other counties that match to them making them cluster cores and meaning that they CANNOT match to another county. 
And 2 (Allamakee, Hardin) which do not have other exporting counties which they import from. 

Johnson only has a very weak absorption with Woodburry, below the isolation threshold, thus also making Woodbury a cluster core without any matches.
In addition, since BuenaVista, Carrol, and Johnson are themselves cluster cores, Scott, Linn and Woodburry are also cluster cores without any matches.

 





In this 2-stage analysis, the counties of Iowa are first matched internally. 
Metro counties in areas with a population of under a 1 million serve as first-order cores which all other counties are matched based on their capacitance.  


Note: this matching asks the question: Where is the greatest industry development opportunity for all rural counties among the Iowa Micropolitan Statistical Areas group of places, ignoring all other market opportunities in and out of state?

Next we ask: Where is the greatest industry development opportunity for all rural counties and Iowa Micropolitan Statistical Areas among the Iowa Metropolitan Statistical Areas group of places, ignoring all other market opportunities out of state? 



```{r}

#Produce new clustered total output matrix from matched cores

# for (l in 1:length(industry_levels)){  
#   Output_mat_H4[[l]] <- cbind(Output_mat_H4[[l]], Output_mat_H3[[l]][,setdiff(colnames(Output_mat_H3[[l]]), colnames(Output_mat_H4[[l]]))])
# }

```










FIN
::: 
















