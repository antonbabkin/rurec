---
title: "Maps and IO Similarity Index: Iowa"
author: "Austin Sandler"
date: "2022-09-03"
format:
  html:
    self-contained: true
    page-layout: full
    code-fold: true
    code-tools: true
    code_download: yes
    latex_engine: pdflatex
---


```{r preamble, include = FALSE}
# When you click the **Render** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document.
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 

#For nonscientific notation
options(scipen=999)

```


```{r packages and libraries, include = FALSE}
# Load and attach necessary packages
library(rprojroot)
library(tidyr)
library(Matrix)
library(dplyr)
library(reshape2)
library(ggplot2)
library(ggiraph)
library(glue)
library(magrittr)
library(ggforce)
library(cowplot)
library(tibble)
library(sf)
library(ggpattern)


# library(dash)
# library(dlm)
# library(DT)
# library(gtools)
# library(knitr)
# library(plotly)
# library(scales)
# library(tools)

#Load custom functions
#source(file.path(find_rstudio_root_file(), "nbs", "rural_typology_r_data_generation.R"))
source(file.path(find_rstudio_root_file(), "nbs", "rural_typology_r_functions.R"))



```

```{r load data, include=FALSE}
# Load previously generated datafiles
importr(TIGER_RUCC)
#importr(Queego)
#importr(Queeg_relo)
importr(Output_mat)
importr(Impede_mat)
#importr(Input_mat_exp)
#importr(Input_mat_imp)
#importr(Input_mat_expo)
#importr(Input_mat_impo)
importr(Direct_mat)

# importr(Total_mat)
# importr(Xpay_mat)
importr(D_mat)

industry_levels  <-  c("Sector", "Summary", "Detail")

# Queeg_listo <- list(Queego, Queeg_relo)
# names(Queeg_listo) <- c("Queego",  "Queeg_relo")

data_dir = file.path(find_rstudio_root_file(), "data", "robjs")

```


This document attempts to map the various topological similarity index relationships for Iowa counties.

::: {.panel-tabset}


### Methods

I-O analysis, or inter-industry analysis, is an economic tool that measures the relationships between industries in the economy. The framework measures flows of products from each of the sectors (as a producer/seller) to each of the sectors (as a purchaser/buyer); these interindustry flows, or transactions are measured for a particular time period and in monetary terms.  

We categorize the economy into $n$ sectors and let $x_{i}$ denote the total output of sector $i$. We denote $f_{i}$ as *final demand*, which represents all sales that are *exogenous* to the industrial sectors (e.g., households, government, and foreign trade). Taken together, we specify sector  $i$'s *output* with an accounting  identity $x_{i} = \sum^{n}_{j=1}z_{ij} + f_{i}$ that describes the way in which sector $i$ distributes its product to other sectors and to final demand, here the $z_{ij}$ terms represent *interindustry* sales by sector $i$ to all $j$ sectors in $n$. 

Let the *total output* of all sectors be summarized by: 
$$\mathbf{x} = \mathbf{Zi} + \mathbf{f}$$
where $\mathbf{i}$ represent a column vector of 1â€™s. 

We define the *input coefficient*, $a_{ij} = z_{ij}/x_{j}$ to be the quantity of the output of sector $i$ absorbed by sector $j$ per unit of its total output. This ratio is also known as the *technical coefficient*; the *inputâ€“output coefficient*;  or the *direct input coefficient*, specifies the required amount of industry $i$â€™s commodity used to produce of one unit of industry $j$â€™s commodity. 

Let the $n \times n$ *technical coefficient matrix* by summarized by:  
$$\mathbf{A} = \mathbf{Z\hat{x}^{-1}}$$
where the â€œhatâ€ over a vector denotes a diagonal matrix. Therefore, given a set of fixed technical coefficients, $\mathbf{x} = \mathbf{Ax} + \mathbf{f}$ denotes the accounting equation for the distribution of total output to all sectors and final demand. Note the inherent production functions of this system are isoquant â€œcurvesâ€ that exhibit constant output. Such *Leontief* production functions require inputs in fixed proportions, where a fixed amount of each input is required to produce one unit of output.  

If $(\mathbf{I} - \mathbf{A})$ is non-singular, where $\mathbf{I}$ is the identity matrix, then rearranging gives, $\mathbf{x} = \left(\mathbf{I} - \mathbf{A}\right)^{-1}\mathbf{f}$. Let the *Leontief* inverse or the *total requirements matrix* be given by:
$$\mathbf{L} = \left(\mathbf{I} - \mathbf{A}\right)^{-1}$$ 
Finally, in much the same way that subscript $i$ denotes an industry sector, we let superscript $r$ designate subnational geographies. Thus, $\mathbf{x^{r}}$ denotes the vector of gross output of all industries  in region $r$.


In  practice, we derive a national-level, industry-by-industry direct requirements matrix, $\mathbf{A}$ from the national-level, industry-by-industry total requirements matrix, $\mathbf{L}$ available from the U.S. Bureau of Economic Analysis (BEA) at three levels of industry specificity  (i.e.,  Sector,  Summary, and Detail). We construct the location specific total output vector, ð±rfrom a payroll and labor share quotient using  Census Bureau County Business Patterns  (CBP) or FSRDC depending on the desired spatial scale. With these two inputs we construct location specific metrics of industry input needs.

**Location specific metrics of industry inputs**

First, we specify the place specific *input needs vector* as: 
$$\mathbf{Ax^{r}}$$
In addition, we define the *net import shortage vector* as: 
$$\text{NIS}^{r} = \max \{\mathbf{Ax^{r}} - \mathbf{x^{r}}, 0\}$$ 

Similarly, we define the *net input excess vector* as: 
$$\text{NIE}^{r} = \max \{\mathbf{x^{r} - \mathbf{Ax^{r}}}, 0\}$$

**Cross location industry compatibility**

To elucidate the industrial compatibility across locations, we construct a *similarity index*. In general, it is defined on the metric space $(\mathfrak{X}, \mathfrak{D})$ where $\mathfrak{X}$ is a set of vectors $\{\mathbf{x}_{i} \in \mathbb{R} : i \in \{1, \dots, n \}\}$ and $\mathfrak{D}:\mathfrak{X} \times \mathfrak{X}	\rightarrow \mathbb{R}$ is a distance function.  

We first define an *absorption* vector between exporting location $r$ and importing location $s$ as: 
$$\min\{\text{NIE}^{r}, \text{NIS}^{s} \}$$

Finally, to match geographies through their supply chain capacitance we specify the novel *Queeg* distance as: 
$$\arg \max_{l} \{\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}\}~ \forall ~ r,s \in l$$ 

Places with net input excesses will have capacity to export their commodities to places with net shortage capacity. The pair of geographies with the largest overall economic capacity overlap are matched together. In practice $s$ places enter as pre-specified non-rural cores and all other rural places $r$ are matched to them. 

To restrict the capacitance magnitudes we specify the *Relative Queeg* distance as: 
$$\arg \max_{l} \{\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}/\mathbf{i'}\text{NIE}^{r}\}~ \forall ~ r,s \in l$$
Note: Contrary to the other similarity indices the *Queeg* measure is not a "distance" where the $\arg \min$ matches two places. But rather the *Queeg* specification is a congruence or compatibility metric where the $\arg \max$  matches two places.

**Spatial considerations**

In addition, we weight the economic capacitance metric by a *geographical impedance function*, $\mathbf{Q}$.  For example, in practice the geographical impedance between locations $r$ and $s$ may be defined as: the Inverse Square Function $Q^{rs} = 1/(d^{rs})^2$, the Exponential Decay Function $Q^{rs} = e^{-d^{rs}}$, or the Hyperbolic Secant Function $Q^{rs} = 2 / (e^{-d^{rs}} +e^{d^{rs}})$, where $d^{rs}$ is the great-circle distance between the two locations. Specifically, 
$d^{rs}  = R \cdot \arccos(\sin(\phi_{r})\sin(\phi_{s}) + \cos(\phi_{r})\cos(\phi_{s})\cos(\vert \lambda_{r} - \lambda_{s} \vert))$, where $\lambda_{r}, \phi_{r}$ and $\lambda_{s}, \phi_{r}$ are the longitude and latitude of locations $r$ and $s$, and $R$ is the radius of the reference sphere, which in this case is the *mean earth radius* from the WGS84 ellipsoid. 


Let the novel *Spatial Queeg* distance between exporting locations $r$ and importing location $s$ be given by:
$$\arg \max_{l} \{(\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}) * Q^{rs} \}~ \forall ~ r,s \in l$$ 
And similarly, let the *Spatial Relative Queeg* distance be given by: 
$$\arg \max_{l} \{(\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}/\mathbf{i'}\text{NIE}^{r}) * Q^{rs}  \}~ \forall ~ r,s \in l$$
Alternative specifications of the spatial distance are possible. One possibility is to discretize the impedance matrix as a binary proximity operator which is one when two locations share a boundary (or vertex) and zero otherwise.  





### Natural Matching


```{r}
#Specify regional extent and possible (MSA) clusters

metro <- c("19193", 
           "19085",
           "19155",
           "19129",
           "19121",
           "19181",
           "19077",
           "19049",
           "19153",
           "19099",
           "19015",
           "19169",
           "19017",
           "19075",
           "19013",
           "19061",
           "19011",
           "19113",
           "19105",
           "19103",
           "19183",
           "19163")

micro <- c("19059", 
           "19041",
           "19021",
           "19027",
           "19187",
           "19195",
           "19033",
           "19127",
           "19125",
           "19123",
           "19179",
           "19101",
           "19045",
           "19139",
           "19057",
           "19111")


Desmoines <- c("19153",
               "19121",
               "19181",
               "19077",
               "19049",
               "19099")

Ames <- c("19169",
          "19015")

Siouxcity <- c("19193",
               "46127",
               "31043",
               "31051")

Omaha  <- c("19155",
            "19085",
            "19129",
            "31177",
            "31055",
            "31153",
            "31025",
            "31155")

Wateloo <- c("19013",
             "19017",
             "19075")

Cedarrrapids <- c("19113",
                  "19011",
                  "19105")

Iowacity <-  c("19103",
               "19183")

Davenport <- c("19163",
               "17161",
               "17073",
               "17131")

Masoncity <- c("19033",
               "19195")

Burlington <- c("19057",
                "17071")

Keokuk  <- c("19111",
             "17067",
             "29045")

```


```{r}
cbsa  <-  data.frame("CBSA" = c("Des Moines-West Des Moines, IA MSA",
"Newton, IA Î¼SA",
"Pella, IA Î¼SA",
"Cedar Rapids, IA MSA",
"Davenport-Moline-Rock Island, IA-IL MSA",
"Waterloo-Cedar Falls, IA MSA",
"Iowa City, IA MSA",
"Omaha-Council Bluffs, NE-IA MSA",
"Ames, IA MSA",
"Sioux City, IA-NE-SD MSA",
"Dubuque, IA MSA",
"Muscatine, IA Î¼SA",
"Mason City, IA Î¼SA",
"Clinton, IA Î¼SA",
"Burlington, IA-IL Î¼SA",
"Marshalltown, IA Î¼SA",
"Fort Dodge, IA Î¼SA",
"Fort Madison-Keokuk, IA-MO Î¼SA",
"Ottumwa, IA Î¼SA",
"Oskaloosa, IA Î¼SA",
"Storm Lake, IA Î¼SA",
"Spirit Lake, IA Î¼SA",
"Spencer, IA Î¼SA",
"Carroll, IA Î¼SA"))

cbsa  <- data.frame(cbsa, "NAME"= c("Polk",
  "Jasper",
  "Marion",
  "Linn",
  "Scott",
  "Black Hawk",
  "Johnson",
  "Pottawattamie",
  "Story",
  "Woodbury",
  "Dubuque",
  "Muscatine",
  "Cerro Gordo",
  "Clinton",
  "Des Moines",
  "Marshall",
  "Webster",
  "Lee",
  "Wapello",
  "Mahaska",
  "Buena Vista",
  "Dickinson",
  "Clay",
  "Carroll"))

```



```{r}

isolation_th=.05


#Produce new clustered total output matrix from matched cores

macc <- grep("^19", rownames(TIGER_RUCC), value=TRUE)
singcc <- grep("^19", rownames(TIGER_RUCC), value=TRUE)
ext <- NA
industry_levels <-industry_levels

trimr(specname=Output_mat_H1, macc=macc, singcc=singcc, ext=NA, industry_levels=industry_levels, o_mat=Output_mat)

##View a counties output by industry
##View(Output_mat_H1[[3]][,"19001", drop = FALSE])

```


```{r}
###First level calc

############ Input Needs
Input_Needs(specname=Input_mat_H1, o_mat=Output_mat_H1, industry_levels=industry_levels)

############ Import Input Needs
Import_Needs(specname=Input_mat_imp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Net Exports
Export_Needs(specname=Input_mat_exp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Relative Queeg specification
Rel_Queeg(specname=Queeg_rel_H1, o_mat=Output_mat_H1, im_mat=Input_mat_imp_H1, ex_mat=Input_mat_exp_H1, industry_levels=industry_levels)

```



```{r}
#Produce new clustered total output matrix from matched cores

###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#geographical impedance (used here for breaking ties)
imp_mat <- Impede_mat[[4]]

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th


Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, th_iso=th_iso, nomatch_core_out=nomatch_core_out, queeg_mat=Queeg_rel_H1, imp_mat=imp_mat, macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=isolation_th)

```


```{r}
##Top absorption overlaps by core for each non-core
im_mat=Input_mat_imp_H1
ex_mat=Input_mat_exp_H1
#impind <- colnames(CoreMatch[[l]])
impind <- c("19193", "19153", "19111")
macc <- grep("^19", rownames(TIGER_RUCC), value=TRUE)

absorbr(top_absorb=top_absorb, all_absorb=all_absorb, in_core=in_core, im_mat=Input_mat_imp_H1, ex_mat=Input_mat_exp_H1, impind=impind, macc=macc, industry_levels=industry_levels)



###Custom Graph colors for import county bubbles
  values = c("#ffffb3",  "#fccde5",  "#80b1d3")
  #values = c("#e31a1c",  "#1f78b4",  "#33a02c", "#ff7f00", "#6a3d9a", "#ffff99",  "#b15928", "#fb9a99",  "#b2df8a", "#fdbf6f",  "#cab2d6", "#a6cee3",  "#1b9e77",  "#d95f02",  "#7570b3",  "#e7298a", "#66a61e", "#e6ab02", "#8dd3c7", "#ffffb3",  "#bebada", "#fb8072", "#80b1d3")
   my_pal_graph <- c()
      for(m in 1:length(unique(union(in_core[[1]]$core_fips, union(in_core[[2]]$core_fips, in_core[[3]]$core_fips))))){
        my_pal_graph[m] =  values[m]
      }
  names(my_pal_graph) <- sort(unique(union(in_core[[1]]$core_fips, union(in_core[[2]]$core_fips, in_core[[3]]$core_fips))))


  
 ###Graphs of import and export absorption
graphr(specname=ggtop, top_absorb=top_absorb, TIGER_RUCC=TIGER_RUCC, my_pal=my_pal_graph, macc=macc, industry_levels=industry_levels)




```



```{r, warning=FALSE}

####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- isolation_th
  # ext <- list(Masoncity = Masoncity,
  #             Burlington = Burlington,
  #             Keokuk  = Keokuk,
  #             Desmoines = Desmoines,
  #             Ames = Ames,
  #             Siouxcity = Siouxcity,
  #             Omaha = Omaha,
  #             Wateloo = Wateloo,
  #             Cedarrrapids = Cedarrrapids,
  #             Iowacity = Iowacity,
  #             Davenport = Davenport)
  #macc <- colnames(Queeg_rel_H1[[3]])
 ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=Impede_mat[[4]], cbsa=cbsa) 

#####Custom colors 
 values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
 placenames = h1m[[3]]$cnt_place
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)
 
#c("#e31a1c",  "#1f78b4",  "#33a02c", "#ff7f00", "#6a3d9a", "#ffff99",  "#b15928", "#fb9a99",  "#b2df8a", "#fdbf6f",  "#cab2d6", "#a6cee3",  "#1b9e77",  "#d95f02",  "#7570b3",  "#e7298a", "#66a61e", "#e6ab02", "#8dd3c7", "#ffffb3",  "#bebada", "#fb8072", "#80b1d3")

 #c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")

#c("#ffffb3",  "#fccde5",  "#80b1d3")

#c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")

my_pal_map  <- c("Black Hawk" = "#8dd3c7", 
                "Buena Vista" = "#fb8072", 
                "Dallas" = "#bebada", 
                "Lee" = "#ffffb3", 
                "Linn"  = "#b3de69",  
                "Polk" = "#fccde5", 
                "Pottawattamie" = "#fdb462", 
                "Sioux" = "#e5c494",
                "Woodbury" = "#80b1d3",
                "ECA Isolated" = "#A9A9A9",
                "Isolated" = "#000000")



####Mapping Economic and Spatial cluster matching with isolation
  
maprCNT(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
      



```


```{r, warning=FALSE}

  ### Maps for multiple industry  levels 
  # gplot = plot_grid(p[[1]] + theme(legend.position = 'none'), 
  #                   p[[2]] + theme(legend.position = 'none'), 
  #                   p[[3]] + theme(legend.position = 'none'),
  #                       labels = c("Sector", "Summary", "Detail"),
  #                       nrow = 1,
  #                       label_x = 0, label_y = .75,
  #                       hjust = -0.5
  #     )
  #     
  #     gleg = get_legend(p[[3]] +
  #                         guides(color = guide_legend(nrow = 1)) +
  #                         theme(legend.position = "bottom", 
  #                               legend.key.size = unit(.2, "cm"))
  #     )
  #     
  #     gall = gplot + draw_grob(gleg, x = 0, y = 0, width = 1, height = .5, scale = .5)
  #     
  #     g <- girafe(ggobj = gall, 
  #                      options = list(opts_hover(css = "stroke:gray;r:20pt;"),
  #                                     opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
  #                      )
  #     )
  #     
  #     
  
      
      
```




Location specific total output vector specified by annual industry payroll is adjusted for labor share quotient.

Note: matching made by the maximum of within *minimum* as such large outliers do not necessarily hold sway over connectedness.     

Note: maps or even metrics do not show what is. We do have  have actual inter-industry to expense reports. But better yet we show where the greatest opportunities lie. That is, we are able to provide a product to entrepreneurs and local small business in rural place and across all industry types,where  and  how far is their greatest opportunity to serve an in demand product to a needs market.





```{r}
#print(ggtop[[3]]$`19009`)
girafe(ggobj =ggtop[[3]]$`19161`,
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;")
                       ))

```




```{r}
#print(ggtop[[3]]$`19001`)
girafe(ggobj =ggtop[[3]]$`19061`,
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;")
                       ))

```

On the other hand, consider the rural Clayton County with a population of 16,998 in the North-east of the state. *A priori* one might assume based on geographical distance alone that Clayton is best connected with either Dubuque or Waterloo. However, Clayton County is economically isolated, with at most only 2% of its excess production matching with Black Hawk County (Waterloo).


```{r}
#print(ggtop[[3]]$`19043`)
girafe(ggobj =ggtop[[3]]$`19197`,
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;")
                       ))

```


**Maps of Natural Matching: no *ex ante* core matching restrictions or county clustering**

All counties can match to all counties, and no clusters (e.g., MSAs) are prespecified.


If a county is matched with another because it has the maximum relative absorption of all possible net input shortage counties, then it is a cluster core. 
  
Matching is done using "Spatial Relative Queeg distance": $\arg \max_{l} \{(\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}/\mathbf{i'}\text{NIE}^{r}) * Q^{rs}\}~ \forall ~ r,s \in l$. However, the impedance factor in this example $Q^{rs}$ is only a very mild spatial tax, used principally for making assignments between counties withotherwise tied maximum absorption values. 

```{r}
girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )
```
This map shows that even with no prior specification of which counties are cores and which are not, and treating all counties as isolated (i.e., not accounting for multicounty cores), our connectedness metric identifies most of the places one would expect as being cores: MSAs. That is errors of omission and commission are low despite the overly naive specification.








**Maps of Natural Matching, with Metro and Micro core aggregate clusters, but no core matching restrictions**


```{r, warning=FALSE}

#Produce new clustered total output matrix from matched cores


#All metro and micro clusters
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)

#All metro and micro core county representative
shoname <- sapply(ext, function(x) x[1])

#All non-metro, non-micro counties
macc <- grep("^19", rownames(TIGER_RUCC), value=TRUE) %>% setdiff(., metro) %>% setdiff(., micro)

#All metro and micro that are not the representative core county
singcc <- setdiff(union(micro, metro), setdiff(unlist(ext), shoname)) 



trimr(specname=Output_mat_H1, macc=macc, singcc=singcc, ext=ext, industry_levels=industry_levels, o_mat=Output_mat)

```


```{r}
###First level calc

############ Input Needs
Input_Needs(specname=Input_mat_H1, o_mat=Output_mat_H1, industry_levels=industry_levels)

############ Import Input Needs
Import_Needs(specname=Input_mat_imp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Net Exports
Export_Needs(specname=Input_mat_exp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Relative Queeg specification
Rel_Queeg(specname=Queeg_rel_H1, o_mat=Output_mat_H1, im_mat=Input_mat_imp_H1, ex_mat=Input_mat_exp_H1, industry_levels=industry_levels)

```



```{r }
#Produce new clustered total output matrix from matched cores

###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#geographical impedance (used here for breaking ties)
imp_mat <- Impede_mat[[4]]

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th




Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=Impede_mat[[4]], macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=isolation_th)


```


```{r, warning=FALSE}

####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- isolation_th
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  #ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=Impede_mat[[4]], cbsa=cbsa) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = h1m[[3]]$lab
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)
 

####Mapping Economic and Spatial cluster matching with isolation
  mapr2(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
      
```



All counties/clusters can match to all counties/clusters.


```{r}
# girafe(ggobj = p[[3]], 
#                        options = list(opts_hover(css = "stroke:gray;r:20pt;"),
#                                       opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
#                        )
#       )
```


This map shows how clustering causes more absorption from the larger with-in cluster economies. 




**Maps of Restricted Core Matching to all Metro and Micro Stat Areas, with Metro and Micro core aggregation**


```{r, warning=FALSE}

#Produce new clustered total output matrix from matched cores


#All metro and micro clusters
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)

#All metro and micro core county representative
shoname <- sapply(ext, function(x) x[1])

#All non-metro, non-micro counties
macc <- grep("^19", rownames(TIGER_RUCC), value=TRUE) %>% setdiff(., metro) %>% setdiff(., micro)

#All metro and micro that are not the representative core county
singcc <- setdiff(union(micro, metro), setdiff(unlist(ext), shoname)) 


trimr(specname=Output_mat_H1, macc=macc, singcc=singcc, ext=ext, industry_levels=industry_levels, o_mat=Output_mat)

```


```{r}
###First level calc

############ Input Needs
Input_Needs(specname=Input_mat_H1, o_mat=Output_mat_H1, industry_levels=industry_levels)

############ Import Input Needs
Import_Needs(specname=Input_mat_imp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Net Exports
Export_Needs(specname=Input_mat_exp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Relative Queeg specification
Rel_Queeg(specname=Queeg_rel_H1, o_mat=Output_mat_H1, im_mat=Input_mat_imp_H1, ex_mat=Input_mat_exp_H1, industry_levels=industry_levels)

```



```{r}
#Produce new clustered total output matrix from matched cores

###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#geographical impedance (used here for breaking ties)
imp_mat <- Impede_mat[[4]]

#exporting "row" counties
macc <- grep("^19", rownames(TIGER_RUCC), value=TRUE) %>% setdiff(., metro) %>% setdiff(., micro)

#importing "column" counties
singcc <- union(setdiff(union(micro, metro), unlist(ext)), shoname) 

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=Impede_mat[[4]], macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=isolation_th)
```


```{r, warning=FALSE}

####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust <- vector(mode='list', length=length(industry_levels))
  names(spec_clust) <- industry_levels

    for (l in 1:length(industry_levels)){
      spec_clust[[l]] = data.frame(matrix(nrow = 1, ncol = length(union(colnames(th_iso[[l]]), union(setdiff(union(micro, metro), unlist(ext)), shoname)) )))
      colnames(spec_clust[[l]] ) <- union(colnames(th_iso[[l]]), union(setdiff(union(micro, metro), unlist(ext)), shoname)) 
    }

  qdf <- Queeg_rel_H1
  isolation_th <- isolation_th
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  
  



hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=Impede_mat[[4]],  cbsa=cbsa) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = h1m[[3]]$lab
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)
 

####Mapping Economic and Spatial cluster matching with isolation
  mapr2(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
      
```



All counties/clusters can match to only CBSAs.



```{r}
# girafe(ggobj = p[[3]], 
#                        options = list(opts_hover(css = "stroke:gray;r:20pt;"),
#                                       opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
#                        )
#       )
```








**Maps of Restricted Core Matching to only Metro Stat Areas, with Metro and Micro core aggregation**


```{r, warning=FALSE}

#Produce new clustered total output matrix from matched cores


#All metro and micro clusters
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)

#All metro and micro core county representative
shoname <- sapply(ext, function(x) x[1])

#All non-metro, non-micro counties
macc <- grep("^19", rownames(TIGER_RUCC), value=TRUE) %>% setdiff(., metro) %>% setdiff(., micro)

#All metro and micro that are not the representative core county
singcc <- setdiff(union(micro, metro), setdiff(unlist(ext), shoname)) 


trimr(specname=Output_mat_H1, macc=macc, singcc=singcc, ext=ext, industry_levels=industry_levels, o_mat=Output_mat)

```


```{r}
###First level calc

############ Input Needs
Input_Needs(specname=Input_mat_H1, o_mat=Output_mat_H1, industry_levels=industry_levels)

############ Import Input Needs
Import_Needs(specname=Input_mat_imp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Net Exports
Export_Needs(specname=Input_mat_exp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Relative Queeg specification
Rel_Queeg(specname=Queeg_rel_H1, o_mat=Output_mat_H1, im_mat=Input_mat_imp_H1, ex_mat=Input_mat_exp_H1, industry_levels=industry_levels)

```



```{r }
#Produce new clustered total output matrix from matched cores

###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#geographical impedance (used here for breaking ties)
imp_mat <- Impede_mat[[4]]

#exporting "row" counties
macc <- grep("^19", rownames(TIGER_RUCC), value=TRUE) %>% setdiff(., metro) %>% setdiff(.,intersect(setdiff(unlist(ext), shoname), micro))

#importing "column" counties
singcc <- union(setdiff(metro, unlist(ext)), intersect(shoname, metro)) 

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=Impede_mat[[4]], macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=isolation_th)
```


```{r, warning=FALSE}

####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  #spec_clust  <- union(setdiff(metro, unlist(ext)), intersect(shoname, metro)) 

  spec_clust <- vector(mode='list', length=length(industry_levels))
  names(spec_clust) <- industry_levels

    for (l in 1:length(industry_levels)){
      spec_clust[[l]] = data.frame(matrix(nrow = 1, ncol = length(union(colnames(th_iso[[l]]), union(setdiff(metro, unlist(ext)), shoname)) )))
      colnames(spec_clust[[l]] ) <- union(colnames(th_iso[[l]]), union(setdiff(metro, unlist(ext)), shoname)) 
    }

  qdf <- Queeg_rel_H1
  isolation_th <- isolation_th
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  #ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=Impede_mat[[4]], cbsa=cbsa) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = h1m[[3]]$lab
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)
 

####Mapping Economic and Spatial cluster matching with isolation
  mapr2(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
      
```



All counties/clusters can match only to Metro Stat Areas.



```{r}
# girafe(ggobj = p[[3]], 
#                        options = list(opts_hover(css = "stroke:gray;r:20pt;"),
#                                       opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
#                        )
#       )
```








### Hierarchical

```{r, warning=FALSE}

isolation_th=.05


#Produce new clustered total output matrix from matched cores


#All metro and micro clusters
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)

#All metro and micro core county representative
shoname <- sapply(ext, function(x) x[1])

#All non-metro, non-micro counties
macc <- grep("^19", rownames(TIGER_RUCC), value=TRUE) %>% setdiff(., metro) %>% setdiff(., micro)

#All metro and micro that are the representative core county
singcc <- setdiff(union(micro, metro), setdiff(unlist(ext), shoname)) 


trimr(specname=Output_mat_H1, macc=macc, singcc=singcc, ext=ext, industry_levels=industry_levels, o_mat=Output_mat)

```


```{r}
###First level calc

############ Input Needs
Input_Needs(specname=Input_mat_H1, o_mat=Output_mat_H1, industry_levels=industry_levels)

############ Import Input Needs
Import_Needs(specname=Input_mat_imp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Net Exports
Export_Needs(specname=Input_mat_exp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Relative Queeg specification
Rel_Queeg(specname=Queeg_rel_H1, o_mat=Output_mat_H1, im_mat=Input_mat_imp_H1, ex_mat=Input_mat_exp_H1, industry_levels=industry_levels)

```



```{r}
#Produce new clustered total output matrix from matched cores

###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#geographical impedance (used here for breaking ties)
imp_mat <- Impede_mat[[4]]

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=Impede_mat[[4]], macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=isolation_th)



```



```{r, warning=FALSE}

####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- isolation_th
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  #ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=Impede_mat[[4]], cbsa=cbsa) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = (h1m[[3]]$lab)
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)


  my_pal_map  <- c("Cedar Rapids, IA MSA"  = "#b3de69",
                   "Des Moines-West Des Moines, IA MSA" = "#fccde5", 
                   "Fort Madison-Keokuk, IA-MO Î¼SA" = "#ffffb3",
                   "Iowa City, IA MSA" = "#ffd92f",
                  "Omaha-Council Bluffs, NE-IA MSA" = "#fdb462",
                  "Sioux" = "#e5c494",
                 "Sioux City, IA-NE-SD MSA" = "#80b1d3",
                  "Storm Lake, IA Î¼SA" = "#fb8072",
                 "Waterloo-Cedar Falls, IA MSA" = "#8dd3c7",
                  "ECA Isolated" = "#A9A9A9")
 

####Mapping Economic and Spatial cluster matching with isolation
  mapr2(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
  

  
  
```


**Level 1 Natural Matching**

All counties/clusters can match to all counties/clusters.



```{r}

#####Mapping Natural Matches
girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )
```




**Level 1 ECA's**

```{r}

####Mapping ECAs

  my_pal_map  <- c("Cedar Rapids, IA MSA"  = "#b3de69",
                   "Des Moines-West Des Moines, IA MSA" = "#fccde5", 
                   "Fort Madison-Keokuk, IA-MO Î¼SA" = "#ffffb3",
                   "Iowa City, IA MSA" = "#ffd92f",
                  "Omaha-Council Bluffs, NE-IA MSA" = "#fdb462",
                  "Sioux" = "#e5c494",
                 "Sioux City, IA-NE-SD MSA" = "#80b1d3",
                  "Storm Lake, IA Î¼SA" = "#fb8072",
                 "Waterloo-Cedar Falls, IA MSA" = "#8dd3c7")


    maprECA(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)

girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )
```






```{r}


###All previously isolated counties
macc <- h1m[[3]]$place[h1m[[3]]$h2eca == "Isolated"]


###All new ECA clusters
tdf <-  data.frame(place = c(h1m[[3]]$place[h1m[[3]]$NAME %in% (setdiff(unique(h1m[[3]]$h2eca) , "Isolated"))]),
                   NAME = c(h1m[[3]]$NAME[h1m[[3]]$NAME %in% (setdiff(unique(h1m[[3]]$h2eca) , "Isolated"))]))


#Each new core cluster
df <- vector(mode='list', length=length(setdiff(unique(h1m[[3]]$h2eca) , "Isolated")))
  names(df) <- h1m[[3]]$NAME[h1m[[3]]$NAME %in% (setdiff(unique(h1m[[3]]$h2eca) , "Isolated"))]

for(i in 1:length(df)){
  df[[i]] <- c(tdf[i,1])
}

for(i in 1:length(df)){
  df[[i]] <- c(df[[i]],  setdiff(h1m[[3]]$place[h1m[[3]]$h2eca %in% names(df[i])], df[[i]]))
}


ext <- df
#shoname <- sapply(df, function(x) x[1])
singcc <- sapply(ext, function(x) x[1])


trimr(specname=Output_mat_H3, macc=macc, singcc=singcc, ext=ext, industry_levels=industry_levels, o_mat=Output_mat_H2)



```





```{r}
###First level calc
# 
# ############ Input Needs
# Input_Needs(specname=Input_mat_H2, o_mat=Output_mat_H3, industry_levels=industry_levels)
# 
# ############ Import Input Needs
# Import_Needs(specname=Input_mat_imp_H2, o_mat=Output_mat_H3, i_mat=Input_mat_H2,  industry_levels=industry_levels)
# 
# ############ Net Exports
# Export_Needs(specname=Input_mat_exp_H2, o_mat=Output_mat_H3, i_mat=Input_mat_H2,  industry_levels=industry_levels)
# 
# ############ Relative Queeg specification
# Rel_Queeg(specname=Queeg_rel_H2, o_mat=Output_mat_H3, im_mat=Input_mat_imp_H2, ex_mat=Input_mat_exp_H2, industry_levels=industry_levels)


############ Input Needs

  Input_mat_H2 <- vector(mode='list', length=length(industry_levels))
  names(Input_mat_H2) <- industry_levels
  
  for (l in 3) {
    o <- Output_mat_H3[[l]]
    industries <- rownames(o)
    d <- Direct_mat[[l]][industries, industries]
    Input_mat_H2[[l]] <- d %*% o
  }


############ Import Input Needs

  Input_mat_imp_H2 <- vector(mode='list', length=length(industry_levels))
  names(Input_mat_imp_H2) <- industry_levels
  
  for (l in 3){
    Input_mat_imp_H2[[l]] <- pmax(Input_mat_H2[[l]] - Output_mat_H3[[l]], 0)
  }


############ Net Exports

  Input_mat_exp_H2 <- vector(mode='list', length=length(industry_levels))
  names(Input_mat_exp_H2) <- industry_levels
  
  for (l in 3){
    Input_mat_exp_H2[[l]] <- pmax(Output_mat_H3[[l]] -  Input_mat_H2[[l]], 0)
  }


############ Relative Queeg specification

  Queeg_rel_H2 <- vector(mode='list', length=length(industry_levels))
  names(Queeg_rel_H2) <- industry_levels
  for (l in 3){
    Queeg_rel_H2[[l]] <-  matrix(0, nrow = ncol(Output_mat_H3[[l]]), 
                         ncol = ncol(Output_mat_H3[[l]]) )
    rownames(Queeg_rel_H2[[l]]) = colnames(Queeg_rel_H2[[l]]) <- colnames(Output_mat_H3[[l]])
  }
  
  for (l in 3){
    o <- Output_mat_H3[[l]]
    industries <- rownames(o)
    d <- Direct_mat[[l]][industries, industries]
    for (i in 1:ncol(o)){
      for (j in 1:ncol(o)){
        Queeg_rel_H2[[l]][i,j] <- 
          (rep(c(1), each=ncol(d)) %*% pmin(Input_mat_exp_H2[[l]][,i], Input_mat_imp_H2[[l]][,j])) /
          (rep(c(1), each=ncol(d)) %*% Input_mat_exp_H2[[l]][,i])
      }
    }
  }




```



```{r }
#Produce new clustered total output matrix from matched cores

###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H2

#geographical impedance (used here for breaking ties)
imp_mat <- Impede_mat[[4]]

#exporting "row" counties
macc <- colnames(Queeg_rel_H2[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H2[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th

# Queeg_selectr(specname=Output_mat_H4, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H2, imp_mat=Impede_mat[[4]], macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H3, isolation_th=isolation_th)



  Output_mat_H4 <- vector(mode='list', length=length(industry_levels))
  names(Output_mat_H4) <- industry_levels
  
  CoreMatch <- Output_mat_H4
  MatchMat <- Output_mat_H4
  cuml_core_out <- Output_mat_H4
  perf_core_out <- Output_mat_H4 
  nomatch_core_out <- Output_mat_H4
  th_iso <- Output_mat_H4
  
  for (l in 3){
    l<<-l
    #all non-zero row-total export counties
    CoreMatch[[l]] <- (queeg_mat[[l]][macc, singcc] * Impede_mat[[4]][[l]][macc, singcc])  
    CoreMatch[[l]] %<>% .[apply(., 1, function(x){!all(x<isolation_th)}), ,drop = FALSE]
    
    if(length(CoreMatch[[l]]) >0 ){
      #CoreMatch[[l]] %<>% as.matrix()
    MatchMat[[l]] <- sparseMatrix(i = match(rownames(CoreMatch[[l]]), rownames(CoreMatch[[l]])),
                               j = match(c(colnames(CoreMatch[[l]])[apply(CoreMatch[[l]], 1, which.max)]), colnames(CoreMatch[[l]])),
                               x = 1L,
                               dims = c(nrow(CoreMatch[[l]]), ncol(CoreMatch[[l]])),
                               dimnames = list(rownames(CoreMatch[[l]]), colnames(CoreMatch[[l]]))
    ) %>% as.matrix()
    
    #cumulative output of matched cores and non-cores 
    cuml_core_out[[l]] <- (out_mat[[l]][, rownames(MatchMat[[l]])[order(rownames(MatchMat[[l]]))],  drop = FALSE] %*% 
                             MatchMat[[l]][order(rownames(MatchMat[[l]])), order(colnames(MatchMat[[l]])), drop = FALSE]) %>% 
      .[, sort(unique(colnames(CoreMatch[[l]])[apply(CoreMatch[[l]], 1, which.max)])), drop = FALSE] + out_mat[[l]][, sort(unique(colnames(CoreMatch[[l]])[apply(CoreMatch[[l]], 1, which.max)])), drop = FALSE]
    
    }else{ cuml_core_out[[l]] =  NA}
    
    #output of unmatched cores
    perf_core_out[[l]] <- as.data.frame(queeg_mat[[l]][macc, singcc] * imp_mat[[l]][macc,  singcc]) %>% .[apply(., 1, function(x){all(x<isolation_th)}),]  %>% rownames() %>% setdiff(., colnames(cuml_core_out[[l]])) %>% out_mat[[l]][, .]
    
    perf_core_out[[l]] <- (queeg_mat[[l]][macc, singcc] * imp_mat[[l]][macc, singcc]) 
    perf_core_out[[l]] %<>% .[apply(., 1, function(x){all(x<isolation_th)}),]  %>% rownames() %>% setdiff(., colnames(cuml_core_out[[l]])) %>% out_mat[[l]][, .]
    
    
    #output of unmatched noncores
    nomatch_core_out[[l]] <- union(colnames(cuml_core_out[[l]]), colnames(perf_core_out[[l]])) %>% setdiff(colnames(queeg_mat[[l]][, singcc]), .) %>% out_mat[[l]][,.] 
      
    th_iso[[l]] <- as.data.frame(queeg_mat[[l]][macc, singcc] * imp_mat[[l]][macc,  singcc]) %>% .[apply(., 1, function(x){all(x<isolation_th)}),]  %>% rownames() %>% out_mat[[l]][,.]
    
    Output_mat_H4[[l]] <- cbind(cuml_core_out[[l]], perf_core_out[[l]], nomatch_core_out[[l]]) %>% .[, sort(c(colnames(cuml_core_out[[l]]), 
                                                                                               colnames(perf_core_out[[l]]), 
                                                                                               colnames(nomatch_core_out[[l]])
    ))]
    
  }
  





```



```{r, warning=FALSE}


###All new ECA clusters
tdf <-  data.frame(place = c(h1m[[3]]$place[h1m[[3]]$NAME %in% (setdiff(unique(h1m[[3]]$h2eca) , "Isolated"))]),
                   NAME = c(h1m[[3]]$NAME[h1m[[3]]$NAME %in% (setdiff(unique(h1m[[3]]$h2eca) , "Isolated"))]))


#Each new core cluster
df <- vector(mode='list', length=length(setdiff(unique(h1m[[3]]$h2eca) , "Isolated")))
  names(df) <- h1m[[3]]$NAME[h1m[[3]]$NAME %in% (setdiff(unique(h1m[[3]]$h2eca) , "Isolated"))]

for(i in 1:length(df)){
  df[[i]] <- c(tdf[i,1])
}

for(i in 1:length(df)){
  df[[i]] <- c(df[[i]],  setdiff(h1m[[3]]$place[h1m[[3]]$h2eca %in% names(df[i])], df[[i]]))
}


ext <- df


####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H2
  isolation_th <- isolation_th
  
  
  macc <- h1m[[3]]$place[h1m[[3]]$h2eca == "Isolated"]
  
  #All metro and micro clusters
  df <- list("Cerro Gordo" = Masoncity,
              "Des Moines" = Burlington,
              "Lee"  = Keokuk,
              "Polk" = Desmoines,
              "Story" = Ames,
              "Woodbury" = Siouxcity,
              "Pottawattamie" = Omaha,
              "Black Hawk" = Wateloo,
              "Linn" = Cedarrrapids,
              "Johnson" = Iowacity,
              "Scott" = Davenport)
  
  # 
  # 
  # 
  # #############BAD Brute FORCE
  

  
  n <- df[setdiff(names(df), names(ext))][sapply(df[setdiff(names(df), names(ext))], function(x) x[1]) %in% unlist(ext)]
 
  # #     # #vis
  #     for(i in 1:length(ext)){
  #          print(unlist(ext[i]) %in% unlist(n))
  #     }
  # 
  #         test <- c()
  #       for (i in 1:length(ext)){
  #         test[i] <- any(unlist(ext[i]) %in% unlist(n))
  #       }
  # 
  #         # #vis
  #        ext[names(ext[test])]

       
  #           ext$Johnson <- union(unlist(ext$Johnson), unlist(n$`Des Moines`))  
  #           ext$Johnson <- union(unlist(ext$Johnson), unlist(n$Woodbury))  
  #           ext$Pottawattamie <- union(unlist(ext$Pottawattamie), unlist(n$Lee))  
         
          # ##10% isolation
          #     ext$`Buena Vista` <- union(unlist(ext$`Buena Vista`), unlist(n$`Cerro Gordo`))  
          #     ext$`Buena Vista` <- union(unlist(ext$`Buena Vista`), unlist(n$`Des Moines`))  
          #     ext$Woodbury <- union(unlist(ext$Woodbury), unlist(n$Story))  
          #     
              
  
         # ##5% isolation
              ext$`Buena Vista` <- union(unlist(ext$`Buena Vista`), unlist(n$`Cerro Gordo`))  
              ext$`Buena Vista` <- union(unlist(ext$`Buena Vista`), unlist(n$`Des Moines`)) 
              ext$Pottawattamie <- union(unlist(ext$Pottawattamie), unlist(n$Scott)) 
              ext$Woodbury <- union(unlist(ext$Woodbury), unlist(n$Story)) 
          
          
  # 
  #                 ##All old clusters overlap with newly clusted CSAs
  #                 
  #                   # t <- vector(mode='list', length=length(setdiff(names(df), names(ext))) )
  #                   #     names(t) <- setdiff(names(df), names(ext))
  #                   # for (i in 1:length(t) ) {
  #                   #    t[[i]] <- union(unlist(ext[intersect(names(df), names(ext))][i]), 
  #                   #                    unlist(df[intersect(names(df), names(ext))][i]))
  #                   #    names(t[i]) <- df[i]
  #                   # }
  #                       
  #   ###############  
  # 
  
  ##All overlapping new clusters and old 
  t <- vector(mode='list', length=length(intersect(names(df), names(ext))) )
  names(t) <- intersect(names(df), names(ext))
  
  for (i in 1:length(t) ) {
       t[[i]] <- union(unlist(ext[intersect(names(df), names(ext))][i]), 
                       unlist(df[intersect(names(df), names(ext))][i]))
       names(t[i]) <- df[i]
    }

  ##All new clusters that are not old clusters
  k <- ext[setdiff(names(ext) , names(df))]
  
  ##All new clusters that do and do not overlap with old clusters 
  m <- c(t , k)
  
  
  #All old clusters  that are isolated
  o <- df[setdiff(names(df), union(names(n), names(ext)))]
  
  ##All clusters
  exta <- c(m , o)
  
  
  
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=exta, isolation_th=isolation_th, imp_mat=Impede_mat[[4]],  cbsa=cbsa) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = h1m[[3]]$lab
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)





my_pal_map  <- c("Cedar Rapids, IA MSA"  = "#b3de69",
                 "Omaha-Council Bluffs, NE-IA MSA" = "#fdb462", 
                 "Sioux City, IA-NE-SD MSA" = "#80b1d3",
                 "ECA Isolated" = "#A9A9A9",
                 "Isolated" = "#000000")
 

####Mapping Economic and Spatial cluster matching with isolation
  mapr2(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
       
```



**Level 2 Natural Matching**



```{r}
girafe(ggobj = p[[3]],
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;")
                       )
      )
```





**Level 2 ECA's**

```{r}

####Mapping ECAs
my_pal_map  <- c("Cedar Rapids, IA MSA"  = "#b3de69",  
                 "Omaha-Council Bluffs, NE-IA MSA" = "#fdb462", 
                  "Sioux City, IA-NE-SD MSA" = "#80b1d3",
                 "Isolated" = "#000000")
 
    maprECA(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)

girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )
```





### Impedance Effects


**Level 1 Natural Matching**

All counties/clusters can match to all counties/clusters.

```{r, warning=FALSE}

isolation_th=.05


#Produce new clustered total output matrix from matched cores


#All metro and micro clusters
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)

#All metro and micro core county representative
shoname <- sapply(ext, function(x) x[1])

#All non-metro, non-micro counties
macc <- grep("^19", rownames(TIGER_RUCC), value=TRUE) %>% setdiff(., metro) %>% setdiff(., micro)

#All metro and micro that are the representative core county
singcc <- setdiff(union(micro, metro), setdiff(unlist(ext), shoname)) 


trimr(specname=Output_mat_H1, macc=macc, singcc=singcc, ext=ext, industry_levels=industry_levels, o_mat=Output_mat)

```


```{r}
###First level calc

############ Input Needs
Input_Needs(specname=Input_mat_H1, o_mat=Output_mat_H1, industry_levels=industry_levels)

############ Import Input Needs
Import_Needs(specname=Input_mat_imp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Net Exports
Export_Needs(specname=Input_mat_exp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Relative Queeg specification
Rel_Queeg(specname=Queeg_rel_H1, o_mat=Output_mat_H1, im_mat=Input_mat_imp_H1, ex_mat=Input_mat_exp_H1, industry_levels=industry_levels)

```


**Hyperbolic Secant Function**

$Q^{rs} = 2/(e^{-d^{rs}c} + e^{d^{rs}c})$ where scalar $c = 10^{7}$ 

(Minimal spatial effect - used in all previous maps)

```{r, warning=FALSE}
#Produce new clustered total output matrix from matched cores

#geographical impedance (used here for breaking ties)
imp_mat <- Impede_mat[[4]]


###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=imp_mat, macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=isolation_th)


####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- isolation_th
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  #ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=imp_mat, cbsa=cbsa) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = (h1m[[3]]$lab)
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)


  my_pal_map  <- c("Cedar Rapids, IA MSA"  = "#b3de69",
                   "Des Moines-West Des Moines, IA MSA" = "#fccde5", 
                   "Fort Madison-Keokuk, IA-MO Î¼SA" = "#ffffb3",
                   "Iowa City, IA MSA" = "#ffd92f",
                  "Omaha-Council Bluffs, NE-IA MSA" = "#fdb462",
                  "Sioux" = "#e5c494",
                 "Sioux City, IA-NE-SD MSA" = "#80b1d3",
                  "Storm Lake, IA Î¼SA" = "#fb8072",
                 "Waterloo-Cedar Falls, IA MSA" = "#8dd3c7")
 

####Mapping Economic and Spatial cluster matching with isolation
  maprECA(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
  

  

girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )


```


**Hyperbolic Secant Function**

$Q^{rs} = 2/(e^{-d^{rs}c} + e^{d^{rs}c})$ where scalar $c = 10^{6}$ 

Note changes for Monona County, Marshal County, and the Fort Madison-Keokuk, IA-MO Î¼SA

```{r, warning=FALSE}
#Produce new clustered total output matrix from matched cores

#geographical impedance (used here for breaking ties)
imp_mat <- Impede_mat[[3]]


###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=imp_mat, macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=isolation_th)


####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- isolation_th
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  #ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=imp_mat, cbsa=cbsa) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = (h1m[[3]]$lab)
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)





  my_pal_map  <- c("Cedar Rapids, IA MSA"  = "#b3de69",
                   "Des Moines-West Des Moines, IA MSA" = "#fccde5", 
                   "Fort Madison-Keokuk, IA-MO Î¼SA" = "#ffffb3",
                   "Iowa City, IA MSA" = "#ffd92f",
                  "Omaha-Council Bluffs, NE-IA MSA" = "#fdb462",
                  "Sioux" = "#e5c494",
                 "Sioux City, IA-NE-SD MSA" = "#80b1d3",
                  "Storm Lake, IA Î¼SA" = "#fb8072",
                 "Waterloo-Cedar Falls, IA MSA" = "#8dd3c7")
 

####Mapping Economic and Spatial cluster matching with isolation
  maprECA(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
  

  

girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )


```



**Hyperbolic Secant Function**

$Q^{rs} = 2/(e^{-d^{rs}c} + e^{d^{rs}c})$ where scalar $c = 10^{5}$ 

```{r, warning=FALSE}
#Produce new clustered total output matrix from matched cores

#geographical impedance (used here for breaking ties)
  df <- D_mat
  for (i in 1:length(D_mat)){
    df[[i]] <- ((2/(exp(-(D_mat[[i]]/100000)) + exp(D_mat[[i]]/100000))))
  }

imp_mat <- df


###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=imp_mat, macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=isolation_th)


####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- isolation_th
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  #ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=imp_mat, cbsa=cbsa) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = (h1m[[3]]$lab)
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)




  my_pal_map  <- c("Cedar Rapids, IA MSA"  = "#b3de69",
                   "Des Moines-West Des Moines, IA MSA" = "#fccde5", 
                   "Fort Dodge, IA Î¼SA"  = "#66c2a5",
                   "Fort Madison-Keokuk, IA-MO Î¼SA" = "#ffffb3",
                   "Iowa City, IA MSA" = "#ffd92f",
                  "Omaha-Council Bluffs, NE-IA MSA" = "#fdb462",
                  "Sioux" = "#e5c494",
                 "Sioux City, IA-NE-SD MSA" = "#80b1d3",
                  "Storm Lake, IA Î¼SA" = "#fb8072",
                 "Waterloo-Cedar Falls, IA MSA" = "#8dd3c7",
                  "Isolated" = "#000000")




####Mapping Economic and Spatial cluster matching with isolation
  maprECA(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
  

  

girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )


```



**Hyperbolic Secant Function**

$Q^{rs} = 2/(e^{-d^{rs}c} + e^{d^{rs}c})$ where scalar $c = 10^{4}$ 

```{r, warning=FALSE}
#Produce new clustered total output matrix from matched cores

#geographical impedance (used here for breaking ties)
  df <- D_mat
  for (i in 1:length(D_mat)){
    df[[i]] <- ((2/(exp(-(D_mat[[i]]/10000)) + exp(D_mat[[i]]/10000))))
  }

imp_mat <- df


###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=imp_mat, macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=isolation_th)


####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- isolation_th
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  #ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=imp_mat, cbsa=cbsa) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = (h1m[[3]]$eca)
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)



my_pal_map  <- c("Isolated" = "#000000")


####Mapping Economic and Spatial cluster matching with isolation
  maprECA(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
  

  

girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )


```





**Exponential Decay Function**

$Q^{rs} = e^{-d^{rs}c}$ where scalar $c = 10^{7}$ 

```{r, warning=FALSE}
#Produce new clustered total output matrix from matched cores

#geographical impedance (used here for breaking ties)

  df <- D_mat
  for (i in 1:length(D_mat)){
    df[[i]] <- (exp(-(D_mat[[i]]/10000000)) )
  }

imp_mat <- df


###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=imp_mat, macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=isolation_th)


####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- isolation_th
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  #ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=imp_mat, cbsa=cbsa) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = (h1m[[3]]$eca)
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)



  my_pal_map  <- c("Cedar Rapids, IA MSA"  = "#b3de69",
                   "Des Moines-West Des Moines, IA MSA" = "#fccde5", 
                   "Fort Madison-Keokuk, IA-MO Î¼SA" = "#ffffb3",
                   "Iowa City, IA MSA" = "#ffd92f",
                  "Omaha-Council Bluffs, NE-IA MSA" = "#fdb462",
                  "Sioux" = "#e5c494",
                 "Sioux City, IA-NE-SD MSA" = "#80b1d3",
                  "Storm Lake, IA Î¼SA" = "#fb8072",
                 "Waterloo-Cedar Falls, IA MSA" = "#8dd3c7")


####Mapping Economic and Spatial cluster matching with isolation
  maprECA(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
  

  

girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )


```


**Exponential Decay Function**

$Q^{rs} = e^{-d^{rs}c}$ where scalar $c = 10^{6}$ 

```{r, warning=FALSE}
#Produce new clustered total output matrix from matched cores

#geographical impedance (used here for breaking ties)

  df <- D_mat
  for (i in 1:length(D_mat)){
    df[[i]] <- (exp(-(D_mat[[i]]/1000000)) )
  }

imp_mat <- df


###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=imp_mat, macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=isolation_th)


####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- isolation_th
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  #ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=imp_mat, cbsa=cbsa) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = (h1m[[3]]$eca)
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)



  my_pal_map  <- c( "Des Moines-West Des Moines, IA MSA" = "#fccde5", 
                  "Iowa City, IA MSA" = "#ffd92f",
                  "Omaha-Council Bluffs, NE-IA MSA" = "#fdb462",
                 "Sioux City, IA-NE-SD MSA" = "#80b1d3",
                  "Storm Lake, IA Î¼SA" = "#fb8072",
                 "Waterloo-Cedar Falls, IA MSA" = "#8dd3c7",
                  "Isolated" = "#000000")


####Mapping Economic and Spatial cluster matching with isolation
  maprECA(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
  

  

girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )


```



**Exponential Decay Function**

$Q^{rs} = e^{-d^{rs}c}$ where scalar $c = 10^{5}$ 

```{r, warning=FALSE}
#Produce new clustered total output matrix from matched cores

#geographical impedance (used here for breaking ties)

  df <- D_mat
  for (i in 1:length(D_mat)){
    df[[i]] <- (exp(-(D_mat[[i]]/100000)) )
  }

imp_mat <- df


###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=imp_mat, macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=isolation_th)


####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- isolation_th
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  #ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=imp_mat, cbsa=cbsa) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = (h1m[[3]]$eca)
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)



  my_pal_map  <- c("Cedar Rapids, IA MSA"  = "#b3de69",
                   "Des Moines-West Des Moines, IA MSA" = "#fccde5", 
                   "Fort Dodge, IA Î¼SA"  = "#66c2a5",
                   "Fort Madison-Keokuk, IA-MO Î¼SA" = "#ffffb3",
                   "Iowa City, IA MSA" = "#ffd92f",
                  "Omaha-Council Bluffs, NE-IA MSA" = "#fdb462",
                 "Sioux City, IA-NE-SD MSA" = "#80b1d3",
                  "Storm Lake, IA Î¼SA" = "#fb8072",
                 "Waterloo-Cedar Falls, IA MSA" = "#8dd3c7",
                  "Isolated" = "#000000")



####Mapping Economic and Spatial cluster matching with isolation
  maprECA(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
  

  

girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )


```





**Inverse Thousandth Root Function**

$Q^{rs} = 1/(d^{rs})^{1/1000}$

```{r, warning=FALSE}
#Produce new clustered total output matrix from matched cores

#geographical impedance (used here for breaking ties)

  df <- D_mat
  for (i in 1:length(D_mat)){
    df[[i]] <-  ((1/(D_mat[[i]]^{1/1000})))
    diag(df[[i]]) <- 1
  }

imp_mat <- df


###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=imp_mat, macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=isolation_th)


####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- isolation_th
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  #ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=imp_mat, cbsa=cbsa) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = (h1m[[3]]$eca)
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)



#
  
  my_pal_map  <- c("Cedar Rapids, IA MSA"  = "#b3de69",
                   "Des Moines-West Des Moines, IA MSA" = "#fccde5", 
                   "Fort Madison-Keokuk, IA-MO Î¼SA" = "#ffffb3",
                   "Iowa City, IA MSA" = "#ffd92f",
                  "Omaha-Council Bluffs, NE-IA MSA" = "#fdb462",
                  "Sioux" = "#e5c494",
                 "Sioux City, IA-NE-SD MSA" = "#80b1d3",
                  "Storm Lake, IA Î¼SA" = "#fb8072",
                 "Waterloo-Cedar Falls, IA MSA" = "#8dd3c7")



####Mapping Economic and Spatial cluster matching with isolation
  maprECA(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
  

  

girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )


```



**Inverse Hundredth Root Function**

$Q^{rs} = 1/(d^{rs})^{1/100}$

```{r, warning=FALSE}
#Produce new clustered total output matrix from matched cores

#geographical impedance (used here for breaking ties)

  df <- D_mat
  for (i in 1:length(D_mat)){
    df[[i]] <-  ((1/(D_mat[[i]]^{1/100})))
    diag(df[[i]]) <- 1
  }

imp_mat <- df


###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=imp_mat, macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=isolation_th)


####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- isolation_th
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  #ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=imp_mat, cbsa=cbsa) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = (h1m[[3]]$eca)
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)

  
  my_pal_map  <- c("Cedar Rapids, IA MSA"  = "#b3de69",
                   "Des Moines-West Des Moines, IA MSA" = "#fccde5", 
                   "Fort Madison-Keokuk, IA-MO Î¼SA" = "#ffffb3",
                   "Iowa City, IA MSA" = "#ffd92f",
                  "Omaha-Council Bluffs, NE-IA MSA" = "#fdb462",
                  "Sioux" = "#e5c494",
                 "Sioux City, IA-NE-SD MSA" = "#80b1d3",
                  "Storm Lake, IA Î¼SA" = "#fb8072",
                 "Waterloo-Cedar Falls, IA MSA" = "#8dd3c7",
                  "Isolated" = "#000000")


####Mapping Economic and Spatial cluster matching with isolation
  maprECA(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
  

  

girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )


```




**Inverse Twentieth Root Function**

$Q^{rs} = 1/(d^{rs})^{1/20}$

```{r, warning=FALSE}
#Produce new clustered total output matrix from matched cores

#geographical impedance (used here for breaking ties)

  df <- D_mat
  for (i in 1:length(D_mat)){
    df[[i]] <-  ((1/(D_mat[[i]]^{1/20})))
    diag(df[[i]]) <- 1
  }

imp_mat <- df


###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=imp_mat, macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=isolation_th)


####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- isolation_th
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  #ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=imp_mat, cbsa=cbsa) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = (h1m[[3]]$eca)
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)



 
  my_pal_map  <- c("Des Moines-West Des Moines, IA MSA" = "#fccde5", 
                   "Iowa City, IA MSA" = "#ffd92f",
                  "Omaha-Council Bluffs, NE-IA MSA" = "#fdb462",
                 "Sioux City, IA-NE-SD MSA" = "#80b1d3",
                  "Storm Lake, IA Î¼SA" = "#fb8072",
                 "Waterloo-Cedar Falls, IA MSA" = "#8dd3c7",
                  "Isolated" = "#000000")


####Mapping Economic and Spatial cluster matching with isolation
  maprECA(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
  

  

girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )


```


**Inverse Tenth Root Function**

$Q^{rs} = 1/(d^{rs})^{1/10}$

```{r, warning=FALSE}
#Produce new clustered total output matrix from matched cores

#geographical impedance (used here for breaking ties)

  df <- D_mat
  for (i in 1:length(D_mat)){
    df[[i]] <-  ((1/(D_mat[[i]]^{1/10})))
    diag(df[[i]]) <- 1
  }

imp_mat <- df


###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=imp_mat, macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=isolation_th)


####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- isolation_th
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  #ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=imp_mat, cbsa=cbsa) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = (h1m[[3]]$eca)
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)


 my_pal_map  <- c("Des Moines-West Des Moines, IA MSA" = "#fccde5", 
                  "Omaha-Council Bluffs, NE-IA MSA" = "#fdb462",
                 "Sioux City, IA-NE-SD MSA" = "#80b1d3",
                  "Storm Lake, IA Î¼SA" = "#fb8072",
                 "Waterloo-Cedar Falls, IA MSA" = "#8dd3c7",
                  "Isolated" = "#000000")


####Mapping Economic and Spatial cluster matching with isolation
  maprECA(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
  

  

girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )


```


**Inverse Eighth Root Function**

$Q^{rs} = 1/(d^{rs})^{1/8}$

```{r, warning=FALSE}
#Produce new clustered total output matrix from matched cores

#geographical impedance (used here for breaking ties)

  df <- D_mat
  for (i in 1:length(D_mat)){
    df[[i]] <-  ((1/(D_mat[[i]]^{1/8})))
    diag(df[[i]]) <- 1
  }

imp_mat <- df


###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=imp_mat, macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=isolation_th)


####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- isolation_th
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  #ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=imp_mat, cbsa=cbsa) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = (h1m[[3]]$eca)
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)

 my_pal_map  <- c("Des Moines-West Des Moines, IA MSA" = "#fccde5", 
                  "Omaha-Council Bluffs, NE-IA MSA" = "#fdb462",
                 "Sioux City, IA-NE-SD MSA" = "#80b1d3",
                  "Storm Lake, IA Î¼SA" = "#fb8072",
                 "Waterloo-Cedar Falls, IA MSA" = "#8dd3c7",
                  "Isolated" = "#000000")


####Mapping Economic and Spatial cluster matching with isolation
  maprECA(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
  

  

girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )


```



**Inverse Seventh Root Function**

$Q^{rs} = 1/(d^{rs})^{1/7}$

```{r, warning=FALSE}
#Produce new clustered total output matrix from matched cores

#geographical impedance (used here for breaking ties)

  df <- D_mat
  for (i in 1:length(D_mat)){
    df[[i]] <-  ((1/(D_mat[[i]]^{1/7})))
    diag(df[[i]]) <- 1
  }

imp_mat <- df


###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=imp_mat, macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=isolation_th)


####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- isolation_th
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  #ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=imp_mat, cbsa=cbsa) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = (h1m[[3]]$eca)
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)


 my_pal_map  <- c("Des Moines-West Des Moines, IA MSA" = "#fccde5", 
                  "Omaha-Council Bluffs, NE-IA MSA" = "#fdb462",
                 "Sioux City, IA-NE-SD MSA" = "#80b1d3",
                  "Storm Lake, IA Î¼SA" = "#fb8072",
                 "Waterloo-Cedar Falls, IA MSA" = "#8dd3c7",
                  "Isolated" = "#000000")


####Mapping Economic and Spatial cluster matching with isolation
  maprECA(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
  

  

girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )


```




**Inverse Sixth Root Function**

$Q^{rs} = 1/(d^{rs})^{1/6}$

```{r, warning=FALSE}
#Produce new clustered total output matrix from matched cores

#geographical impedance (used here for breaking ties)

  df <- D_mat
  for (i in 1:length(D_mat)){
    df[[i]] <-  ((1/(D_mat[[i]]^{1/6})))
    diag(df[[i]]) <- 1
  }

imp_mat <- df


###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=imp_mat, macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=isolation_th)


####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- isolation_th
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  #ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=imp_mat, cbsa=cbsa) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = (h1m[[3]]$eca)
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)


 my_pal_map  <- c("Omaha-Council Bluffs, NE-IA MSA" = "#fdb462",
                 "Sioux City, IA-NE-SD MSA" = "#80b1d3",
                  "Storm Lake, IA Î¼SA" = "#fb8072", 
                 "Waterloo-Cedar Falls, IA MSA" = "#8dd3c7", 
                  "Isolated" = "#000000")


####Mapping Economic and Spatial cluster matching with isolation
  maprECA(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
  

  

girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )


```






**Inverse Fifth Root Function**

$Q^{rs} = 1/(d^{rs})^{1/5}$

```{r, warning=FALSE}
#Produce new clustered total output matrix from matched cores

#geographical impedance (used here for breaking ties)

  df <- D_mat
  for (i in 1:length(D_mat)){
    df[[i]] <-  ((1/(D_mat[[i]]^{1/5})))
    diag(df[[i]]) <- 1
  }

imp_mat <- df


###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=imp_mat, macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=isolation_th)


####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- isolation_th
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport)
  #ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=imp_mat, cbsa=cbsa) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = (h1m[[3]]$eca)
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)


my_pal_map  <- c("Omaha-Council Bluffs, NE-IA MSA" = "#fdb462",
                 "Sioux City, IA-NE-SD MSA" = "#80b1d3",
                   "Isolated" = "#000000")


####Mapping Economic and Spatial cluster matching with isolation
  maprECA(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
  

  

girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )


```




### Multistate


```{r}
#Specify regional extent and possible (MSA) clusters

metro <- c("19193", 
           "19085",
           "19155",
           "19129",
           "19121",
           "19181",
           "19077",
           "19049",
           "19153",
           "19099",
           "19015",
           "19169",
           "19017",
           "19075",
           "19013",
           "19061",
           "19011",
           "19113",
           "19105",
           "19103",
           "19183",
           "19163",
"31025",
"31043",
"31051",
"31055",
"31079",
"31081",
"31093",
"31109",
"31121",
"31153",
"31155",
"31159",
"31177")


micro <- c("19059", 
           "19041",
           "19021",
           "19027",
           "19187",
           "19195",
           "19033",
           "19127",
           "19125",
           "19123",
           "19179",
           "19101",
           "19045",
           "19139",
           "19057",
           "19111",
"31001",
"31019",
"31047",
"31053",
"31067",
"31073",
"31099",
"31111",
"31113",
"31119",
"31139",
"31141",
"31157",
"31165",
"31167" )

               

Desmoines <- c("19153",
               "19121",
               "19181",
               "19077",
               "19049",
               "19099")

Ames <- c("19169",
          "19015")

Siouxcity <- c("19193",
               "46127",
               "31043",
               "31051")

Omaha  <- c("19155",
            "19085",
            "19129",
            "31177",
            "31055",
            "31153",
            "31025",
            "31155")

Wateloo <- c("19013",
             "19017",
             "19075")

Cedarrrapids <- c("19113",
                  "19011",
                  "19105")

Iowacity <-  c("19103",
               "19183")

Davenport <- c("19163",
               "17161",
               "17073",
               "17131")

Masoncity <- c("19033",
               "19195")

Burlington <- c("19057",
                "17071")

Keokuk  <- c("19111",
             "17067",
             "29045")

Lincon <- c("31109","31159")
Grandisland <- c("31079","31121","31093")
Kearney <- c("31019", "31099")
Norfolk <- c("31119", "31139", "31167")
Scottsbluff <- c("31157", "31165")
Northplatte <- c("31111", "31113")
Laxington <- c("31047", "31073")




```


```{r}
cbsa  <-  data.frame("CBSA" = c("Des Moines-West Des Moines, IA MSA",
"Newton, IA Î¼SA",
"Pella, IA Î¼SA",
"Cedar Rapids, IA MSA",
"Davenport-Moline-Rock Island, IA-IL MSA",
"Waterloo-Cedar Falls, IA MSA",
"Iowa City, IA MSA",
"Omaha-Council Bluffs, NE-IA MSA",
"Ames, IA MSA",
"Sioux City, IA-NE-SD MSA",
"Dubuque, IA MSA",
"Muscatine, IA Î¼SA",
"Mason City, IA Î¼SA",
"Clinton, IA Î¼SA",
"Burlington, IA-IL Î¼SA",
"Marshalltown, IA Î¼SA",
"Fort Dodge, IA Î¼SA",
"Fort Madison-Keokuk, IA-MO Î¼SA",
"Ottumwa, IA Î¼SA",
"Oskaloosa, IA Î¼SA",
"Storm Lake, IA Î¼SA",
"Spirit Lake, IA Î¼SA",
"Spencer, IA Î¼SA",
"Carroll, IA Î¼SA"))

cbsa  <- data.frame(cbsa, "NAME"= c("Polk",
  "Jasper",
  "Marion",
  "Linn",
  "Scott",
  "Black Hawk",
  "Johnson",
  "Pottawattamie",
  "Story",
  "Woodbury",
  "Dubuque",
  "Muscatine",
  "Cerro Gordo",
  "Clinton",
  "Des Moines",
  "Marshall",
  "Webster",
  "Lee",
  "Wapello",
  "Mahaska",
  "Buena Vista",
  "Dickinson",
  "Clay",
  "Carroll"))


df  <-  data.frame("CBSA" = c("CBSA" = c("Fremont, NE Î¼SA",
"Lincoln, NE MSA",
"Beatrice, NE Î¼SA",
"Grand Island, NE MSA",
"Kearney, NE Î¼SA",
"Norfolk, NE Î¼SA",
"Scottsbluff, NE Î¼SA",
"North Platte, NE Î¼SA",
"Columbus, NE Î¼SA",
"Hastings, NE Î¼SA",
"Lexington, NE Î¼SA")))


df  <- data.frame(df, "NAME"= c("NAME" = c("Dodge",
"Lancaster", 
"Gage", 
"Hall",
"Buffalo", 
"Madison",
"Scotts Bluff", 
"Lincoln", 
"Platte", 
"Adams", 
"Dawson")))

cbsa  <- rbind(cbsa, df)

```



```{r}

isolation_th=.05


#Produce new clustered total output matrix from matched cores

macc <- c(grep("^19", rownames(TIGER_RUCC), value=TRUE),
              grep("^31", rownames(TIGER_RUCC), value=TRUE) %>%
                grep("31007", ., value=TRUE, invert = TRUE) %>%
                grep("31117", ., value=TRUE, invert = TRUE) %>%
                grep("31085", ., value=TRUE, invert = TRUE) %>%
                grep("31103", ., value=TRUE, invert = TRUE))
singcc <- c(grep("^19", rownames(TIGER_RUCC), value=TRUE),
              grep("^31", rownames(TIGER_RUCC), value=TRUE) %>%
                grep("31007", ., value=TRUE, invert = TRUE) %>%
                grep("31117", ., value=TRUE, invert = TRUE) %>%
                grep("31085", ., value=TRUE, invert = TRUE) %>%
                grep("31103", ., value=TRUE, invert = TRUE))
ext <- NA
industry_levels <-industry_levels

trimr(specname=Output_mat_H1, macc=macc, singcc=singcc, ext=NA, industry_levels=industry_levels, o_mat=Output_mat)

```


```{r}
###First level calc

############ Input Needs
Input_Needs(specname=Input_mat_H1, o_mat=Output_mat_H1, industry_levels=industry_levels)

############ Import Input Needs
Import_Needs(specname=Input_mat_imp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Net Exports
Export_Needs(specname=Input_mat_exp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Relative Queeg specification
Rel_Queeg(specname=Queeg_rel_H1, o_mat=Output_mat_H1, im_mat=Input_mat_imp_H1, ex_mat=Input_mat_exp_H1, industry_levels=industry_levels)

```



```{r}
#Produce new clustered total output matrix from matched cores

###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#geographical impedance (used here for breaking ties)
imp_mat <- Impede_mat[[4]]

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th


Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, th_iso=th_iso, nomatch_core_out=nomatch_core_out, queeg_mat=Queeg_rel_H1, imp_mat=imp_mat, macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=isolation_th)

```



```{r, warning=FALSE}

####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- isolation_th
  # ext <- list(Masoncity = Masoncity,
  #             Burlington = Burlington,
  #             Keokuk  = Keokuk,
  #             Desmoines = Desmoines,
  #             Ames = Ames,
  #             Siouxcity = Siouxcity,
  #             Omaha = Omaha,
  #             Wateloo = Wateloo,
  #             Cedarrrapids = Cedarrrapids,
  #             Iowacity = Iowacity,
  #             Davenport = Davenport)
  #macc <- colnames(Queeg_rel_H1[[3]])
 ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=Impede_mat[[4]], cbsa=cbsa) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#e31a1c",  "#1f78b4",  "#33a02c", "#ff7f00", "#6a3d9a", "#ffff99",  "#b15928", "#fb9a99",  "#b2df8a", "#fdbf6f",  "#cab2d6", "#a6cee3",  "#1b9e77",  "#d95f02",  "#7570b3",  "#e7298a", "#66a61e", "#e6ab02", "#8dd3c7", "#ffffb3",  "#bebada", "#fb8072", "#80b1d3")
 placenames = h1m[[3]]$cnt_place
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)
 


# my_pal_map  <- c("Black Hawk" = "#8dd3c7", 
#                 "Buena Vista" = "#fb8072", 
#                 "Dallas" = "#bebada", 
#                 "Lee" = "#ffffb3", 
#                 "Linn"  = "#b3de69",  
#                 "Polk" = "#fccde5", 
#                 "Pottawattamie" = "#fdb462", 
#                 "Sioux" = "#e5c494",
#                 "Woodbury" = "#80b1d3",
#                 "ECA Isolated" = "#A9A9A9",
#                 "Isolated" = "#000000")



####Mapping Economic and Spatial cluster matching with isolation
  
maprCNT(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
      



```

```{r}
# girafe(ggobj = p[[3]], 
#                        options = list(opts_hover(css = "stroke:gray;r:20pt;"),
#                                       opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
#                        )
#       )
```









```{r, warning=FALSE}

isolation_th=.05


#Produce new clustered total output matrix from matched cores


#All metro and micro clusters
  ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport,
Lincon=Lincon, 
Grandisland=Grandisland,
Kearney=Kearney, 
Norfolk=Norfolk, 
Scottsbluff=Scottsbluff, 
Northplatte=Northplatte, 
Laxington=Laxington )

#All metro and micro core county representative
shoname <- sapply(ext, function(x) x[1])

#All non-metro, non-micro counties
macc <- c(grep("^19", rownames(TIGER_RUCC), value=TRUE),
              grep("^31", rownames(TIGER_RUCC), value=TRUE) %>%
                grep("31007", ., value=TRUE, invert = TRUE) %>%
                grep("31117", ., value=TRUE, invert = TRUE) %>%
                grep("31085", ., value=TRUE, invert = TRUE) %>%
                grep("31103", ., value=TRUE, invert = TRUE)) %>% setdiff(., metro) %>% setdiff(., micro)

#All metro and micro that are the representative core county
singcc <- setdiff(union(micro, metro), setdiff(unlist(ext), shoname)) 


trimr(specname=Output_mat_H1, macc=macc, singcc=singcc, ext=ext, industry_levels=industry_levels, o_mat=Output_mat)


```


```{r}
###First level calc

############ Input Needs
Input_Needs(specname=Input_mat_H1, o_mat=Output_mat_H1, industry_levels=industry_levels)

############ Import Input Needs
Import_Needs(specname=Input_mat_imp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Net Exports
Export_Needs(specname=Input_mat_exp_H1, o_mat=Output_mat_H1, i_mat=Input_mat_H1,  industry_levels=industry_levels)

############ Relative Queeg specification
Rel_Queeg(specname=Queeg_rel_H1, o_mat=Output_mat_H1, im_mat=Input_mat_imp_H1, ex_mat=Input_mat_exp_H1, industry_levels=industry_levels)

```



```{r}
#Produce new clustered total output matrix from matched cores

###Second level Output Vector
#county by county absorption matrix
queeg_mat <- Queeg_rel_H1

#geographical impedance (used here for breaking ties)
imp_mat <- Impede_mat[[4]]

#exporting "row" counties
macc <- colnames(Queeg_rel_H1[[3]])

#importing "column" counties
singcc <- colnames(Queeg_rel_H1[[3]])

#total industry output by county matrix
out_mat <- Output_mat_H1

#Isolation threshold
isolation_th=isolation_th

Queeg_selectr(specname=Output_mat_H2, CoreMatch=CoreMatch, MatchMat=MatchMat, cuml_core_out=cuml_core_out, perf_core_out=perf_core_out, nomatch_core_out=nomatch_core_out, th_iso=th_iso, queeg_mat=Queeg_rel_H1, imp_mat=Impede_mat[[4]], macc=macc, singcc=singcc, industry_levels=industry_levels, out_mat=Output_mat_H1, isolation_th=isolation_th)



```



```{r, warning=FALSE}

####Economic and Spatial cluster matching with isolation 
  mat_mat <- MatchMat
  spec_clust  <- th_iso
  qdf <- Queeg_rel_H1
  isolation_th <- isolation_th
ext <- list(Masoncity = Masoncity,
              Burlington = Burlington,
              Keokuk  = Keokuk,
              Desmoines = Desmoines,
              Ames = Ames,
              Siouxcity = Siouxcity,
              Omaha = Omaha,
              Wateloo = Wateloo,
              Cedarrrapids = Cedarrrapids,
              Iowacity = Iowacity,
              Davenport = Davenport,
Lincon=Lincon, 
Grandisland=Grandisland,
Kearney=Kearney, 
Norfolk=Norfolk, 
Scottsbluff=Scottsbluff, 
Northplatte=Northplatte, 
Laxington=Laxington )
  #ext <- NA
  
  
hierarchr(specname=h1m, mat_mat=mat_mat, spec_clust=spec_clust, qdf=qdf, ext=ext, isolation_th=isolation_th, imp_mat=Impede_mat[[4]], cbsa=cbsa) 

#####Custom colors 
 #values = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#fccde5",  "#80b1d3", "#fdb462", "#b3de69")
values = c("#8dd3c7", "#ffffb3", "#e5c494", "#ffd92f", "#bebada", "#fb8072", "#fccde5", "#fdb462", "#b3de69", "#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854")
 placenames = (h1m[[3]]$lab)
 #placenames = (rbind(h1m[[1]],h1m[[2]],h1m[[3]]))$lab
 
cus_pal_maps(specname = my_pal_map, values=values, placenames=placenames)
# comp_pal  <- c( "Waterloo-Cedar Falls, IA MSA" = "#8dd3c7", 
#                   "Storm Lake, IA Î¼SA" = "#fb8072", 
#                 "Dallas" = "#bebada", 
#                   "Fort Madison-Keokuk, IA-MO Î¼SA" = "#ffffb3", 
#                 "Fremont, NE Î¼SA" = "#8da0cb",
#                "Iowa City, IA MSA" = "#ffd92f",
#                   "Cedar Rapids, IA MSA"  = "#b3de69",  
#                   "Des Moines-West Des Moines, IA MSA" = "#fccde5",
#                   "Kearney, NE Î¼SA"  =   "#fc8d62",
#                   "Omaha-Council Bluffs, NE-IA MSA" = "#fdb462", 
#                   "Sioux" = "#e5c494",
#                   "Sioux City, IA-NE-SD MSA" = "#80b1d3",
#                     "Fort Dodge, IA Î¼SA"  = "#66c2a5"
#                   "ECA Isolated" = "#A9A9A9",
#                    "Davenport-Moline-Rock Island, IA-IL MSA" = "#e78ac3",
#                   "Isolated" = "#000000")


  my_pal_map  <- c("Cedar Rapids, IA MSA"  = "#b3de69",
                    "Davenport-Moline-Rock Island, IA-IL MSA" = "#e78ac3",
                   "Des Moines-West Des Moines, IA MSA" = "#fccde5",
                   "Fort Dodge, IA Î¼SA"  = "#66c2a5",
                   "Fort Madison-Keokuk, IA-MO Î¼SA" = "#ffffb3",
                   "Fremont, NE Î¼SA" = "#8da0cb",
                   "Iowa City, IA MSA" = "#ffd92f",
                       "Kearney, NE Î¼SA"  =   "#fc8d62",
                 "Omaha-Council Bluffs, NE-IA MSA" = "#fdb462",
                 "Sioux" = "#e5c494",
                "Sioux City, IA-NE-SD MSA" = "#80b1d3",
                  "Storm Lake, IA Î¼SA" = "#fb8072",
                 "Waterloo-Cedar Falls, IA MSA" = "#8dd3c7",
                   "ECA Isolated" = "#A9A9A9")
 

####Mapping Economic and Spatial cluster matching with isolation
  mapr2(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)
  

  
  
```


**Level 1 Natural Matching**

All counties/clusters can match to all counties/clusters.



```{r}

#####Mapping Natural Matches
girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )
```



**Level 1 ECA's**

```{r}

####Mapping ECAs

  my_pal_map  <- c("Cedar Rapids, IA MSA"  = "#b3de69",
                   "Davenport-Moline-Rock Island, IA-IL MSA" = "#e78ac3",
                   "Des Moines-West Des Moines, IA MSA" = "#fccde5",
                   "Fort Dodge, IA Î¼SA"  = "#66c2a5",
                   "Fort Madison-Keokuk, IA-MO Î¼SA" = "#ffffb3",
                   "Fremont, NE Î¼SA" = "#8da0cb",
                   "Iowa City, IA MSA" = "#ffd92f",
                       "Kearney, NE Î¼SA"  =   "#fc8d62",
                 "Omaha-Council Bluffs, NE-IA MSA" = "#fdb462",
                 "Sioux" = "#e5c494",
                "Sioux City, IA-NE-SD MSA" = "#80b1d3",
                  "Storm Lake, IA Î¼SA" = "#fb8072",
                 "Waterloo-Cedar Falls, IA MSA" = "#8dd3c7")


    maprECA(specname=p, shade=FALSE, hatch=FALSE, hm=h1m, my_pal=my_pal_map)

girafe(ggobj = p[[3]], 
                       options = list(opts_hover(css = "stroke:gray;r:20pt;"),
                                      opts_tooltip(css = "font-family:sans-serif;background-color:gray;color:white;padding:10px;border-radius:5px;") 
                       )
      )
```




### notes


Two absorb the one,

the supply chain scales upward-

in isolation 


Note: Corner Cases.
Story county has a maximum total absorption with Johnson along with 15 other counties 
Allamakee has a maximum total absorption with Story and so would be matched to Story,making Story a cluster core.  However, 

5 Counties that are the only match  for that county
Allamakee to Story
BuenaVista to Scott
 Carrol  to  Linn
 Hardin to Dubuque
Johnson to Woodburry

Of these 5 there are 3 (BuenaVista, Carrol, Johnson) which have other counties that match to them making them cluster cores and meaning that they CANNOT match to another county. 
And 2 (Allamakee, Hardin) which do not have other exporting counties which they import from. 

Johnson only has a very weak absorption with Woodburry, below the isolation threshold, thus also making Woodbury a cluster core without any matches.
In addition, since BuenaVista, Carrol, and Johnson are themselves cluster cores, Scott, Linn and Woodburry are also cluster cores without any matches.

 





In this 2-stage analysis, the counties of Iowa are first matched internally. 
Note: this matching asks the question: Where is the greatest industry development opportunity for all rural counties among the Iowa Micropolitan Statistical Areas group of places, ignoring all other market opportunities in and out of state?
Next we ask: Where is the greatest industry development opportunity for all rural counties and Iowa Micropolitan Statistical Areas among the Iowa Metropolitan Statistical Areas group of places, ignoring all other market opportunities out of state? 



```{r}

#Produce new clustered total output matrix from matched cores

# for (l in 1:length(industry_levels)){  
#   Output_mat_H4[[l]] <- cbind(Output_mat_H4[[l]], Output_mat_H3[[l]][,setdiff(colnames(Output_mat_H3[[l]]), colnames(Output_mat_H4[[l]]))])
# }




##df <- left_join(h1m$Detail, cbsa, by = "NAME")
df <- h1m$Detail
df <- select(df, -c(H3, place, q_value, lab, cnt_place, m_count, h2eca, RUC_CODE_DESCRIPTION))

df <- relocate(df, match, .after = center)

df <- rename(df, match_cbsa_name = match_name)
df <- rename(df, norm_absorption_alpha = a_value)
df <- rename(df, level1_eca = eca)

df <- select(df, -c(match))
df <- as.data.frame(df)
iowaska <- df
saver(iowaska)
iowaska <- select(iowaska, -c(geometry, center))
write.csv(iowaska, "iowaska.csv")
```










FIN
::: 
















