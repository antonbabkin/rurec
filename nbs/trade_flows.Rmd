---
title: "&nbsp;"
format:
  html:
    self-contained: true
    page-layout: full
    code-fold: true
    code-tools: true
    code_download: yes
    latex_engine: pdflatex
params:
  county_fips: "39099"
---

```{r preamble, include = FALSE}

############ When you click the **Render** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document.
############ The params:county_fips:"..." option in YAML header allows the user to select a county for the notebook to analyze  


############ Set chunk behavior 
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 

############ For nonscientific notation
options(scipen=999)

```

```{r packages and libraries, include = FALSE}

############ Load and attach necessary packages
library(rprojroot)

############ Load custom functions
source(file.path(find_rstudio_root_file(), "nbs", "rural_typology_r_functions.R"))

```

```{r parameters, include = FALSE}
#Initialize parameter values
params

#Year of shapefile boundary data, one of ("2000", "2010", or "2013" through "2020")
tiger_year = "2020" 

#Get county and state names of params:county_fips
t <- call_tiger(tiger_year, 
                geometry = FALSE)

county_name <- t$NAME[t$place == params$county_fips]
state_name <- t$STATE[t$place == params$county_fips]

rm(t)

```

::: panel-tabset

# Notation

**Sector Framework**

Assume that the economy can be categorized into $n$ sectors

$\underset{(n \times n)}{\mathbf{Z}} = [z_{ij}]$ - monetary transactions matrix between pairs of sectors, from row sector $i$ to column sector $j$

$\underset{(n \times 1)}{\mathbf{f}} = [f_{i}]$ - total final demand vector for sector $i$'s product

$\underset{(n \times 1)}{\mathbf{x}} = [x_{i}]$ - total gross output vector of sector $i$'s product. Note $\mathbf{x} = \mathbf{Zi} + \mathbf{f} = \left[\sum^{n}_{j=1} z_{ij} + f_{i}\right]$

where $\mathbf{i}$ represent a column vector of 1's 

Postmultiplication of a matrix by $\mathbf{i}$ creates a column vector whose elements are the row sums of the matrix. 
Premultiplication of a matrix by $\mathbf{i'}$ creates a row vector whose elements are the column sums of the matrix.

$\underset{(n \times n)}{\mathbf{A}} = [a_{ij}]$ - the direct requirements matrix a.k.a. the technical coefficients matrix of the quantity of sector $i$'s product absorbed by sector $j$ per unit of $j$'s total output. Note $\mathbf{A} = \mathbf{Z\hat{x}}^{-1} = [z_{ij} / x_{j}]$

where the "hat" over a vector denotes a diagonal matrix with the elements of the vector along the main diagonal

$\underset{(n \times n)}{\mathbf{L}} = [l_{ij}]$ - the total requirements matrix a.k.a. the Leontief inverse matrix of the quantity of sector $i$'s overall production required to produce a dollar of sector $j$'s gross output. Note $\mathbf{x} = \mathbf{Ax} + \mathbf{f}$ such that $\mathbf{x} = \left(\mathbf{I} - \mathbf{A}\right)^{-1}\mathbf{f}$ and $\mathbf{L} = \left(\mathbf{I} - \mathbf{A}\right)^{-1}$



**Regional Framework**

Assume that the economy consists of $r$ sub-national regional economies

$\underset{(n \times n)}{\mathbf{Z}^{rr}} = [z^{rr}_{ij}]$ - monetary transactions matrix between pairs of sectors, from sector $i$ in region $r$ to sector $j$ in region $r$

$\underset{(n \times n)}{\mathbf{Z}^{rs}} = [z^{rs}_{ij}]$ - monetary transactions matrix between pairs of sectors, from sector $i$ in region $r$ to sector $j$ in region $s$

$\underset{(n \times n)}{\mathbf{Z}^{sr}} = [z^{sr}_{ij}]$ - monetary transactions matrix between pairs of sectors, from sector $i$ in region $s$ to sector $j$ in region $r$

$\underset{(n \times n)}{\mathbf{Z}^{ss}} = [z^{ss}_{ij}]$ - monetary transactions matrix between pairs of sectors, from sector $i$ in region $s$ to sector $j$ in region $s$

$\underset{(n \times 1)}{\mathbf{f}^{r}} = [f^{r}_{i}]$ - total final demand vector for sector $i$'s product in region $r$

$\underset{(n \times 1)}{\mathbf{x}^{r}} = [x^{r}_{i}]$ - total gross output vector of sector $i$'s product in region $r$

$\underset{(n \times n)}{\mathbf{A}^{rr}} = [a^{rr}_{ij}]$ - direct requirements matrix of the quantity of the output from sector $i$ in region $r$ absorbed by sector $j$ per unit of $j$'s total output in region $r$

$\underset{(n \times n)}{\mathbf{A}^{rs}} = [a^{rs}_{ij}]$ - direct requirements matrix of the quantity of the output from sector $i$ in region $r$ absorbed by sector $j$ per unit of $j$'s total output in region $s$

$\underset{(n \times n)}{\mathbf{A}^{sr}} = [a^{sr}_{ij}]$ - direct requirements matrix of the quantity of the output from sector $i$ in region $s$ absorbed by sector $j$ per unit of $j$'s total output in region $r$

$\underset{(n \times n)}{\mathbf{A}^{ss}} = [a^{ss}_{ij}]$ - direct requirements matrix of the quantity of the output from sector $i$ in region $s$ absorbed by sector $j$ per unit of $j$'s total output in region $s$

$\hat{a}^{rr}_{ij} = (\gamma^{r}_{ij}) (a^{n}_{ij})$ - estimate of regional input coefficient from national technical coefficient, where $\gamma^{r}_{ij} = (\alpha^{r}_{ij}) (\beta^{r}_{ij})$

Let $\hat{a}^{r}_{ij} = (\alpha^{r}_{ij}) (a^{n}_{ij})$ - estimate of regional technical coefficient from national technical coefficient, where $\alpha^{r}_{ij} \geq 0$

Let $\hat{a}^{rr}_{ij} = (\beta^{r}_{ij}) (a^{r}_{ij})$ - estimate of regional input coefficient from the regional technical coefficient, where ($0 \leq \beta^{r}_{ij} \leq 1$)

Note $a^{r}_{ij} \equiv a^{n}_{ij}$ if region $r$ and national production recipes are identical

Let $\beta^{r}_{ij} = p^{r}_{i}$ if each regional purchaser, $j$, of input $i$ buys the same proportion of those inputs from within the region, where $p^{r}_{i}$ - the ratio of total regional output, less exports, of sector $i$, to the total output, less exports, plus imports, of sector $i$, and $p^{r}_{i} = 1$ when none of good $i$ is imported


**Commodity/Industry Framework**

Assume that the economy consists of industries, $i$ that use commodities, $c$ to make commodities, $c$

$\underset{(n \times 1)}{\mathbf{x}} = [x_{j}]$ - *total gross industry output* of industry $j$

$\underset{(m \times 1)}{\mathbf{q}} = [q_{i}]$ - *total gross commodity output* of commodity $i$

$\underset{(n \times 1)}{\mathbf{v}} = [v_{j}]$ - *industry value added* by industry $j$

$\underset{(m \times 1)}{\mathbf{e}} = [e_{i}]$ - *commodity final demand* of commodity $i$

$\underset{(c \times i)}{\mathbf{U}} = [u_{ij}]$ - the *Use matrix* of the value of purchases of commodity $i$ by industry $j$, intermediate sales of a commodity to an industry or intermediate purchases of a commodity by an industry

The accounting identities are $\mathbf{q} = \mathbf{Ui} + \mathbf{e}$ and $\mathbf{x'} = \mathbf{i'U} + \mathbf{v'}$

$\underset{(c \times i)}{\mathbf{B}}= \mathbf{U\hat{x}}^{-1} \Rightarrow [b_{ij}] = [u_{ij} / x_{j}]$ - the value of commodity $i$'s input per dollar's worth of industry $j$'s output, the commodity/industry parallel to the technical coefficients matrix

$\underset{(i \times c)}{\mathbf{V}} = [v_{ij}]$ - the *Make matrix* of the value of the output of commodity $j$ that is produced by industry $i$

$\underset{(c \times i)}{\mathbf{V^{'}}}$ - the *Supply matrix* is the transpose of the Make matrix

The accounting identities are $\mathbf{x} = \mathbf{Vi}$ and $\mathbf{q'} = \mathbf{i'V}$ or $\mathbf{q} = \mathbf{V'i}$

$\underset{(c \times i)}{\mathbf{C}} = \mathbf{V'\hat{x}}^{-1}$ - the *Commodity Composition of Industry Outputs* is the fraction of total industry $i$ output that is in the form of commodity $j$

$\underset{(i \times c)}{\mathbf{D}} = \mathbf{V\hat{q}}^{-1}$ - the *Industry Source of Commodity Outputs* is the fraction of total commodity $j$ output that was produced by industry $i$


$\underset{(i \times i)}{\mathbf{A}_{C}}  = \mathbf{C}^{-1}\mathbf{B}$ - the commodity technology model of industry inputs per dollar’s worth of industry output

$\underset{(i \times i)}{\mathbf{A}_{I}}  = \mathbf{D}\mathbf{B}$ - the industry technology model of industry inputs per dollar’s worth of industry output

$\underset{(c \times c)}{\mathbf{A}_{C}}  = \mathbf{B}\mathbf{C}^{-1}$ - the commodity technology model of commodity inputs per dollar’s worth of commodity output

$\underset{(c \times c)}{\mathbf{A}_{I}}  = \mathbf{B}\mathbf{D}$  - the industry technology model of commodity inputs per dollar’s worth of commodity output



$\underset{(c \times c)}{\mathbf{L}_{I}}  = \left(\mathbf{I} - \mathbf{BD}\right)^{-1}$ - industry technology commodity-by-commodity total requirements commodity-demand driven model

$\underset{(c \times c)}{\mathbf{L}_{C}}  =  \left(\mathbf{I} - \mathbf{BC^{-1}}\right)^{-1}$ - commodity technology commodity-by-commodity total requirements commodity-demand driven model

$\underset{(i \times c)}{\mathbf{L}_{I}}  = \mathbf{D}\left(\mathbf{I} - \mathbf{BD}\right)^{-1}$ - industry technology industry-by-commodity total requirements commodity-demand driven model

$\underset{(i \times c)}{\mathbf{L}_{C}}  = \mathbf{C}^{-1}(\mathbf{I} - \mathbf{BC}^{-1})^{-1}$ - commodity technology industry-by-commodity total requirements commodity-demand driven model

$\underset{(i \times i)}{\mathbf{L}_{I}}  = \left(\mathbf{I} - \mathbf{DB}\right)^{-1}$ - industry technology industry-by-industry total requirements industry-demand driven model

$\underset{(i \times i)}{\mathbf{L}_{C}}  =  \left(\mathbf{I} - \mathbf{C^{-1}B}\right)^{-1}$ - commodity technology industry-by-industry total requirements industry-demand driven model

$\underset{(c \times i)}{\mathbf{L}_{I}}  = \mathbf{D}^{-1}\left(\mathbf{I} - \mathbf{DB}\right)^{-1}$ - industry technology commodity-by-industry total requirements industry-demand driven model

$\underset{(c \times i)}{\mathbf{L}_{C}}  = \mathbf{C}(\mathbf{I} - \mathbf{C}^{-1}\mathbf{B})^{-1}$ - commodity technology commodity-by-industry total requirements industry-demand driven model


**RAS Framework**

$\mathbf{A^{n}}$ - national input--output table

$\mathbf{A^{r}}$ - regional table to be estimated

$\mathbf{x^{r}}$ - regional total gross outputs

$\mathbf{u^{r}}$ - regional total intermediate sales

$\mathbf{v^{r}}$ - regional total intermediate purchases

Step 1: Assume $\mathbf{A^{r}} = \mathbf{A^{r}}$ such that $\mathbf{Z^{0}} = \mathbf{A^{n}\hat{x}^{r}}$, where zero superscript denotes the base iteration

Step 2: Ask does $\mathbf{Z^{0}i} = \mathbf{u^{r}}$ and $\mathbf{iZ^{0}} = \mathbf{v^{r}}$? 
If yes to both, then $\mathbf{Z^{0}} = \mathbf{Z^{r}}$ and $\mathbf{A^{n}} = \mathbf{A^{r}}$
If no to either, then $\mathbf{A^{1}} = \mathbf{\hat{r}^{1}A^{n}}$, where $\mathbf{\hat{r}^{1}} = [\mathbf{\hat{u}^{r}}](\mathbf{\hat{Z}^{0}i})^{-1}$ and $\mathbf{u^{r}} = \mathbf{Z^{1}i} = [\mathbf{\hat{r}^{1}A^{n}\hat{x}^{r}}]\mathbf{i}$

Step 3: Ask does $\mathbf{iZ^{1}} = \mathbf{v^{r}}$? 
If yes, then $\mathbf{Z^{1}} = \mathbf{Z^{r}}$ and $\mathbf{Z^{1}\hat{x}^{r}} = \mathbf{A^{r}}$
If no, then $\mathbf{A^{2}} = \mathbf{A^{1}\hat{s}^{1}}$, where $\mathbf{\hat{s}^{1}} = [\mathbf{\hat{v}^{r}}](\mathbf{iZ^{1}})^{-1}$ and $\mathbf{\hat{v}^{r}} = (\mathbf{Z^{2}})'\mathbf{i} = [\mathbf{A^{2}\hat{x}^{r}}]'\mathbf{i}$

Step 4: Specify a value $\epsilon$ such that $[|\mathbf{u^{r}} - \mathbf{u^{t}}|]$ and $[|\mathbf{v^{r}} - \mathbf{v^{t}}|]$ are no more than $\epsilon$ 


**Gravity Framework**

$x^{r \cdot}_{i}$ - the "supply pool" of good $i$ in region $r$

$x^{\cdot s}_{i}$ - the "demand pool" of good $i$ in region $s$

$x^{\cdot \cdot}_{i}$ - the total production of commodity $i$ in the system

$Q^{rs}_{i}$ - the measure of "impedance" between region $r$ and region $s$, assuming $Q^{rs}_{i} > 0$

$z^{rs}_{i} = \frac{x^{r \cdot}_{i}x^{\cdot s}_{i}} {x^{\cdot \cdot}_{i}} Q^{rs}_{i}$ - gravity estimate of the dollar flow of goods from sector $i$ in region $r$ to sector $j$ in region $s$

**rurec equations**

$\mathbf{NID} = \text{arg max}(Regional Commodity Factor Demand - Regional Gross Commodity Output, 0)$ - import needs by region
$\mathbf{NIS} = \text{arg max}(Regional Gross Commodity Output - Regional Commodity Factor Demand, 0)$ - export excess by region

$\mathbf{A} = \mathbf{i'}\min\{\text{NID}^{r}, \textbf{NIS} \}~ \forall ~ r$ - Nominal Absorption matrix

$\mathbf{\alpha} = \mathbf{i'}\min\{\text{NID}^{r}, \textbf{NIS} \} / \text{NIS}^{r} ~ \forall ~ r$ - Normalized Absorption matrix

$sum(Regional Commodity Factor Demand)/ sum(Regional Commodity Gross Output)$ - National "Factor Ratio" is the proportion of FinalDemand allocated to intermediate use


**Absorption Potential Matching (alpha max)**

ECA (Economic Catchment Area) Matching (based on row-wise maximum Absorption with a non-zero isolation threshold minimum): 
  row max < threshold → Isolated (ECA match = Self Match)
    (no one imports enough of what you have available as positive Final Demand)
    
  row max > threshold → Cluster Source (ECA match = rowMax column county)
    (at least one county could import your positive Final Demand given its NID)
    (Matched to county that could import more than any other county what you have available as positive Final Demand)
    
  row max > threshold, but also a sink (rowMax county) for another county → Cluster Sink (ECA match = Self Match)
    (at least one county could import your positive Final Demand, but you are also the max import sink for at least one other county)
    
  row max < threshold, but also a sink (rowMax county) for another county → Isolated, Cluster Sink (ECA match = Self Match)
    (no one imports enough of what you have available as positive Final Demand, but you are also the max import sink for at least one other county)
    

# Methods

$\mathbf{U}$ = BEA Use matrix (c-by-i) i.e., intermediate uses of commodities $c$ by industries $i$

$\mathbf{V'}$ = BEA Supply matrix (c-by-i) i.e., total output of commodities $c$ by industries $i$

$\mathbf{x}$ = BEA Total Gross Industry Output vector (1-by-i) = national-level output for each industry $i$ (see Use table T018 or Supply table T017)

$\mathbf{q}$ = BEA Total Gross Commodity Output vector (c-by-1) = national-level output for each commodity $c$ (see Supply table T007)

$payroll$ = CBP County Industry Payroll matrix (i-by-r) = annual payroll for each industry $i$ in each county/region $r$


$ps =  (payroll \cdot \mathbf{i})'{\hat{x}}^{-1}$ = payroll's share of (national) gross output vector (1-by-i)

$\mathbf{\tilde{x}} = {\widehat{ps}}^{-1} \cdot payroll$ = Gross Industry Output by region matrix (i-by-r)

$\mathbf{B} = \mathbf{U\hat{x}}^{-1}$ = Commodity/Industry Technical Coefficients matrix (c-by-i)

$\mathbf{B\tilde{x}}$ = Commodity Factor Demand matrix (c-by-r)

$\mathbf{D} = \mathbf{V\hat{q}}^{-1}$ = Industry Source of Commodity Outputs matrix (i-by-c)

$\mathbf{DB}$ = Industry Technology Technological Coefficients matrix (i-by-i)

$\mathbf{C} = \mathbf{V'\hat{x}}^{-1}$ = Commodity Composition of Industry Outputs matrix (c-by-i)

$\mathbf{C\tilde{x}}$ = Gross Commodity Output by region matrix (c-by-r)

$cfr = (\widehat{\mathbf{B\tilde{x}i}} \cdot \widehat{\mathbf{C\tilde{x}i}})\mathbf{i}$  = Commodity Factor Ratio vector (c-by-1)

$\widehat{cfr}  \cdot \mathbf{C\tilde{x}}$ = Commodity Factor Supply by region matrix (c-by-r)

$\mathbf{DB\tilde{x}}$ = Industry Factor Demand by region matrix (i-by-r)

$ifr = (\widehat{\mathbf{DB\tilde{x}i}} \cdot \widehat{\mathbf{\tilde{x}i}})\mathbf{i}$  = Industry Factor Ratio vector (i-by-1)

$\widehat{ifr} \cdot \mathbf{\tilde{x}}$ = Industry Factor Supply by region matrix (i-by-r)


# RAS Trade Flows Sector

```{r, include = FALSE eval = FALSE}
#benchmarking effect of impedance on RAS
cbp_year = "2012"
ilevel = "det"

fs <- industry_factor_supply_tidy_matrix(cbp_year = cbp_year, ilevel = ilevel)
fd <- industry_factor_demand_tidy_matrix(cbp_year = cbp_year, ilevel = ilevel)

system.time(
  rx1 <- ras_trade_lists(factor_supply = fs, factor_demand = fd)
  )

system.time(
  test <- ras_trade_listsx(factor_supply = fs, factor_demand = fd)
  )

i = 1

impedance_mat <- dprox_mat(tiger_year = year2tiger(cbp_year),
                    boundary_limit = miles2meters(200))
    diag(impedance_mat) <- 1
impedance_mat =  gaus_impedance_mat(tiger_year = year2tiger(cbp_year), 
                                    rms_width = miles2meters(200))
sprintf("%.64f", impedance_mat[1,2])


x0 = (t(fs[i, , drop=F]) %*% fd[i, , drop=F])

system.time(
  r1 <- ras_trade_flows(x0 = x0,
                        rs1 = fs[i, , drop=F], 
                        cs1 = fd[i, , drop=F],
                        verbose = TRUE,
                        maxiter = 3)
  )

x0 = (t(fs[i, , drop=F]) %*% fd[i, , drop=F]) * (impedance_mat[colnames(fs), colnames(fd)])

system.time(
  rx <- ras_trade_flows(x0 = x0,
                        rs1 = fs[i, , drop=F], 
                        cs1 = fd[i, , drop=F],
                        verbose = TRUE,
                        maxiter = 3)
  )


  y <- intersect(
    names(which(!is.na(rowSums(fd)) & 
                !rowSums(fd) == 0 )), 
    names(which(!is.na(rowSums(fs)) & 
                !rowSums(fs) == 0 ))
    )

df <- lapply(file.path(find_rstudio_root_file(), "data", "robjs", "temp", y), readRDS)
names(df) <- y

```


## Sector level, industries, xcross haul, no impedance
```{r}

cbp_year = "2012"
ilevel = "sec"
industryflow = TRUE
impedance_mat = NULL
#unique(ilevel_concord(ilevel)[1])
subsectors = NULL
impedance_call = NULL
crosshaul = TRUE

df <- load_tradeflows(cbp_year = cbp_year,
                      ilevel = ilevel,
                      industryflow = industryflow,
                      impedance_mat = impedance_mat,
                      subsectors = subsectors, 
                      impedance_call = impedance_call,
                      crosshaul = crosshaul)
```


```{r}
#Eigenvector centrality scores correspond to the values of the first eigenvector of the graph adjacency matrix; these scores may, in turn, be interpreted as arising from a reciprocal process in which the centrality of each actor is proportional to the sum of the centralities of those actors to whom he or she is connected. In general, vertices with high eigenvector centralities are those which are connected to many other vertices which are, in turn, connected to many others (and so on). This implies that the largest values will be obtained by individuals in large cliques (or high-density substructures.
metric = c("eigen_centrality", 
           "alpha_centrality", 
           "closeness", 
           "harmonic_centrality", 
           "hub_score", 
           "authority_score", 
           "page_rank", 
           "strength")[1]
df %>% Reduce('+', .) %>% sna_value_map(metric = metric)
```


```{r}
#Bonacich alpha centrality scores of network positions
metric = c("eigen_centrality", 
           "alpha_centrality", 
           "closeness", 
           "harmonic_centrality", 
           "hub_score", 
           "authority_score", 
           "page_rank", 
           "strength")[2]
df %>% Reduce('+', .) %>% sna_value_map(metric = metric)
```

```{r}
#Closeness centrality measures how many steps is required to access every other vertex from a given vertex.
metric = c("eigen_centrality", 
           "alpha_centrality", 
           "closeness", 
           "harmonic_centrality", 
           "hub_score", 
           "authority_score", 
           "page_rank", 
           "strength")[3]
df %>% Reduce('+', .) %>% sna_value_map(metric = metric)
```

```{r}
#The harmonic centrality of a vertex is the mean inverse distance to all other vertices.
metric = c("eigen_centrality", 
           "alpha_centrality", 
           "closeness", 
           "harmonic_centrality", 
           "hub_score", 
           "authority_score", 
           "page_rank", 
           "strength")[4]
df %>% Reduce('+', .) %>% sna_value_map(metric = metric)
```

```{r}
#The hub scores of the vertices are defined as the principal eigenvector of At(A) where A is the adjacency matrix of the graph.
metric = c("eigen_centrality", 
           "alpha_centrality", 
           "closeness", 
           "harmonic_centrality", 
           "hub_score", 
           "authority_score", 
           "page_rank", 
           "strength")[5]
df %>% Reduce('+', .) %>% sna_value_map(metric = metric)
```

```{r}
#The authority scores of the vertices are defined as the principal eigenvector of t(A)A where A is the adjacency matrix of the graph.
metric = c("eigen_centrality", 
           "alpha_centrality", 
           "closeness", 
           "harmonic_centrality", 
           "hub_score", 
           "authority_score", 
           "page_rank", 
           "strength")[6]
df %>% Reduce('+', .) %>% sna_value_map(metric = metric)
```

```{r}
#Calculates the Google PageRank for the specified vertices.
metric = c("eigen_centrality", 
           "alpha_centrality", 
           "closeness", 
           "harmonic_centrality", 
           "hub_score", 
           "authority_score", 
           "page_rank", 
           "strength")[7]
df %>% Reduce('+', .) %>% sna_value_map(metric = metric)
```

```{r}
#Summing up the edge weights of the adjacent edges for each vertex.
metric = c("eigen_centrality", 
           "alpha_centrality", 
           "closeness", 
           "harmonic_centrality", 
           "hub_score", 
           "authority_score", 
           "page_rank", 
           "strength")[8]
df %>% Reduce('+', .) %>% sna_value_map(metric = metric)
```


```{r}
sector = NULL
inbound2outbound_map(Reduce('+', df), sector = sector)
```


```{r}
sector = NULL
inbound2outbound_map(Reduce('+', df), sector = sector, fill = "out2in" )
```

```{r}
sector = NULL
central_place = params$county_fips
export_flows = F
censor_scale_lowerbound = 1

place_trade_map(df = Reduce('+', df),
                sector = sector,
                central_place = central_place,
                export_flows = export_flows,
                censor_scale_lowerbound = censor_scale_lowerbound)

```

```{r}
sector = NULL
central_place = params$county_fips
export_flows = T
censor_scale_lowerbound = 1

place_trade_map(df = Reduce('+', df),
                sector = sector,
                central_place = central_place,
                export_flows = export_flows,
                censor_scale_lowerbound = censor_scale_lowerbound)

```

```{r}
sector = "11"
central_place = params$county_fips
export_flows = F
censor_scale_lowerbound = 1

place_trade_map(df = df,
                sector = sector,
                central_place = central_place,
                export_flows = export_flows,
                censor_scale_lowerbound = censor_scale_lowerbound)

```

## Sector level, industries, no cross haul, no impedance
```{r}

cbp_year = "2012"
ilevel = "sec"
industryflow = TRUE
impedance_mat = NULL
#unique(ilevel_concord(ilevel)[1])
subsectors = NULL
impedance_call = NULL
crosshaul = F

df <- load_tradeflows(cbp_year = cbp_year,
                      ilevel = ilevel,
                      industryflow = industryflow,
                      impedance_mat = impedance_mat,
                      subsectors = subsectors, 
                      impedance_call = impedance_call,
                      crosshaul = crosshaul)
```


```{r}
sector = NULL
inbound2outbound_map(Reduce('+', df), sector = sector, fill = "out2in" )
```

```{r}
sector = NULL
central_place = params$county_fips
export_flows = F
censor_scale_lowerbound = 1

place_trade_map(df = Reduce('+', df),
                sector = sector,
                central_place = central_place,
                export_flows = export_flows,
                censor_scale_lowerbound = censor_scale_lowerbound)

```

```{r}
sector = NULL
central_place = params$county_fips
export_flows = T
censor_scale_lowerbound = 1

place_trade_map(df = Reduce('+', df),
                sector = sector,
                central_place = central_place,
                export_flows = export_flows,
                censor_scale_lowerbound = censor_scale_lowerbound)

```

## Sector level, industries, xcross haul, gauss impedance
```{r}

cbp_year = "2012"
ilevel = "sec"
industryflow = T
impedance_mat = gaus_impedance_mat(tiger_year = year2tiger(cbp_year), 
                                    rms_width = miles2meters(200))
#unique(ilevel_concord(ilevel)[1])
subsectors = NULL
impedance_call = "gaus200"
crosshaul = T

df <- load_tradeflows(cbp_year = cbp_year,
                      ilevel = ilevel,
                      industryflow = industryflow,
                      impedance_mat = impedance_mat,
                      subsectors = subsectors, 
                      impedance_call = impedance_call,
                      crosshaul = crosshaul)



```
```{r}
#Eigenvector centrality scores correspond to the values of the first eigenvector of the graph adjacency matrix; these scores may, in turn, be interpreted as arising from a reciprocal process in which the centrality of each actor is proportional to the sum of the centralities of those actors to whom he or she is connected. In general, vertices with high eigenvector centralities are those which are connected to many other vertices which are, in turn, connected to many others (and so on). This implies that the largest values will be obtained by individuals in large cliques (or high-density substructures.
metric = c("eigen_centrality", 
           "alpha_centrality", 
           "closeness", 
           "harmonic_centrality", 
           "hub_score", 
           "authority_score", 
           "page_rank", 
           "strength")[1]
df %>% Reduce('+', .) %>% sna_value_map(metric = metric, scale = T)
```

```{r}
df %>% Reduce('+', .) %>% sna_value_map(metric = metric, normalize = "row", scale = T)
```

```{r}
df %>% Reduce('+', .) %>% sna_value_map(metric = metric, normalize = "column", scale = T)
```





```{r}
sector = NULL
inbound2outbound_map(Reduce('+', df), sector = sector, fill = "out2in" )
```


```{r}
sector = "11"
central_place = params$county_fips
export_flows = F
censor_scale_lowerbound = 1

place_trade_map(df = df,
                sector = sector,
                central_place = central_place,
                export_flows = export_flows,
                censor_scale_lowerbound = censor_scale_lowerbound)

```

```{r}
sector = "11"
central_place = params$county_fips
export_flows = T
censor_scale_lowerbound = 1

place_trade_map(df = df,
                sector = sector,
                central_place = central_place,
                export_flows = export_flows,
                censor_scale_lowerbound = censor_scale_lowerbound)

```

```{r}
sector = NULL
central_place = params$county_fips
export_flows = F
censor_scale_lowerbound = 1

place_trade_map(df = Reduce('+', df),
                sector = sector,
                central_place = central_place,
                export_flows = export_flows,
                censor_scale_lowerbound = censor_scale_lowerbound)

```

```{r}
sector = NULL
central_place = params$county_fips
export_flows = T
censor_scale_lowerbound = 1

place_trade_map(df = Reduce('+', df),
                sector = sector,
                central_place = central_place,
                export_flows = export_flows,
                censor_scale_lowerbound = censor_scale_lowerbound)

```

## Sector level, industries, no cross haul, gauss impedance
```{r}

cbp_year = "2012"
ilevel = "sec"
industryflow = T
impedance_mat = gaus_impedance_mat(tiger_year = year2tiger(cbp_year), 
                                    rms_width = miles2meters(200))
#unique(ilevel_concord(ilevel)[1])
subsectors = NULL
impedance_call = "gaus200"
crosshaul = F

df <- load_tradeflows(cbp_year = cbp_year,
                      ilevel = ilevel,
                      industryflow = industryflow,
                      impedance_mat = impedance_mat,
                      subsectors = subsectors, 
                      impedance_call = impedance_call,
                      crosshaul = crosshaul)



```

```{r}
sector = NULL
inbound2outbound_map(Reduce('+', df), sector = sector, fill = "out2in" )
```

```{r}
sector = NULL
central_place = params$county_fips
export_flows = F
censor_scale_lowerbound = 1

place_trade_map(df = Reduce('+', df),
                sector = sector,
                central_place = central_place,
                export_flows = export_flows,
                censor_scale_lowerbound = censor_scale_lowerbound)

```

```{r}
sector = NULL
central_place = params$county_fips
export_flows = T
censor_scale_lowerbound = 1

place_trade_map(df = Reduce('+', df),
                sector = sector,
                central_place = central_place,
                export_flows = export_flows,
                censor_scale_lowerbound = censor_scale_lowerbound)

```

# RAS Trade Flows Detail

## Detail level, industries, xcross haul, no impedance
```{r}

cbp_year = "2012"
ilevel = "det"
industryflow = T
impedance_mat = NULL
#unique(ilevel_concord(ilevel)[1])
subsectors = NULL
impedance_call = NULL
crosshaul = TRUE

df <- load_tradeflows(cbp_year = cbp_year,
                      ilevel = ilevel,
                      industryflow = industryflow,
                      impedance_mat = impedance_mat,
                      subsectors = subsectors, 
                      impedance_call = impedance_call,
                      crosshaul = crosshaul)
```

```{r}
sector = NULL
inbound2outbound_map(Reduce('+', df), sector = sector)
```

```{r}
sector = NULL
inbound2outbound_map(Reduce('+', df), sector = sector, fill = "out2in" )
```

```{r}
sector = NULL
central_place = params$county_fips
export_flows = F
censor_scale_lowerbound = 1

place_trade_map(df = Reduce('+', df),
                sector = sector,
                central_place = central_place,
                export_flows = export_flows,
                censor_scale_lowerbound = censor_scale_lowerbound)

```

```{r}
sector = NULL
central_place = params$county_fips
export_flows = T
censor_scale_lowerbound = 1

place_trade_map(df = Reduce('+', df),
                sector = sector,
                central_place = central_place,
                export_flows = export_flows,
                censor_scale_lowerbound = censor_scale_lowerbound)

```


## Detail level, industries, no cross haul, no impedance
```{r}

cbp_year = "2012"
ilevel = "det"
industryflow = T
impedance_mat = NULL
#unique(ilevel_concord(ilevel)[1])
subsectors = NULL
impedance_call = NULL
crosshaul = F

df <- load_tradeflows(cbp_year = cbp_year,
                      ilevel = ilevel,
                      industryflow = industryflow,
                      impedance_mat = impedance_mat,
                      subsectors = subsectors, 
                      impedance_call = impedance_call,
                      crosshaul = crosshaul)
```

```{r}
sector = NULL
inbound2outbound_map(Reduce('+', df), sector = sector, fill = "out2in" )
```

```{r}
sector = NULL
central_place = params$county_fips
export_flows = F
censor_scale_lowerbound = 1

place_trade_map(df = Reduce('+', df),
                sector = sector,
                central_place = central_place,
                export_flows = export_flows,
                censor_scale_lowerbound = censor_scale_lowerbound)

```

```{r}
sector = NULL
central_place = params$county_fips
export_flows = T
censor_scale_lowerbound = 1

place_trade_map(df = Reduce('+', df),
                sector = sector,
                central_place = central_place,
                export_flows = export_flows,
                censor_scale_lowerbound = censor_scale_lowerbound)

```

## Detail level, industries, xcross haul, gauss impedance
```{r}

cbp_year = "2012"
ilevel = "det"
industryflow = T
impedance_mat = gaus_impedance_mat(tiger_year = year2tiger(cbp_year), 
                                    rms_width = miles2meters(200))
#unique(ilevel_concord(ilevel)[1])
subsectors = NULL
impedance_call = "gaus200"
crosshaul = T

df <- load_tradeflows(cbp_year = cbp_year,
                      ilevel = ilevel,
                      industryflow = industryflow,
                      impedance_mat = impedance_mat,
                      subsectors = subsectors, 
                      impedance_call = impedance_call,
                      crosshaul = crosshaul)



```

```{r}
sector = NULL
inbound2outbound_map(Reduce('+', df), sector = sector, fill = "out2in" )
```

```{r}
sector = NULL
central_place = params$county_fips
export_flows = F
censor_scale_lowerbound = 1

place_trade_map(df = Reduce('+', df),
                sector = sector,
                central_place = central_place,
                export_flows = export_flows,
                censor_scale_lowerbound = censor_scale_lowerbound)

```

```{r}
sector = NULL
central_place = params$county_fips
export_flows = T
censor_scale_lowerbound = 1

place_trade_map(df = Reduce('+', df),
                sector = sector,
                central_place = central_place,
                export_flows = export_flows,
                censor_scale_lowerbound = censor_scale_lowerbound)

```

## Detail level, industries, no cross haul, gauss impedance
```{r}

cbp_year = "2012"
ilevel = "det"
industryflow = T
impedance_mat = gaus_impedance_mat(tiger_year = year2tiger(cbp_year), 
                                    rms_width = miles2meters(200))
#unique(ilevel_concord(ilevel)[1])
subsectors = NULL
impedance_call = "gaus200"
crosshaul = F

df <- load_tradeflows(cbp_year = cbp_year,
                      ilevel = ilevel,
                      industryflow = industryflow,
                      impedance_mat = impedance_mat,
                      subsectors = subsectors, 
                      impedance_call = impedance_call,
                      crosshaul = crosshaul)



```

```{r}
sector = NULL
inbound2outbound_map(Reduce('+', df), sector = sector, fill = "out2in" )
```



```{r}
sector = NULL
central_place = params$county_fips
export_flows = F
censor_scale_lowerbound = 1

place_trade_map(df = Reduce('+', df),
                sector = sector,
                central_place = central_place,
                export_flows = export_flows,
                censor_scale_lowerbound = censor_scale_lowerbound)

```

```{r}
sector = NULL
central_place = params$county_fips
export_flows = T
censor_scale_lowerbound = 1

place_trade_map(df = Reduce('+', df),
                sector = sector,
                central_place = central_place,
                export_flows = export_flows,
                censor_scale_lowerbound = censor_scale_lowerbound)

```


```{r}
geog_year = "2013"
inner_join(call_geog(geog_year), 
           absorption_maximum_match(Reduce('+', df)), 
           by = "place") %>% clustmember_map()
```

```{r}
inner_join(call_geog(geog_year), 
           absorption_maximum_match(Reduce('+', df)), 
           by = "place") %>% aqual_map()
```

```{r}
# 
# temp <- call_imputed_tradeflows(cbp_year = "2012",
#                                 ilevel = "det",
#                                 industryflow = T,
#                                 impedance_mat = NULL,
#                                 subsectors = unique(ilevel_concord("det")[1])[1:13,],
#                                 verbose = TRUE)
# 
# inbound2outbound_map(temp)
```




```{r}
impedance_distribution_map(decay_function = "gaus", 
                           rms_width = 200,
                           year = "2012",
                           central_place = params$county_fips)
```

```{r}
sector = "11"
central_place = params$county_fips
export_flows = T
censor_scale_lowerbound = 1

place_trade_map(df = df,
                sector = sector,
                central_place = central_place,
                export_flows = export_flows,
                censor_scale_lowerbound = censor_scale_lowerbound)

```

```{r}
sector = "11"
central_place = params$county_fips
export_flows = F
censor_scale_lowerbound = 1

place_trade_map(df = df,
                sector = sector,
                central_place = central_place,
                export_flows = export_flows,
                censor_scale_lowerbound = censor_scale_lowerbound)

```



ECA clusters: sink and source membership tally 
```{r}
geog_year = "2013"
inner_join(call_geog(geog_year), 
           absorption_maximum_match(Reduce('+', df)), 
           by = "place") %>% clustmember_map()
```


ECA clusters: qualitative and clickable
```{r}
inner_join(call_geog(geog_year), 
           absorption_maximum_match(Reduce('+', df)), 
           by = "place") %>% aqual_map()
```



# RAS Trade Flows Sector

The preferred globally balanced industry specific county-to-county potential trade flow permits all places to trade all goods to each other. Given CBP payroll and AgCensus output data we derive county specific factor demand and factor supply using BEA technological requirements coefficients. The RAS balancing procedure imputes a globally balanced county-to-county trade flow potential matrix within a prespecified error and iteration tolerance. The final derived trade flow potential matrix is sensitive to initial starting conditions which are established by a seemingly arbitrary and infinite set of trade impedance distance functions which serve as a proxy for transportation costs. The current method uses a Gaussian impedance distance functional form. For each industry the smallest Gaussian RMS which satisfied the error and iteration tolerance is selected from the infinite set of trade impedance distance functions to derive the trade flow potential matrix. 


```{r}
df <- readRDS(file.path(find_rstudio_root_file(), "data", "robjs", "trade_base", "tally_detail_2012_industry_gaus_by25"))

imped_dist <- call_industry_concordance() %>% 
  select("SECTOR", "DETAIL") %>% 
  setNames(c("group", "sector")) %>% 
  .[!duplicated(.), ] %>% 
  inner_join(readRDS(file.path(find_rstudio_root_file(), "data", "robjs", "trade_base", "tally_detail_2012_industry_gaus_by25")), by = "sector")

imped_dist$group <- factor(imped_dist$group, levels = c(unique(imped_dist$group)), ordered = TRUE)
```


Summary of Gauss impedance RMS distances by sector
```{r}
# tapply(imped_dist$impedance, imped_dist$group, summary)
```

```{r}
# ggplot(imped_dist, aes(x = impedance)) + 
#   geom_density() +
#   labs(x = "Gauss Impedance RMS Distance", y = "Density")
```

```{r}
# ggplot(imped_dist, aes(impedance, fill = group)) +
#   geom_density(position = "stack") +
#   labs(x = "Gauss Impedance RMS Distance", y = "Density", fill = "Sector") 
```

Given a set of globally balanced detail-level industry specific county-to-county potential trade flows, we aggregate the 365 detail-level industries into their respective 14 sector-level industry groups. The distribution and density of each industry varies from a 75 to 375 Gaussian RMS width. The lower the RMS the more cost an industry could endure and still balance its tradeflows. 

```{r}
ggplot(imped_dist, aes(impedance, after_stat(count), fill = group)) +
  geom_density(position = "stack") +
  labs(x = "Gauss Impedance RMS Distance", y = "Count", fill = "Sector") 
```



```{r}
# ggplot(imped_dist, aes(impedance, stat(count), fill = group)) +
#   geom_density(position = "fill") +
#   labs(x = "Gauss Impedance RMS Distance", y = "Count", fill = "Sector") 
```



```{r}
ggplot(imped_dist, aes(impedance, fill = group)) +
  geom_bar() +
  labs(x = "Gauss Impedance RMS Distance", y = "Count", fill = "Sector") 
```



```{r}
ggplot(imped_dist, aes(x = impedance, y = group, fill = group)) + 
  stat_density_ridges(rel_min_height = 0.005, linetype = 1, scale = 1.5, quantile_lines = TRUE, alpha = 0.85, quantiles = 2) +
  theme(legend.position = "none") +
  labs(x = "Gauss Impedance RMS Distance", y = "Sector Cluster")
```



```{r}
# ggplot(imped_dist, aes(x = impedance, y = group, fill = group)) + 
#   geom_density_ridges(stat = "binline", bins = 13, scale = 0.95, draw_baseline = FALSE) +
#   theme(legend.position = "none") +
#   labs(x = "Gauss Impedance RMS Distance", y = "Sector Cluster")

```



A Gaussian impedance distance functional form with variable RMS has desirable properties as a proxy for transportation costs, namely continuous and nonlinear across space. This allows for all counties to be able to trade among each other while imposing a higher and higher costs for longer and longer trade. However, an RMS width is not directly initiative or interpretable. 

Instead, one might wish to know: What is the maximum distance at which 95% or 90% or 50% of the market still clears? (Given a set of globally balanced detail-level industry specific county-to-county potential trade flows.)

```{r}

dist_mat <- readRDS(file.path(find_rstudio_root_file(), "data", "robjs", "dist_mat"))
 
dis_list <- data.frame()

y <- list.files(file.path(find_rstudio_root_file(), "data", "robjs", "trade_base", "min_dis"))

for(i in y){
  print(paste("Industry:", i))
  df <- readRDS(file.path(find_rstudio_root_file(), "data", "robjs", "trade_base", "min_dis", i))
  sf <- dist_mat[rownames(df), colnames(df)]
  tot_df <- sum(df)
  
  itstep = 50
  flag90 <- FALSE
  flag95 <- FALSE
   for(d in seq(3000, 0, by = -itstep) ){
    #print(paste("Distance Trail:", d))
    sf[sf > miles2meters(d)] <- 0
    x <- df
    x[sf <= 0] <- 0
    if(sum(x, na.rm = T)/tot_df < .50){
      mcd_50 <- d+itstep
      #print(paste(">50% Market Clearing Distance:", d+itstep))
      break
      }
    else if(sum(x, na.rm = T)/tot_df < .90 && !flag90){
      mcd_90 <- d+itstep
      #print(paste(">90% Market Clearing Distance:", d+itstep))
      flag90 <- TRUE
    }
    else if(sum(x, na.rm = T)/tot_df < .95 && !flag95){
      mcd_95 <- d+itstep
      #print(paste(">95% Market Clearing Distance:", d+itstep))
      flag95 <- TRUE
    }
  }
  dis_list <- rbind(dis_list, 
                    data.frame(
                              "sector" = i, 
                              "mcd_95" = mcd_95,
                              "mcd_90" = mcd_90,
                              "mcd_50" = mcd_50))
}
saveRDS(dis_list, file.path(find_rstudio_root_file(), "data", "robjs", "trade_base", "mcd_detail_2012_industry_gaus_by25"))

```

```{r}
df <- readRDS(file.path(find_rstudio_root_file(), "data", "robjs", "trade_base", "mcd_detail_2012_industry_gaus_by25"))

imped_dist <- call_industry_concordance() %>% 
  select("SECTOR", "DETAIL") %>% 
  setNames(c("group", "sector")) %>% 
  .[!duplicated(.), ] %>% 
  inner_join(df, by = "sector")

imped_dist$group <- factor(imped_dist$group, levels = c(unique(imped_dist$group)), ordered = TRUE)
```


```{r}
# tapply(imped_dist$mcd_95, imped_dist$group, summary)
# tapply(imped_dist$mcd_90, imped_dist$group, summary)
# tapply(imped_dist$mcd_50, imped_dist$group, summary)
```


```{r}
ggplot(imped_dist, aes(mcd_95, fill = group)) +
  geom_bar() +
  labs(x = paste0(">", substr(deparse(substitute(mcd_95)), 5, 6), "% Clear Market Distance"), y = "Count", fill = "Sector") 
```

```{r}
ggplot(imped_dist, aes(mcd_90, fill = group)) +
  geom_bar() +
  labs(x = paste0(">", substr(deparse(substitute(mcd_90)), 5, 6), "% Clear Market Distance"), y = "Count", fill = "Sector") 
```

```{r}
ggplot(imped_dist, aes(mcd_50, fill = group)) +
  geom_bar() +
  labs(x = paste0(">", substr(deparse(substitute(mcd_50)), 5, 6), "% Clear Market Distance"), y = "Count", fill = "Sector") 
```

```{r}
ggplot(imped_dist, aes(x = mcd_95, y = group, fill = group)) + 
  stat_density_ridges(rel_min_height = 0.005, linetype = 1, scale = 1.5, quantile_lines = TRUE, alpha = 0.85, quantiles = 2) +
  theme(legend.position = "none") +
  labs(x = paste0(">", substr(deparse(substitute(mcd_95)), 5, 6), "% Clear Market Distance"), y = "Sector Cluster")
```
```{r}
ggplot(imped_dist, aes(x = mcd_90, y = group, fill = group)) + 
  stat_density_ridges(rel_min_height = 0.005, linetype = 1, scale = 1.5, quantile_lines = TRUE, alpha = 0.85, quantiles = 2) +
  theme(legend.position = "none") +
  labs(x = paste0(">", substr(deparse(substitute(mcd_90)), 5, 6), "% Clear Market Distance"), y = "Sector Cluster")
```

```{r}
ggplot(imped_dist, aes(x = mcd_50, y = group, fill = group)) + 
  stat_density_ridges(rel_min_height = 0.005, linetype = 1, scale = 1.5, quantile_lines = TRUE, alpha = 0.85, quantiles = 2) +
  theme(legend.position = "none") +
  labs(x = paste0(">", substr(deparse(substitute(mcd_50)), 5, 6), "% Clear Market Distance"), y = "Sector Cluster")
```

In addition to being continuous and nonlinear across space another desirable property of the Gaussian impedance distance functional form is that global balancing converges faster and within a "smaller" distance over non-continuous alternatives due to many more non-zero cells in the trade potential matrix that give more degrees of freedom. However, these values may be very very small and well below any economically relevant value or any statically meaningful level giving the measurement and suppression error in the raw data. 

An related but alternative question for deriving interpretable distances is therefore to ask: What is the maximum potential trade distance ignoring all imputed trade flows below \$1, \$10, \$100, \$1000, \$10,000, \$100,000, or \$1,000,000? (Given a set of globally balanced detail-level industry specific county-to-county potential trade flows.)


```{r}
dist_mat <- readRDS(file.path(find_rstudio_root_file(), "data", "robjs", "dist_mat"))
 
dis_list <- data.frame()

y <- list.files(file.path(find_rstudio_root_file(), "data", "robjs", "trade_base", "min_dis"))

for(i in y){
  print(paste("Industry:", i))
  df <- readRDS(file.path(find_rstudio_root_file(), "data", "robjs", "trade_base", "min_dis", i))
  
  sf <- dist_mat[rownames(df), colnames(df)]
  sf[df < 0.001] <- 0
  med_1 <- max(sf) %>% meters2miles() %>% round() 
  sf[df < 0.01] <- 0
  med_10 <- max(sf) %>% meters2miles() %>% round() 
  sf[df < 0.1] <- 0
  med_100 <- max(sf) %>% meters2miles() %>% round() 
  sf[df < 1] <- 0
  med_1000 <- max(sf) %>% meters2miles() %>% round() 
  sf[df < 10] <- 0
  med_10000 <- max(sf) %>% meters2miles() %>% round() 
  sf[df < 100] <- 0
  med_100000 <- max(sf) %>% meters2miles() %>% round()
  sf[df < 1000] <- 0
  med_1000000 <- max(sf) %>% meters2miles() %>% round()
  dis_list <- rbind(dis_list, 
                    data.frame(
                              "sector" = i, 
                              "med_1" = med_1,
                              "med_10" = med_10,
                              "med_100" = med_100,
                              "med_1000" = med_1000,
                              "med_10000" = med_10000,
                              "med_100000" = med_100000,
                              "med_1000000" = med_1000000))
}
saveRDS(dis_list, file.path(find_rstudio_root_file(), "data", "robjs", "trade_base", "med_detail_2012_industry_gaus_by25"))


```

```{r}
df <- readRDS(file.path(find_rstudio_root_file(), "data", "robjs", "trade_base", "med_detail_2012_industry_gaus_by25"))

imped_dist <- call_industry_concordance() %>% 
  select("SECTOR", "DETAIL") %>% 
  setNames(c("group", "sector")) %>% 
  .[!duplicated(.), ] %>% 
  inner_join(df, by = "sector")

imped_dist$group <- factor(imped_dist$group, levels = c(unique(imped_dist$group)), ordered = TRUE)
```


```{r}
ggplot(imped_dist, aes(mcd_1, after_stat(count), fill = group)) +
  geom_density(position = "stack") +
  labs(x = paste0("Clear Market Distance >$", substr(deparse(substitute(mcd_1)), 5, nchar(deparse(substitute(mcd_1))))), y = "Count", fill = "Sector") 
```

```{r}
ggplot(imped_dist, aes(mcd_1000, after_stat(count), fill = group)) +
  geom_density(position = "stack") +
  labs(x = paste0("Clear Market Distance >$", substr(deparse(substitute(mcd_1000)), 5, nchar(deparse(substitute(mcd_1000))))), y = "Count", fill = "Sector") 
```


```{r}
ggplot(imped_dist, aes(mcd_1000000, after_stat(count), fill = group)) +
  geom_density(position = "stack") +
  labs(x = paste0("Clear Market Distance >$", substr(deparse(substitute(mcd_1000000)), 5, nchar(deparse(substitute(mcd_1000000))))), y = "Count", fill = "Sector") 
```


```{r}
ggplot(imped_dist, aes(x = mcd_1, y = group, fill = group)) + 
  stat_density_ridges(rel_min_height = 0.005, linetype = 1, scale = 1.5, quantile_lines = TRUE, alpha = 0.85, quantiles = 2) +
  theme(legend.position = "none") +
  labs(x =  paste0("Clear Market Distance >$", substr(deparse(substitute(mcd_1)), 5, nchar(deparse(substitute(mcd_1))))), y = "Sector Cluster")
```

```{r}
ggplot(imped_dist, aes(x = mcd_1000, y = group, fill = group)) + 
  stat_density_ridges(rel_min_height = 0.005, linetype = 1, scale = 1.5, quantile_lines = TRUE, alpha = 0.85, quantiles = 2) +
  theme(legend.position = "none") +
  labs(x =  paste0("Clear Market Distance >$", substr(deparse(substitute(mcd_1000)), 5, nchar(deparse(substitute(mcd_1000))))), y = "Sector Cluster")
```

```{r}
ggplot(imped_dist, aes(x = mcd_1000000, y = group, fill = group)) + 
  stat_density_ridges(rel_min_height = 0.005, linetype = 1, scale = 1.5, quantile_lines = TRUE, alpha = 0.85, quantiles = 2) +
  theme(legend.position = "none") +
  labs(x =  paste0("Clear Market Distance >$", substr(deparse(substitute(mcd_1000000)), 5, nchar(deparse(substitute(mcd_1000000))))), y = "Sector Cluster")
```

:::





