---
title: "connect_grant_examples"
format:
  html:
    self-contained: true
    page-layout: full
    code-fold: true
    code-tools: true
    code_download: yes
editor: visual
---

```{r packages and libraries, include = FALSE}

# Load packages

library(tidyr)
library(geosphere)


```

## Example

```{r}
##From Direct to Total 

Industry_Count <- 3
Toy_Direct_mat <-  matrix(c(0.429,  0.014, 0.086, 
                            0.08,  0.56, 0.24,
                            0.016,  0.392, 0.568), nrow = Industry_Count, byrow = TRUE)

rownames(Toy_Direct_mat) = colnames(Toy_Direct_mat) <- c("Oil", "Wheat", "Bread")

Toy_Total_mat <-  solve(diag(ncol(Toy_Direct_mat)) - Toy_Direct_mat)

```

```{r}
##From Total to Direct 

# Industry_Count <- 3
# Toy_Total_mat <-  matrix(c(1.350,  0.448, 0.624, 
#                             0.329,  1.622, 0.992,
#                             0.325,  0.226, 1.327), nrow = Industry_Count, byrow = TRUE)
# 
# rownames(Toy_Total_mat) = colnames(Toy_Total_mat) <- c("Oil", "Wheat", "Bread")
# 
# 
# Toy_Direct_mat <-  diag(ncol(Toy_Total_mat)) - solve(Toy_Total_mat)

```

"National Industry-by-Industry Total Requirements Table" (BEA): $\mathbf{T}$

```{r}
Toy_Total_mat %>% round(2)
```

"National Industry-by-Industry Direct Requirements Table": $\mathbf{D} = \mathbf{I} - (\mathbf{T})^{-1}$

```{r}
Toy_Direct_mat %>% round(3)

```

"Industry-by-County Output Table" (CBP): $\mathbf{Y}$

```{r}
Region_Count <- 3

Toy_X_mat <-  matrix(c(0, 30, 40, 
                       100, 20,  30,
                       100, 15,  75), nrow = Industry_Count, byrow = TRUE)

rownames(Toy_X_mat) <- c("Oil", "Wheat", "Bread")
colnames(Toy_X_mat) <- c("Albany", "Brown", "Cook")

Toy_X_mat
```

"Industry-by-County Input Needs Table": $\mathbf{D}\mathbf{Y}$

```{r}
Toy_Input_mat <- (Toy_Direct_mat  %*%  Toy_X_mat) 
Toy_Input_mat  %>% round(2)
```

"Net Input Demand Table": $\max \{\mathbf{D}\mathbf{Y} - \mathbf{Y} , 0\}$

```{r}
Toy_Input_mat_imp <- pmax(Toy_Input_mat - Toy_X_mat, 0)
Toy_Input_mat_imp  %>% round(2)
```

"Net Input Supply Table": $\max \{ \mathbf{Y} - \mathbf{D}\mathbf{Y}, 0\}$

```{r}
Toy_Input_mat_exp <- abs(pmin(Toy_Input_mat - Toy_X_mat, 0))
Toy_Input_mat_exp  %>% round(2)
```

County $r$ Absorption matrix: $\mathbf{A}^{r} = \min\{\text{NIE}^{r}, \textbf{NIS} \}$

```{r}

Toy_Absorb <- vector(mode='list', length=ncol(Toy_X_mat))
  names(Toy_Absorb) <- colnames(Toy_X_mat)

for (i in 1:ncol(Toy_X_mat)){
Toy_Absorb[[i]] <- matrix(0, nrow = nrow(Toy_X_mat), ncol = ncol(Toy_X_mat))
 rownames(Toy_Absorb[[i]])  <- rownames(Toy_X_mat)
   colnames(Toy_Absorb[[i]]) <- colnames(Toy_X_mat)
}

  for (i in 1:ncol(Toy_X_mat)){
    for (j in 1:ncol(Toy_X_mat)){
        Toy_Absorb[[i]][,j]  <-   pmin(Toy_Input_mat_exp[,i], Toy_Input_mat_imp[,j])  %>% round(2)
    }
  }

Toy_Absorb  

```

"Total Absorption matrix": $\mathbf{A} = \mathbf{i'}\min\{\text{NIE}^{r}, \textbf{NIS} \}~ \forall ~ r$

```{r}

Toy_Queeg<-  matrix(0, nrow = ncol(Toy_X_mat), ncol = ncol(Toy_X_mat))
 rownames(Toy_Queeg) = colnames(Toy_Queeg) <- colnames(Toy_X_mat)

  for (i in 1:ncol(Toy_X_mat)){
    for (j in 1:ncol(Toy_X_mat)){
        Toy_Queeg[i,j]  <-  rep(c(1), each=ncol(Toy_Total_mat)) %*% pmin(Toy_Input_mat_exp[,i], Toy_Input_mat_imp[,j])
    }
  }


colnames(Toy_Queeg) <- c("Albany", "Brown", "Cook")
Toy_Queeg  %>% round(2)

```

"Normalized Absorption Shares": $\mathbf{\alpha} = \mathbf{i'}\min\{\text{NIE}^{r}, \textbf{NIS} \} / \text{NIE}^{r} ~ \forall ~ r$

```{r}

Toy_Queeg_R<-  matrix(0, nrow = ncol(Toy_X_mat), ncol = ncol(Toy_X_mat))
 rownames(Toy_Queeg_R) = colnames(Toy_Queeg) <- colnames(Toy_X_mat)

  for (i in 1:ncol(Toy_X_mat)){
    for (j in 1:ncol(Toy_X_mat)){
        Toy_Queeg_R[i,j]  <-  (rep(c(1), each=ncol(Toy_Total_mat)) %*% pmin(Toy_Input_mat_exp[,i], Toy_Input_mat_imp[,j])) /
                                    (rep(c(1), each=ncol(Toy_Total_mat)) %*% Toy_Input_mat_exp[,i] )
        

    }
  }


colnames(Toy_Queeg_R) <- c("Albany", "Brown", "Cook")
Toy_Queeg_R  %>% round(2)

```

"Geographical Impedance matrix": $\mathbf{Q} = e^{-d^{rs}}$

```{r}
Toy_Lat <- c(42.3, 44.49, 41.84 )
Toy_Lon <- c(-89.04, -88.03, -87.77)
Toy_Dist_mat <- distm(cbind(Toy_Lon, Toy_Lat))/1000000
colnames(Toy_Dist_mat) = rownames(Toy_Dist_mat) <-  c("Albany", "Brown", "Cook")

#Toy_Q <- (1/(Toy_Dist_mat)^2)
Toy_Q <- exp(-Toy_Dist_mat)

Toy_Q  %>% round(3)
```

"Spatial Absorption matrix": $\mathbf{AQ}$

```{r}
(Toy_Queeg * Toy_Q ) %>% round(2)

```

"Spatial Normalized Absorption Shares": $\mathbf{\alpha Q}$

```{r}

(Toy_Queeg_R * Toy_Q ) %>% round(2)

```

"Connectedness Classification"
```{r}
(data.frame(County = colnames((Toy_Queeg_R * Toy_Q )), Match = colnames((Toy_Queeg_R * Toy_Q ))[apply((Toy_Queeg_R * Toy_Q ), 1, which.max)]))

```


```{r}
#Direct Requirements
D = Toy_Direct_mat
D
#Total Industry Output by region
Y = Toy_X_mat
Y
#National Total Output
Yi = as.matrix(rowSums(Toy_X_mat))
Yi
#National Intermediate Output
DYi = Toy_Direct_mat %*% as.matrix(rowSums(Toy_X_mat)) 
DYi
#National Final Demand 
Fd = as.matrix(rowSums(Toy_X_mat)) - Toy_Direct_mat %*% as.matrix(rowSums(Toy_X_mat)) 
Fd
#Intermediate Output by region
DY = Toy_Direct_mat %*% Toy_X_mat
DY
#National Intermediate Inputs 
YhD = rowSums(diag(rowSums(Toy_X_mat)) %*% t(Toy_Direct_mat))
YhD
#National Transactions Matrix 
Z = Toy_Direct_mat %*% diag(rowSums(Toy_X_mat))
Z
#National Value Added 
V = as.matrix(rowSums(Toy_X_mat)) - colSums(Toy_Direct_mat %*% diag(rowSums(Toy_X_mat)))
V 


#import needs by region: Necessary level of regional total output that needs to be imported to be able to produce the observed level of regional total output (assuming no cross hauling)
pmax(Toy_Direct_mat %*% Toy_X_mat - Toy_X_mat, 0)

#exports (excess) by region: Available level of total output by region that can be exported to other regions
pmax(Toy_X_mat - Toy_Direct_mat %*% Toy_X_mat, 0)

# Percentage that a regions available exports can satisfy the import needs of another region on per industry basis
ExportPotentialAbsorptionPercentage <- vector(mode='list', length=ncol(Toy_X_mat))
  names(ExportPotentialAbsorptionPercentage) <- colnames(Toy_X_mat)
for (i in 1:ncol(Toy_X_mat)){
ExportPotentialAbsorptionPercentage[[i]] <- matrix(0, nrow = nrow(Toy_X_mat), ncol = ncol(Toy_X_mat))
 rownames(ExportPotentialAbsorptionPercentage[[i]])  <- rownames(Toy_X_mat)
   colnames(ExportPotentialAbsorptionPercentage[[i]]) <- colnames(Toy_X_mat)
}
  for (i in 1:ncol(Toy_X_mat)){
    for (j in 1:ncol(Toy_X_mat)){
          ExportPotentialAbsorptionPercentage[[i]][,j]  <- pmin(pmax(Toy_X_mat - Toy_Direct_mat %*% Toy_X_mat, 0)[,i], pmax(Toy_Direct_mat %*% Toy_X_mat - Toy_X_mat, 0)[,j])  /  pmax(Toy_Direct_mat %*% Toy_X_mat - Toy_X_mat, 0)[,j] * 100 %>% round(2)
    }
  }
ExportPotentialAbsorptionPercentage

# Percentage that a regions overall available exports can satisfy the overall import needs of another region
AverageExportPotentialAbsorptionPercentage <-  matrix(0, nrow = ncol(Toy_X_mat), ncol = ncol(Toy_X_mat))
 rownames(AverageExportPotentialAbsorptionPercentage) = colnames(AverageExportPotentialAbsorptionPercentage) <- colnames(Toy_X_mat)

  for (i in 1:ncol(Toy_X_mat)){
        AverageExportPotentialAbsorptionPercentage[i,]  <-  ExportPotentialAbsorptionPercentage[[i]] %>% colMeans(na.rm = TRUE)
  }
 AverageExportPotentialAbsorptionPercentage

# Percentage that a regions import needs are satisfy by the available exports of another region on per industry basis
ImportPotentialAbsorptionPercentage <- vector(mode='list', length=ncol(Toy_X_mat))
  names(ImportPotentialAbsorptionPercentage) <- colnames(Toy_X_mat)
for (i in 1:ncol(Toy_X_mat)){
ImportPotentialAbsorptionPercentage[[i]] <- matrix(0, nrow = nrow(Toy_X_mat), ncol = ncol(Toy_X_mat))
 rownames(ImportPotentialAbsorptionPercentage[[i]])  <- rownames(Toy_X_mat)
   colnames(ImportPotentialAbsorptionPercentage[[i]]) <- colnames(Toy_X_mat)
}
  for (i in 1:ncol(Toy_X_mat)){
    for (j in 1:ncol(Toy_X_mat)){
          ImportPotentialAbsorptionPercentage[[i]][,j]  <- pmin(pmax(Toy_X_mat - Toy_Direct_mat %*% Toy_X_mat, 0)[,j], pmax(Toy_Direct_mat %*% Toy_X_mat - Toy_X_mat, 0)[,i])  /  pmax(Toy_Direct_mat %*% Toy_X_mat - Toy_X_mat, 0)[,i] * 100 %>% round(2)
    }
  }
ImportPotentialAbsorptionPercentage

# Percentage that a regions overall import needs are satisfy by the overall available exports of another region
AverageImportPotentialAbsorptionPercentage <-  matrix(0, nrow = ncol(Toy_X_mat), ncol = ncol(Toy_X_mat))
 rownames(AverageImportPotentialAbsorptionPercentage) = colnames(AverageImportPotentialAbsorptionPercentage) <- colnames(Toy_X_mat)

  for (i in 1:ncol(Toy_X_mat)){
        AverageImportPotentialAbsorptionPercentage[i,]  <-  ImportPotentialAbsorptionPercentage[[i]] %>% colMeans(na.rm = TRUE)
  }
AverageImportPotentialAbsorptionPercentage

# Import susceptive (receptiveness, selectivity) (100 most to zero least)
df <- AverageImportPotentialAbsorptionPercentage
df[df == 0] <- NA
rowMeans(df, na.rm=TRUE)

# Export accommodating (compliant, adaptability) (100 most to zero least)
df <- AverageExportPotentialAbsorptionPercentage
df[df == 0] <- NA
rowMeans(df, na.rm=TRUE)



#Total Output Available as exports across all regions
as.matrix(rowSums(pmax(Toy_X_mat - Toy_Direct_mat %*% Toy_X_mat, 0)))

#Total Output Needed as imports across all regions
as.matrix(rowSums(pmax(Toy_Direct_mat %*% Toy_X_mat - Toy_X_mat, 0)))

#Net Exports of Total Output (equal to national final demand)
as.matrix(rowSums(pmax(Toy_X_mat - Toy_Direct_mat %*% Toy_X_mat, 0))) - as.matrix(rowSums(pmax(Toy_Direct_mat %*% Toy_X_mat - Toy_X_mat, 0)))





```



