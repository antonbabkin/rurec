---
title: "Maps and IO Similarity Index: II"
author: "Austin Sandler"
date: "2022-06-02"
format:
  html:
    self-contained: true
    page-layout: full
    code-fold: true
    code-tools: true
    code_download: yes
    latex_engine: pdflatex
---


```{r preamble, include = FALSE}
# When you click the **Render** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document.
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 

#For nonscientific notation
options(scipen=999)

```


```{r packages and libraries, include = FALSE}
# Load and attach necessary packages
library(rprojroot)
library(cowplot)
library(dash)
library(dlm)
library(DT)
#library(geosphere)
library(ggiraph)
library(glue)
library(gtools)
library(knitr)
library(magrittr)
#library(manipulateWidget)
library(Matrix)
library(plotly)
library(reshape2)
library(scales)
#library(spdep)
#library(tidyverse)
#library(tmap)
#library(tmaptools)
library(tools)

#Load custom functions
#source(file.path(find_rstudio_root_file(), "nbs", "rural_typology_r_functions.R"))
source(file.path(find_rstudio_root_file(), "nbs", "rural_typology_r_data_generation.R"))


```

```{r load data, include=FALSE}
# Load previously generated datafiles
importr(TIGER_RUCC)
importr(Direct_mat)
importr(Total_mat)
importr(Xpay_mat)
importr(Impede_mat)
importr(D_mat)
importr(Queeg)
importr(Queeg_rel)
importr(Input_mat_exp)
importr(Input_mat_imp)
importr(Queego)
importr(Queeg_relo)

Queeg_list <- list(Queeg, Queeg_rel)
names(Queeg_list) <- c("Queeg",  "Queeg_rel")

Queeg_listo <- list(Queego, Queeg_relo)
names(Queeg_listo) <- c("Queego",  "Queeg_relo")

data_dir = file.path(find_rstudio_root_file(), "data", "robjs")

```


This document attempts to map the various topological similarity index relationships for Wisconsin counties. Updates include shading intensity for level of connectiveness and histograms on a industry level matching similarity, as well as more concise code. 

::: {.panel-tabset}


### Methods

I-O analysis, or inter-industry analysis, is an economic tool that measures the relationships between industries in the economy. The framework measures flows of products from each of the sectors (as a producer/seller) to each of the sectors (as a purchaser/buyer); these interindustry flows, or transactions are measured for a particular time period and in monetary terms.  

We categorize the economy into $n$ sectors and let $x_{i}$ denote the total output of sector $i$. We denote $f_{i}$ as *final demand*, which represents all sales that are *exogenous* to the industrial sectors (e.g., households, government, and foreign trade). Taken together, we specify sector  $i$'s *output* with an accounting  identity $x_{i} = \sum^{n}_{j=1}z_{ij} + f_{i}$ that describes the way in which sector $i$ distributes its product to other sectors and to final demand, here the $z_{ij}$ terms represent *interindustry* sales by sector $i$ to all $j$ sectors in $n$. 

Let the *total output* of all sectors be summarized by: 
$$\mathbf{x} = \mathbf{Zi} + \mathbf{f}$$
where $\mathbf{i}$ represent a column vector of 1’s. 

We define the *input coefficient*, $a_{ij} = z_{ij}/x_{j}$ to be the quantity of the output of sector $i$ absorbed by sector $j$ per unit of its total output. This ratio is also known as the *technical coefficient*; the *input–output coefficient*;  or the *direct input coefficient*, specifies the required amount of industry $i$’s commodity used to produce of one unit of industry $j$’s commodity. 

Let the $n \times n$ *technical coefficient matrix* by summarized by:  
$$\mathbf{A} = \mathbf{Z\hat{x}^{-1}}$$
where the “hat” over a vector denotes a diagonal matrix. Therefore, given a set of fixed technical coefficients, $\mathbf{x} = \mathbf{Ax} + \mathbf{f}$ denotes the accounting equation for the distribution of total output to all sectors and final demand. Note the inherent production functions of this system are isoquant “curves” that exhibit constant output. Such *Leontief* production functions require inputs in fixed proportions, where a fixed amount of each input is required to produce one unit of output.  

If $(\mathbf{I} - \mathbf{A})$ is non-singular, where $\mathbf{I}$ is the identity matrix, then rearranging gives, $\mathbf{x} = \left(\mathbf{I} - \mathbf{A}\right)^{-1}\mathbf{f}$. Let the *Leontief* inverse or the *total requirements matrix* be given by:
$$\mathbf{L} = \left(\mathbf{I} - \mathbf{A}\right)^{-1}$$ 
Finally, in much the same way that subscript $i$ denotes an industry sector, we let superscript $r$ designate subnational geographies. Thus, $\mathbf{x^{r}}$ denotes the vector of gross output of all industries  in region $r$.


In  practice, we derive a national-level, industry-by-industry direct requirements matrix, $\mathbf{A}$ from the national-level, industry-by-industry total requirements matrix, $\mathbf{L}$ available from the U.S. Bureau of Economic Analysis (BEA) at three levels of industry specificity  (i.e.,  Sector,  Summary, and Detail). We construct the location specific total output vector, 𝐱rfrom a payroll and labor share quotient using  Census Bureau County Business Patterns  (CBP) or FSRDC depending on the desired spatial scale. With these two inputs we construct location specific metrics of industry input needs.

**Location specific metrics of industry inputs**

First, we specify the place specific *input needs vector* as: 
$$\mathbf{Ax^{r}}$$
In addition, we define the *net import shortage vector* as: 
$$\text{NIS}^{r} = \max \{\mathbf{Ax^{r}} - \mathbf{x^{r}}, 0\}$$ 

Similarly, we define the *net input excess vector* as: 
$$\text{NIE}^{r} = \max \{\mathbf{x^{r} - \mathbf{Ax^{r}}}, 0\}$$

**Cross location industry compatibility**

To elucidate the industrial compatibility across locations, we construct a *similarity index*. In general, it is defined on the metric space $(\mathfrak{X}, \mathfrak{D})$ where $\mathfrak{X}$ is a set of vectors $\{\mathbf{x}_{i} \in \mathbb{R} : i \in \{1, \dots, n \}\}$ and $\mathfrak{D}:\mathfrak{X} \times \mathfrak{X}	\rightarrow \mathbb{R}$ is a distance function.  

We first define an *absorption* vector between exporting location $r$ and importing location $s$ as: 
$$\min\{\text{NIE}^{r}, \text{NIS}^{s} \}$$

Finally, to match geographies through their supply chain capacitance we specify the novel *Queeg* distance as: 
$$\arg \max_{l} \{\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}\}~ \forall ~ r,s \in l$$ 

Places with net input excesses will have capacity to export their commodities to places with net shortage capacity. The pair of geographies with the largest overall economic capacity overlap are matched together. In practice $s$ places enter as pre-specified non-rural cores and all other rural places $r$ are matched to them. 

To restrict the capacitance magnitudes we specify the *Relative Queeg* distance as: 
$$\arg \max_{l} \{\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}/\mathbf{i'}\text{NIE}^{r}\}~ \forall ~ r,s \in l$$
Note: Contrary to the other similarity indices the *Queeg* measure is not a "distance" where the $\arg \min$ matches two places. But rather the *Queeg* specification is a congruence or compatibility metric where the $\arg \max$  matches two places.

**Spatial considerations**

In addition, we weight the economic capacitance metric by a *geographical impedance function*, $\mathbf{Q}$.  For example, in practice the geographical impedance between locations $r$ and $s$ may be defined as: the Inverse Square Function $Q^{rs} = 1/(d^{rs})^2$, the Exponential Decay Function $Q^{rs} = e^{-d^{rs}}$, or the Hyperbolic Secant Function $Q^{rs} = 2 / (e^{-d^{rs}} +e^{d^{rs}})$, where $d^{rs}$ is the great-circle distance between the two locations. Specifically, 
$d^{rs}  = R \cdot \arccos(\sin(\phi_{r})\sin(\phi_{s}) + \cos(\phi_{r})\cos(\phi_{s})\cos(\vert \lambda_{r} - \lambda_{s} \vert))$, where $\lambda_{r}, \phi_{r}$ and $\lambda_{s}, \phi_{r}$ are the longitude and latitude of locations $r$ and $s$, and $R$ is the radius of the reference sphere, which in this case is the *mean earth radius* from the WGS84 ellipsoid. 


Let the novel *Spatial Queeg* distance between exporting locations $r$ and importing location $s$ be given by:
$$\arg \max_{l} \{(\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}) * Q^{rs} \}~ \forall ~ r,s \in l$$ 
And similarly, let the *Spatial Relative Queeg* distance be given by: 
$$\arg \max_{l} \{(\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}/\mathbf{i'}\text{NIE}^{r}) * Q^{rs}  \}~ \forall ~ r,s \in l$$
Alternative specifications of the spatial distance are possible. One possibility is to discretize the impedance matrix as a binary proximity operator which is one when two locations share a boundary (or vertex) and zero otherwise.  



### WI Test

```{r extent}
rural_extent <- grep("^55", rownames(TIGER_RUCC), value=TRUE) %>%
                grep("55009", ., value=TRUE, invert = TRUE) %>% 
                grep("55025", ., value=TRUE, invert = TRUE) %>% 
                grep("55079", ., value=TRUE, invert = TRUE)

primary_extent <- c("55009", "55025", "55079", "17031", "27053")
names(primary_extent) <- primary_extent

all_extent <- c(rural_extent, primary_extent) %>% as.vector()

industry_levels  <-  c("Sector", "Summary", "Detail")




```



"New Regional-level Total Output Table":  $\mathbf{X}^*$

```{r new total output}

Xpay_mat_H1 <- vector(mode='list', length=length(Total_mat))
names(Xpay_mat_H1) <- industry_levels

WISim <- Xpay_mat_H1
NoMatch <- Xpay_mat_H1
MatMat <- Xpay_mat_H1
WI_match <- Xpay_mat_H1

Pmatch <- diag(rep(c(1), each=length(primary_extent)))
colnames(Pmatch) = rownames(Pmatch) <- primary_extent
  
  for (l in 1:length(WISim)){
    
    WISim[[l]] <- (Queeg_list[[2]][[l]][rural_extent, primary_extent] * Impede_mat[[3]][[l]][rural_extent, primary_extent]) %>% 
                     as.data.frame() %>% filter( rowSums(.) != 0) %>% as.matrix()
    NoMatch[[l]] <- Queeg_list[[2]][[l]][rural_extent, primary_extent] %>% 
                     as.data.frame() %>% filter( rowSums(.) == 0) %>% as.matrix()

    MatMat[[l]] <- cbind(
                    rbind(WISim[[l]], 
                          Pmatch, 
                          NoMatch[[l]]
                          ), 
                    rbind(matrix(0, dim(rbind(WISim[[l]], Pmatch))[1], dim(NoMatch[[l]])[1]), 
                          diag(rep(c(1), each=dim(NoMatch[[l]])[1]))
                          ) 
                    )
    colnames(MatMat[[l]]) <- c(colnames(WISim[[l]]), rownames(NoMatch[[l]]))

    WI_match[[l]] <- sparseMatrix(i = match(rownames(MatMat[[l]]), rownames(MatMat[[l]])),
                                  j = match(c(colnames(MatMat[[l]])[apply(MatMat[[l]], 1, which.max)]), colnames(MatMat[[l]])),
                                  x = 1L,
                                  dims = c(nrow(MatMat[[l]]), ncol(MatMat[[l]])),
                                  dimnames = list(rownames(MatMat[[l]]), colnames(MatMat[[l]]))
                                   ) %>% as.matrix()
    
  Xpay_mat_H1[[l]] <- Xpay_mat[[l]][, rownames(WI_match[[l]])[order(rownames(WI_match[[l]]))]] %*% 
                      WI_match[[l]][order(rownames(WI_match[[l]])), order(colnames(WI_match[[l]]))]
}


```


 

```{r}

primary_c <- vector(mode='list', length=length(Total_mat))
names(primary_c) <- industry_levels

test_industry <- vector(mode='list', length=length(Total_mat))
names(test_industry) <- industry_levels

for (l in 1:length(Total_mat)){
    primary_c[[l]] <- Input_mat_imp[[l]][, names(primary_extent)] %>% as.data.frame() %>% select(order(colnames(.)))
    #primary_c[[l]] <- cbind(industry = seq_along(primary_c[[l]][,1]), primary_c[[l]])
    primary_c[[l]]$industry_label <- rownames(primary_c[[l]])
    primary_c[[l]] <- melt(primary_c[[l]], id = "industry_label") %>% rename(NIS = value, core_fips = variable) 
}

for (l in 1:length(Total_mat)){
  for (p in 1:length(rural_extent)){
    test_industry[[l]][[p]] <- Input_mat_exp[[l]][, rural_extent][, p] %>% as.data.frame()
    colnames( test_industry[[l]][[p]]) <- c("NIE")
    test_industry[[l]][[p]]$industry_label <- rownames(test_industry[[l]][[p]])
    #test_industry[[l]][[p]] <- cbind(industry = seq_along(test_industry[[l]][[p]][,1]),  test_industry[[l]][[p]])
    
  }
  names( test_industry[[l]]) <- colnames(Input_mat_exp[[l]][, rural_extent])
}

ggbase <- test_industry
ggtop <- ggbase
```

```{r}

df <- vector(mode='list', length=length(Total_mat))
names(df) <- industry_levels

test <- vector(mode='list', length=length(Total_mat))
names(test) <- industry_levels

for (l in 1:length(Total_mat)){
  for (p in 1:length(rural_extent)){
    df[[l]][[p]] <- inner_join(test_industry[[l]][[p]], primary_c[[l]], by = "industry_label") %>% arrange(core_fips, industry_label) 
    df[[l]][[p]]$absorb <- pmin(df[[l]][[p]]$NIE, df[[l]][[p]]$NIS)
    test[[l]][[p]] <- df[[l]][[p]] %>% filter(absorb > 0) %>% group_by(core_fips) %>% slice_max(order_by = absorb, n = 7) %>% arrange(core_fips)
  }
}


for (l in 3){
  for (p in 1:length(rural_extent)){
    county <- TIGER_RUCC %>% filter(TIGER_RUCC$FIPS %in% rural_extent[p]) %>% pull(COUNTY)
     ggtop[[l]][[p]] <- ggplot(test[[l]][[p]]) +
      geom_col_interactive(aes(x = industry_label,
                               y = (NIE)),
                               fill = "grey") +
 
      geom_point_interactive(
                 aes(x = industry_label,
                     y = (NIS),
                     color = core_fips), 
                     size  = 3.5) +
      labs(x = "Industry Sector", y = "Input Value") +
      scale_y_continuous() +
       labs(title = "Absorption Distribution Capacitance",
            subtitle = glue("Net Input Excess: {county}"),
            color = "Net Import Shortage") +

       scale_colour_brewer(palette = "Set1", labels = (TIGER_RUCC %>% filter(TIGER_RUCC$FIPS %in% primary_extent) %>% pull(COUNTY)) ) +
       theme_minimal() +
        theme(axis.text.x = element_text(angle=45, hjust=1))
    }
}

print(ggtop[[3]]$`55027`)



```


```{r}
# 
# for (l in 1:length(Total_mat)){
#   for (p in 1:length(rural_extent)){
#     county <- TIGER_RUCC %>% filter(TIGER_RUCC$FIPS %in% rural_extent[p]) %>% pull(COUNTY)
#      ggbase[[l]][[p]] <- ggplot(as.data.frame(test_industry[[l]][[p]])) +
#       geom_col_interactive(aes(x = industry,
#                                y = (value)),
#                                fill = "grey") +
#       geom_point_interactive(data = filter(primary_c[[l]], value != 0),
#                  aes(x = industry,
#                      y = (value),
#                      color = variable), 
#                      size  = 3.5) +
#       labs(x = "Industry Sector", y = "Input Value") +
#       scale_x_discrete(limits = factor(1:dim(Input_mat_exp[[l]])[1]), labels = c(rownames(Input_mat_exp[[l]]))) +
#       scale_y_continuous() +
#        labs(title = "Absorption Distribution Capacitance",
#             subtitle = glue("Net Input Excess: {county}"),
#             color = "Net Import Shortage") +
#        scale_colour_brewer(palette = "Set1", labels = (TIGER_RUCC %>% filter(TIGER_RUCC$FIPS %in% primary_extent) %>% pull(COUNTY)) ) +
#        theme_minimal()
#     }
# }



for (l in 1:length(Total_mat)){
  for (p in 1:length(rural_extent)){
    county <- TIGER_RUCC %>% filter(TIGER_RUCC$FIPS %in% rural_extent[p]) %>% pull(COUNTY)
     ggbase[[l]][[p]] <- ggplot(as.data.frame(test_industry[[l]][[p]])) +
      geom_col_interactive(aes(x = industry_label,
                               y = (NIE)),
                               fill = "grey") +
      geom_point_interactive(data = primary_c[[l]],
                 aes(x = industry_label,
                     y = (NIS),
                     color = core_fips), 
                     size  = 3.5) +
      labs(x = "Industry Sector", y = "Input Value") +
      scale_x_discrete(limits = factor(1:dim(Input_mat_exp[[l]])[1]), labels = c(rownames(Input_mat_exp[[l]]))) +
      scale_y_continuous() +
       labs(title = "Absorption Distribution Capacitance",
            subtitle = glue("Net Input Excess: {county}"),
            color = "Net Import Shortage") +
       scale_colour_brewer(palette = "Set1", labels = (TIGER_RUCC %>% filter(TIGER_RUCC$FIPS %in% primary_extent) %>% pull(COUNTY)) ) +
       theme_minimal()
    }
}




#print(ggbase[[1]]$`55027`)

```




```{r queeg maps}

if (!file.exists(file.path(data_dir, "WI_Queeg_Plots_XINT"))){
  if (!exists("WI_Queeg_Plots")){
    cmapr(WI_Queeg_Plots)
  }
  if (!exists("WI_Queeg_Plots_XINT")){
    dismapr(WI_Queeg_Plots)
  }
  saver(WI_Queeg_Plots_XINT)
} else {
  importr(WI_Queeg_Plots_XINT)
}

```

"Queeg distance": $\arg \max_{l} \{\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}\}~ \forall ~ r,s \in l$

```{r}
WI_Queeg_Plots_XINT[[1]] 
```

"Relative Queeg distance":  $\arg \max_{l} \{\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}/\mathbf{i'}\text{NIE}^{r}\}~ \forall ~ r,s \in l$

```{r}
WI_Queeg_Plots_XINT[[2]] 
```

```{r}
rm(WI_Queeg_Plots, WI_Queeg_Plots_XINT) %>% suppressWarnings()
```


Location specific total output vector specified by annual industry payroll is now adjusted for labor share quotient

```{r queego maps}

if (!file.exists(file.path(data_dir, "WI_Queego_Plots_XINT"))){
  if (!exists("WI_Queego_Plots")){
    cmapr(WI_Queego_Plots,  list_of_sim_specifications = Queeg_listo)
  }
  if (!exists("WI_Queego_Plots_XINT")){
    dismapr(WI_Queego_Plots)
  }
  saver(WI_Queego_Plots_XINT)
} else {
  importr(WI_Queego_Plots_XINT)
}

```

"Queeg distance": $\arg \max_{l} \{\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}\}~ \forall ~ r,s \in l$

```{r}
WI_Queego_Plots_XINT[[1]] 
```

"Relative Queeg distance":  $\arg \max_{l} \{\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}/\mathbf{i'}\text{NIE}^{r}\}~ \forall ~ r,s \in l$

```{r}
WI_Queego_Plots_XINT[[2]] 
```

```{r}
rm(WI_Queego_Plots, WI_Queego_Plots_XINT) %>% suppressWarnings()
```




Note: Alpha shading is not consistent *between* categories only within.  

### WI Test - Spatial


"Spatial Impedance Only": $1 / Q^{rs} ~ \forall ~ r,s \in l$ where $Q^{rs} = 2/(e^{-d^{rs}c} + e^{d^{rs}c})$ and scalar $c = 10^{6}$ 

```{r}
  cmapr(WI_TT,  impedance = Impede_mat[[3]], spo = TRUE)
  WI_TT[[1]][[1]]
  rm(WI_TT)
```


"Spatial Queeg distance": $\arg \max_{l} \{(\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \} )* Q^{rs} \}~ \forall ~ r,s \in l$

```{r queeg maps with impedance}

if (!file.exists(file.path(data_dir, "WI_Queeg_Plots_Imped_XINT"))){
  if (!exists("WI_Queeg_Plots_Imped")){
    cmapr(WI_Queeg_Plots_Imped, impedance = Impede_mat[[3]])
  }
  if (!exists("WI_Queeg_Plots_Imped_XINT")){
    dismapr(WI_Queeg_Plots_Imped)
  }
  saver(WI_Queeg_Plots_Imped_XINT)
} else {
  importr(WI_Queeg_Plots_Imped_XINT)
}

```

```{r}
WI_Queeg_Plots_Imped_XINT[[1]] 
```

"Spatial Relative Queeg distance": $\arg \max_{l} \{(\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}/\mathbf{i'}\text{NIE}^{r}) * Q^{rs}\}~ \forall ~ r,s \in l$

```{r}
WI_Queeg_Plots_Imped_XINT[[2]] 
```


```{r}
rm(WI_Queeg_Plots_Imped, WI_Queeg_Plots_Imped_XINT) %>% suppressWarnings()
```

###  Impedance Sensitivity 

```{r}

if (!file.exists(file.path(data_dir, "WI_Test_Sens_XINT"))){
    DI_mat  <- D_mat
    for (i in 1:length(D_mat)){DI_mat[[i]] =  DI_mat[[i]][rural_extent, primary_extent]}
    Sens_list  <- list()
    Sens_list[[1]] <- Queeg_list[[2]]
    
    WI_Test_Sens_XINT = Imp <- vector(mode='list', length = 11)

    for(l in 1:length(Imp)){ 
      Imp[[l]] <- vector(mode='list', length=length(industry_levels))
      names(Imp[[l]]) <- industry_levels
    }

    x = 1
    for (i in 1:length(DI_mat)){ Imp[[x]][[i]] = DI_mat[[i]]/DI_mat[[i]] }
    x=x+1
    for (i in 1:length(DI_mat)){ Imp[[x]][[i]] = 1/(DI_mat[[i]]) } 
    x=x+1
    for (i in 1:length(DI_mat)){ Imp[[x]][[i]] = (1/(DI_mat[[i]])^2) } 
    x=x+1
    for (i in 1:length(DI_mat)){ Imp[[x]][[i]] = (1/(DI_mat[[i]])^(1/2)) } 
    x=x+1
    for (i in 1:length(DI_mat)){ Imp[[x]][[i]] = (1/(DI_mat[[i]])^(1/3)) } 
    # x=x+1
    # for (i in 1:length(DI_mat)){ Imp[[x]][[i]] = (1/(DI_mat[[i]])^(1/10)) } 
    x=x+1
    for (i in 1:length(DI_mat)){ Imp[[x]][[i]] = exp(-(DI_mat[[i]])) }
    x=x+1
    for (i in 1:length(DI_mat)){ Imp[[x]][[i]] = exp(-(DI_mat[[i]]/min(DI_mat[[i]]))) }
    x=x+1
    for (i in 1:length(DI_mat)){ Imp[[x]][[i]] = exp(-(DI_mat[[i]]/1000000)) }
    # x=x+1
    # for (i in 1:length(DI_mat)){ Imp[[x]][[i]] = exp(-(DI_mat[[i]]/10000000)) }
    # x=x+1
    # for (i in 1:length(DI_mat)){ Imp[[x]][[i]] = exp(-(DI_mat[[i]]/100000000)) }
    x=x+1
    for (i in 1:length(DI_mat)){ Imp[[x]][[i]] = 2/(exp(-(D_mat[[i]])) + exp(D_mat[[i]])) }
    x=x+1
    for (i in 1:length(DI_mat)){ Imp[[x]][[i]] = 2/(exp(-(D_mat[[i]]/100000)) + exp(D_mat[[i]]/100000)) }
    x=x+1
    for (i in 1:length(DI_mat)){ Imp[[x]][[i]] = 2/(exp(-(D_mat[[i]]/1000000)) + exp(D_mat[[i]]/1000000)) }
    # x=x+1
    # for (i in 1:length(DI_mat)){ Imp[[x]][[i]] = 2/(exp(-(D_mat[[i]]/10000000)) + exp(D_mat[[i]]/10000000)) }
     
    for (l in 1:length(Imp)){     
      cmapr(Sens, 
           list_of_sim_specifications = Sens_list, 
           impedance = Imp[[l]]
           )
      dismapr(Sens)
      WI_Test_Sens_XINT[l] <- Sens_XINT
    }
  
  saver(WI_Test_Sens_XINT)
  rm(DI_mat, Sens_list, Sens, Sens_XINT, Imp)

} else {
  importr(WI_Test_Sens_XINT)
}


#Add necessary/sufficient conditions check for impedance values with relative indices

```


Specification sensitivity example for various impedance measures using the "Spatial Relative Queeg distance" data.  

**Base map** 

$Q^{rs} = \mathbf{1}$

```{r}
WI_Test_Sens_XINT[[1]]
```

**Inverse Distance Function**

$Q^{rs} = 1/(d^{rs})$ where $d^{rs}$ is the great-circle distance between the two locations

```{r}
WI_Test_Sens_XINT[[2]]
```

**Inverse Square Function**

$Q^{rs} = 1/(d^{rs})^2$

```{r}
WI_Test_Sens_XINT[[3]]
```

**Inverse Square Root Function**

$Q^{rs} = 1/(d^{rs})^{1/2}$

```{r}
WI_Test_Sens_XINT[[4]]
```

**Inverse Cube Root Function**

$Q^{rs} = 1/(d^{rs})^{1/3}$

```{r}
WI_Test_Sens_XINT[[5]]
```


**Exponential Decay Function**

$Q^{rs} = e^{-d^{rs}}$ 

```{r}
WI_Test_Sens_XINT[[6]]
```

**Exponential Decay Function**

$Q^{rs} = e^{-d^{rs}c}$ where scalar $c = \min\{ \text{Distance}\}$ 

```{r}
WI_Test_Sens_XINT[[7]]
```

**Exponential Decay Function**

$Q^{rs} = e^{-d^{rs}c}$ where scalar $c = 10^{6}$ 

```{r}
WI_Test_Sens_XINT[[8]]
```

**Hyperbolic Secant Function**

$Q^{rs} = 2/(e^{-d^{rs}} + e^{d^{rs}})$ 

```{r}
WI_Test_Sens_XINT[[9]]
```

**Hyperbolic Secant Function**

$Q^{rs} = 2/(e^{-d^{rs}c} + e^{d^{rs}c})$ where scalar $c = 10^{5}$ 

```{r}
WI_Test_Sens_XINT[[10]]
```

**Hyperbolic Secant Function**

$Q^{rs} = 2/(e^{-d^{rs}c} + e^{d^{rs}c})$ where scalar $c = 10^{6}$ 

```{r}
WI_Test_Sens_XINT[[11]]
```




### WI Hierarchical

In this 2-stage analysis, the counties of Wisconsin are first matched internally. Metro counties in areas with a population of under a 1 million serve as first-order cores which all other counties are matched based on their capacitance.  
We then perform a second analysis where all Wisconsin counties are matched to Cook and Hennepin counties based on their capacitance.
Finally, we perform a second-level hierarchical analysis where clusters and non-matched counties from the first-level internal matching for Wisconsin are then matched to Cook and Hennepin counties based on their capacitance.



```{r hierarchical extent}
# rural_extent <- grep("^55", rownames(TIGER_RUCC), value=TRUE) %>%
#                 grep("55059", ., value=TRUE, invert = TRUE) %>% 
#                 grep("55079", ., value=TRUE, invert = TRUE) %>% 
#                 grep("55089", ., value=TRUE, invert = TRUE) %>%
#                 grep("55093", ., value=TRUE, invert = TRUE) %>%
#                 grep("55109", ., value=TRUE, invert = TRUE) %>%
#                 grep("55131", ., value=TRUE, invert = TRUE) %>%
#                 grep("55133", ., value=TRUE, invert = TRUE) 
# 
# primary_extent <- c("55059", "55079", "55089", "55093", "55109", "55131", "55133")
# names(primary_extent) <- primary_extent

rural_extent <- grep("^55", rownames(TIGER_RUCC), value=TRUE) %>%
                grep("55009", ., value=TRUE, invert = TRUE) %>% 
                  grep("55025", ., value=TRUE, invert = TRUE) %>%
                  grep("55031", ., value=TRUE, invert = TRUE) %>%
                grep("55035", ., value=TRUE, invert = TRUE) %>%
                grep("55039", ., value=TRUE, invert = TRUE) %>%
                grep("55059", ., value=TRUE, invert = TRUE) %>%
                grep("55063", ., value=TRUE, invert = TRUE) %>% 
                grep("55073", ., value=TRUE, invert = TRUE) %>%
                  grep("55079", ., value=TRUE, invert = TRUE) %>%
                grep("55087", ., value=TRUE, invert = TRUE) %>% 
                  grep("55089", ., value=TRUE, invert = TRUE) %>% 
                grep("55105", ., value=TRUE, invert = TRUE) %>% 
                grep("55117", ., value=TRUE, invert = TRUE) %>%
                  grep("55131", ., value=TRUE, invert = TRUE) %>% 
                  grep("55133", ., value=TRUE, invert = TRUE) %>% 
                grep("55139", ., value=TRUE, invert = TRUE)

  
hold_extent <- c("55025", "55031", "55079", "55089", "55131", "55133")

primary_extent <- c("55009","55035", "55039", "55059", "55063","55073", "55087", "55105", "55117", "55139")
names(primary_extent) <- primary_extent

all_extent <- c(rural_extent, primary_extent) %>% as.vector()

```




```{r}
primary_c <- vector(mode='list', length=length(Total_mat))
names(primary_c) <- industry_levels

test_industry <- vector(mode='list', length=length(Total_mat))
names(test_industry) <- industry_levels

for (l in 1:length(Total_mat)){
    primary_c[[l]] <- Input_mat_imp[[l]][, names(primary_extent)] %>% as.data.frame() %>% select(order(colnames(.)))
    #primary_c[[l]] <- cbind(industry = seq_along(primary_c[[l]][,1]), primary_c[[l]])
    primary_c[[l]]$industry_label <- rownames(primary_c[[l]])
    primary_c[[l]] <- melt(primary_c[[l]], id = "industry_label") %>% rename(NIS = value, core_fips = variable) 
}

for (l in 1:length(Total_mat)){
  for (p in 1:length(rural_extent)){
    test_industry[[l]][[p]] <- Input_mat_exp[[l]][, rural_extent][, p] %>% as.data.frame()
    colnames( test_industry[[l]][[p]]) <- c("NIE")
    test_industry[[l]][[p]]$industry_label <- rownames(test_industry[[l]][[p]])
    #test_industry[[l]][[p]] <- cbind(industry = seq_along(test_industry[[l]][[p]][,1]),  test_industry[[l]][[p]])
    
  }
  names( test_industry[[l]]) <- colnames(Input_mat_exp[[l]][, rural_extent])
}

ggbase <- test_industry
ggtop <- test_industry


df <- vector(mode='list', length=length(Total_mat))
names(df) <- industry_levels

test <- vector(mode='list', length=length(Total_mat))
names(test) <- industry_levels

for (l in 1:length(Total_mat)){
  for (p in 1:length(rural_extent)){
    df[[l]][[p]] <- inner_join(test_industry[[l]][[p]], primary_c[[l]], by = "industry_label") %>% arrange(core_fips, industry_label) 
    df[[l]][[p]]$absorb <- pmin(df[[l]][[p]]$NIE, df[[l]][[p]]$NIS)
    test[[l]][[p]] <- df[[l]][[p]] %>% filter(absorb > 0) %>% group_by(core_fips) %>% slice_max(order_by = absorb, n = 7) %>% arrange(core_fips)
  }
}


for (l in 3){
  for (p in 1:length(rural_extent)){
    county <- TIGER_RUCC %>% filter(TIGER_RUCC$FIPS %in% rural_extent[p]) %>% pull(COUNTY)
     ggtop[[l]][[p]] <- ggplot(test[[l]][[p]]) +
      geom_col_interactive(aes(x = industry_label,
                               y = (NIE)),
                               fill = "grey") +
 
      geom_point_interactive(
                 aes(x = industry_label,
                     y = (NIS),
                     color = core_fips), 
                     size  = 3.5) +
      labs(x = "Industry Sector", y = "Input Value") +
      scale_y_continuous() +
       labs(title = "Absorption Distribution Capacitance",
            subtitle = glue("Net Input Excess: {county}"),
            color = "Net Import Shortage") +

       scale_colour_brewer(palette = "Set3", labels = (TIGER_RUCC %>% filter(TIGER_RUCC$FIPS %in% primary_extent) %>% pull(COUNTY)) ) +
       theme_minimal() +
        theme(axis.text.x = element_text(angle=45, hjust=1))
    }
}

print(ggtop[[3]]$`55043`)


```





```{r}
# 
# primary_c <- vector(mode='list', length=length(Total_mat))
# names(primary_c) <- industry_levels
# 
# test_industry <- vector(mode='list', length=length(Total_mat))
# names(test_industry) <- industry_levels
# 
# for (l in 1:length(Total_mat)){
#     primary_c[[l]] <- Input_mat_imp[[l]][, names(primary_extent)] %>% as.data.frame() %>% select(order(colnames(.)))
#     primary_c[[l]] <- cbind(industry = seq_along(primary_c[[l]][,1]), primary_c[[l]])
#     primary_c[[l]] <- melt(primary_c[[l]], id = "industry")
# }
# 
# for (l in 1:length(Total_mat)){
#   for (p in 1:length(rural_extent)){
#     test_industry[[l]][[p]] <- Input_mat_exp[[l]][, rural_extent][, p] %>% as.data.frame()
#     colnames( test_industry[[l]][[p]]) <- c("value")
#     test_industry[[l]][[p]] <- cbind(industry = seq_along(test_industry[[l]][[p]][,1]),  test_industry[[l]][[p]])
#   }
#   names( test_industry[[l]]) <- colnames(Input_mat_exp[[l]][, rural_extent])
# }
# 
# ggbase <- test_industry
# 
# for (l in 1:length(Total_mat)){
#   for (p in 1:length(rural_extent)){
#     county <- TIGER_RUCC %>% filter(TIGER_RUCC$FIPS %in% rural_extent[p]) %>% pull(COUNTY)
#      ggbase[[l]][[p]] <- ggplot(as.data.frame(test_industry[[l]][[p]])) +
#       geom_col_interactive(aes(x = industry,
#                                y = (value)),
#                                fill = "grey") +
#       geom_point_interactive(data = filter(primary_c[[l]], value != 0),
#                  aes(x = industry,
#                      y = (value),
#                      color = variable), 
#                      size  = 3.5) +
#       labs(x = "Industry Sector", y = "Input Value") +
#       scale_x_discrete(limits = factor(1:dim(Input_mat_exp[[l]])[1]), labels = c(rownames(Input_mat_exp[[l]]))) +
#       scale_y_continuous() +
#        labs(title = "Absorption Distribution Capacitance",
#             subtitle = glue("Net Input Excess: {county}"),
#             color = "Net Import Shortage") +
#        scale_colour_brewer(palette = "Set1", labels = (TIGER_RUCC %>% filter(TIGER_RUCC$FIPS %in% primary_extent) %>% pull(COUNTY)) ) +
#        theme_minimal()
#     }
# }
# 


#print(ggbase[[1]]$`55027`)

```




*First-level Hierarchical Matching*

```{r hierarchical queeg maps}

if (!file.exists(file.path(data_dir, "WI_Queeg_Plots_H1_XINT"))){
  if (!exists("WI_Queeg_Plots_H1")){
    cmapr(WI_Queeg_Plots_H1)
  }
  if (!exists("WI_Queeg_Plots_H1_XINT")){
    dismapr(WI_Queeg_Plots_H1)
  }
  saver(WI_Queeg_Plots_H1_XINT)
} else {
  importr(WI_Queeg_Plots_H1_XINT)
}

```

"Queeg distance": $\arg \max_{l} \{\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}\}~ \forall ~ r,s \in l$

```{r}
WI_Queeg_Plots_H1_XINT[[1]] 
```

"Relative Queeg distance":  $\arg \max_{l} \{\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}/\mathbf{i'}\text{NIE}^{r}\}~ \forall ~ r,s \in l$

```{r}
WI_Queeg_Plots_H1_XINT[[2]] 
```

```{r}
rm(WI_Queeg_Plots_H1, WI_Queeg_Plots_H1_XINT) %>% suppressWarnings()
```



```{r hierarchical new total output  }

Xpay_mat_H1 <- vector(mode='list', length=length(Total_mat))
names(Xpay_mat_H1) <- industry_levels

WISim <- Xpay_mat_H1
NoMatch <- Xpay_mat_H1
MatMat <- Xpay_mat_H1
WI_match <- Xpay_mat_H1

Pmatch <- diag(rep(c(1), each=length(primary_extent)))
colnames(Pmatch) = rownames(Pmatch) <- primary_extent
  
  for (l in 1:length(WISim)){
    
    WISim[[l]] <- (Queeg_list[[2]][[l]][rural_extent, primary_extent] * Impede_mat[[3]][[l]][rural_extent, primary_extent]) %>% 
                     as.data.frame() %>% filter( rowSums(.) != 0) %>% as.matrix()
    NoMatch[[l]] <- Queeg_list[[2]][[l]][rural_extent, primary_extent] %>%
                     as.data.frame() %>% filter( rowSums(.) == 0) %>% as.matrix()

    MatMat[[l]] <- cbind(
                    rbind(WISim[[l]], 
                          Pmatch, 
                          NoMatch[[l]]
                          ), 
                    rbind(matrix(0, dim(rbind(WISim[[l]], Pmatch))[1], dim(NoMatch[[l]])[1]), 
                          diag(rep(c(1), each=dim(NoMatch[[l]])[1]))
                          ) 
                    )
    colnames(MatMat[[l]]) <- c(colnames(WISim[[l]]), rownames(NoMatch[[l]]))

    WI_match[[l]] <- sparseMatrix(i = match(rownames(MatMat[[l]]), rownames(MatMat[[l]])),
                                  j = match(c(colnames(MatMat[[l]])[apply(MatMat[[l]], 1, which.max)]), colnames(MatMat[[l]])),
                                  x = 1L,
                                  dims = c(nrow(MatMat[[l]]), ncol(MatMat[[l]])),
                                  dimnames = list(rownames(MatMat[[l]]), colnames(MatMat[[l]]))
                                   ) %>% as.matrix()
    
    WI_match[[l]] <- WI_match[[l]][order(rownames(WI_match[[l]])),]
  }
    
    ```












```{r}



    
L2_extent <- c("27053", "55025", "55031", "55079", "55089", "55131", "55133")
  


for (l in 1:length(Xpay_mat)){

    Xpay_mat_H1[[l]] <- cbind(Xpay_mat[[l]][, all_extent[order(all_extent)]] %*% 
                              WI_match[[l]][all_extent[order(all_extent)], primary_extent[order(primary_extent)]], 
                              Xpay_mat[[l]][, rural_extent[order(rural_extent)]],
                              Xpay_mat[[l]][, L2_extent[order(L2_extent)]])
    
    Xpay_mat_H1[[l]] <- Xpay_mat_H1[[l]][, order(colnames(Xpay_mat_H1[[l]]))] 
  
}

```


```{r}

############ Input Needs
if (!file.exists(file.path(data_dir, "Input_mat_H1"))){

  Input_mat_H1 <- vector(mode='list', length=length(Total_mat))
  names(Input_mat_H1) <- industry_levels

    for (l in 1:length(Input_mat_H1)){
      Input_mat_H1[[l]] <- (Direct_mat[[l]]  %*%  Xpay_mat_H1[[l]])
    }

  saver(Input_mat_H1)

}

############ Import Input Needs
if (!file.exists(file.path(data_dir, "Input_mat_imp_H1"))){

  Input_mat_imp_H1 <- vector(mode='list', length=length(Total_mat))
  names(Input_mat_imp_H1) <- industry_levels

    for (l in 1:length(Input_mat_imp_H1)){
      Input_mat_imp_H1[[l]] <- pmax(Input_mat_H1[[l]] - Xpay_mat_H1[[l]], 0)
    }

  saver(Input_mat_imp_H1)

}


############ Net Exports
if (!file.exists(file.path(data_dir, "Input_mat_exp_H1"))){

  Input_mat_exp_H1 <- vector(mode='list', length=length(Total_mat))
  names(Input_mat_exp_H1) <- industry_levels

    for (l in 1:length(Input_mat_exp_H1)){
      Input_mat_exp_H1[[l]] <- pmax(Xpay_mat_H1[[l]] - Input_mat_H1[[l]], 0)
    }

  saver(Input_mat_exp_H1)

}


```




```{r}

  importr(Input_mat_exp_H1)
  importr(Input_mat_imp_H1)
  
H2_con <- vector(mode='list', length=length(Total_mat))
names(H2_con) <- industry_levels
excess <- H2_con 
shortage <- H2_con 
  
  for (l in 1:length(H2_con)){
    H2_con[[l]] <- rbind(data.frame(place = rownames(WI_match[[l]]), match  = colnames(WI_match[[l]])[apply(WI_match[[l]], 1, which.max)]), 
                        as.data.frame(cbind(place = L2_extent, 
                                            match = L2_extent)
                                )
                  )
    H2_con[[l]] <- H2_con[[l]][order(H2_con[[l]]$place),]
    
    excess[[l]]  <- Input_mat_exp_H1[[l]][,  match(H2_con[[l]]$match, colnames(Input_mat_exp_H1[[l]]))]
    colnames(excess[[l]]) <- H2_con[[l]]$place
    
    shortage[[l]]  <- Input_mat_imp_H1[[l]][,  match(H2_con[[l]]$match, colnames(Input_mat_imp_H1[[l]]))]
    colnames(shortage[[l]]) <- H2_con[[l]]$place
  }





############  Queeg specification
if (!file.exists(file.path(data_dir, "Queeg_H1"))){
  


  Queeg_H1 <- vector(mode='list', length=length(Total_mat))
  names(Queeg_H1) <- industry_levels

  for (l in 1:length(Queeg_H1)){
    Queeg_H1[[l]] <-  matrix(0, nrow = ncol(Xpay_mat_H1[[l]]), 
                                ncol = ncol(Xpay_mat_H1[[l]]) )
    rownames(Queeg_H1[[l]]) = colnames(Queeg_H1[[l]]) <- colnames(Xpay_mat_H1[[l]])
  }

  for (l in 1:length(Queeg_H1)){
    for (i in 1:nrow(Queeg_H1[[l]])){
      for (j in 1:nrow(Queeg_H1[[l]])){
        Queeg_H1[[l]][i,j]  <- rep(c(1), each=ncol(Total_mat[[l]])) %*% 
                                pmin(excess[[l]][,i], shortage[[l]][,j])
        
        
      }
    }
  }

  saver(Queeg_H1)
}


############ Relative Queeg specification
if (!file.exists(file.path(data_dir, "Queeg_rel_H1"))){
  
  Queeg_rel_H1 <- vector(mode='list', length=length(Total_mat))
  names(Queeg_rel_H1) <- industry_levels

  for (l in 1:length(Queeg_rel_H1)){
    Queeg_rel_H1[[l]] <-  matrix(0, nrow = ncol(Xpay_mat_H1[[l]]), 
                                ncol = ncol(Xpay_mat_H1[[l]]) )
    rownames(Queeg_rel_H1[[l]]) = colnames(Queeg_rel_H1[[l]]) <- colnames(Xpay_mat_H1[[l]])
  }

  for (l in 1:length(Queeg_rel_H1)){
    for (i in 1:nrow(Queeg_rel_H1[[l]])){
      for (j in 1:nrow(Queeg_rel_H1[[l]])){
        Queeg_rel_H1[[l]][i,j] <- (rep(c(1), each=ncol(Total_mat[[l]])) %*% 
                                   pmin(excess[[l]][,i], shortage[[l]][,j])) / 
                                   (rep(c(1), each=ncol(Total_mat[[l]])) %*% 
                                    excess[[l]][,i])
      }
    }
  }

  saver(Queeg_rel_H1)
}

```



*Second Stage Matching: All WI to Cook and Hennepin*

```{r second stage matching}



# rural_extent <- grep("^55", rownames(TIGER_RUCC), value=TRUE) %>%
#                 grep("55009", ., value=TRUE, invert = TRUE) %>% 
#                   grep("55025", ., value=TRUE, invert = TRUE) %>%
#                   grep("55031", ., value=TRUE, invert = TRUE) %>%
#                 grep("55035", ., value=TRUE, invert = TRUE) %>%
#                 grep("55039", ., value=TRUE, invert = TRUE) %>%
#                 grep("55059", ., value=TRUE, invert = TRUE) %>%
#                 grep("55063", ., value=TRUE, invert = TRUE) %>% 
#                 grep("55073", ., value=TRUE, invert = TRUE) %>%
#                   grep("55079", ., value=TRUE, invert = TRUE) %>%
#                 grep("55087", ., value=TRUE, invert = TRUE) %>% 
#                   grep("55089", ., value=TRUE, invert = TRUE) %>% 
#                 grep("55105", ., value=TRUE, invert = TRUE) %>% 
#                 grep("55117", ., value=TRUE, invert = TRUE) %>%
#                   grep("55131", ., value=TRUE, invert = TRUE) %>% 
#                   grep("55133", ., value=TRUE, invert = TRUE) %>% 
#                 grep("55139", ., value=TRUE, invert = TRUE)
# 
#   
# hold_extent <- c("55025", "55031", "55079", "55089", "55131", "55133")
# 
# primary_extent <- c("55009","55035", "55039", "55059", "55063","55073", "55087", "55105", "55117", "55139")
# names(primary_extent) <- primary_extent
# 
# all_extent <- c(rural_extent, primary_extent) %>% as.vector()
# 
#     
# L2_extent <- c("17031","27053", "55025", "55031", "55079", "55089", "55131", "55133")
#   
# 
# 




rural_extent <- grep("^55", rownames(TIGER_RUCC), value=TRUE)  %>%
                  grep("55025", ., value=TRUE, invert = TRUE) %>%
                  grep("55031", ., value=TRUE, invert = TRUE) %>%
                  grep("55079", ., value=TRUE, invert = TRUE) %>%
                  grep("55089", ., value=TRUE, invert = TRUE) %>%
                  grep("55131", ., value=TRUE, invert = TRUE) %>% 
                  grep("55133", ., value=TRUE, invert = TRUE)

primary_extent <- c("17031","27053", "55025", "55079")

all_extent <- c(rural_extent, primary_extent) %>% as.vector()

```


```{r }

if (!file.exists(file.path(data_dir, "WI_Queeg_Plots_C2_XINT"))){
  if (!exists("WI_Queeg_Plots_C2")){
    cmapr(WI_Queeg_Plots_C2)
  }
  if (!exists("WI_Queeg_Plots_C2_XINT")){
    dismapr(WI_Queeg_Plots_C2)
  }
  saver(WI_Queeg_Plots_C2_XINT)
} else {
  importr(WI_Queeg_Plots_C2_XINT)
}

```


"Queeg distance": $\arg \max_{l} \{\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}\}~ \forall ~ r,s \in l$

```{r}
WI_Queeg_Plots_C2_XINT[[1]] 
```

"Relative Queeg distance":  $\arg \max_{l} \{\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}/\mathbf{i'}\text{NIE}^{r}\}~ \forall ~ r,s \in l$


```{r}
WI_Queeg_Plots_C2_XINT[[2]] 
```

```{r}
rm(WI_Queeg_Plots_C2, WI_Queeg_Plots_C2_XINT) %>% suppressWarnings()
```


*Second-level Hierarchical Capacitance*

```{r}





rural_extent <- grep("^55", rownames(TIGER_RUCC), value=TRUE)  %>%
                  grep("55025", ., value=TRUE, invert = TRUE) %>%
                  grep("55031", ., value=TRUE, invert = TRUE) %>%
                  grep("55079", ., value=TRUE, invert = TRUE) 

primary_extent <- c("27053", "55025", "55079")

all_extent <- c(rural_extent, primary_extent) %>% as.vector()



importr(Queeg_H1)
importr(Queeg_rel_H1)

Queeg_list_H1 <- list(Queeg_H1, Queeg_rel_H1)
names(Queeg_list_H1) <- c("Queeg_H1",  "Queeg_rel_H1")



if (!file.exists(file.path(data_dir, "WI_Queeg_Plots_H2_XINT"))){
  if (!exists("WI_Queeg_Plots_H2")){
    cmapr(WI_Queeg_Plots_H2, list_of_sim_specifications = Queeg_list_H1)
  }
  if (!exists("WI_Queeg_Plots_H2_XINT")){
    dismapr(WI_Queeg_Plots_H2)
  }
  saver(WI_Queeg_Plots_H2_XINT)
} else {
  importr(WI_Queeg_Plots_H2_XINT)
}

```

"Queeg distance": $\arg \max_{l} \{\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}\}~ \forall ~ r,s \in l$

```{r}
WI_Queeg_Plots_H2_XINT[[1]] 
```

"Relative Queeg distance":  $\arg \max_{l} \{\mathbf{i'}\min\{\text{NIE}^{r}, \text{NIS}^{s} \}/\mathbf{i'}\text{NIE}^{r}\}~ \forall ~ r,s \in l$

```{r}
WI_Queeg_Plots_H2_XINT[[2]] 
```

```{r}
rm(WI_Queeg_Plots_H2, WI_Queeg_Plots_H2_XINT) %>% suppressWarnings()
```




```{r}
# 
# importr(Input_mat_imp)
# importr(Input_mat_exp)


primary_c <- vector(mode='list', length=length(Total_mat))
names(primary_c) <- industry_levels

test_industry <- vector(mode='list', length=length(Total_mat))
names(test_industry) <- industry_levels

for (l in 1:length(Total_mat)){
    primary_c[[l]] <- Input_mat_imp[[l]][, primary_extent] %>% as.data.frame() %>% select(order(colnames(.)))
    primary_c[[l]]$industry_label <- rownames(primary_c[[l]])
    primary_c[[l]] <- melt(primary_c[[l]], id = "industry_label") %>% rename(NIS = value, core_fips = variable) 
}

for (l in 1:length(Total_mat)){
  for (p in 1:length(rural_extent)){
    test_industry[[l]][[p]] <- Input_mat_exp[[l]][, rural_extent][, p] %>% as.data.frame()
    colnames( test_industry[[l]][[p]]) <- c("NIE")
    test_industry[[l]][[p]]$industry_label <- rownames(test_industry[[l]][[p]])
  }
  names( test_industry[[l]]) <- colnames(Input_mat_exp[[l]][, rural_extent])
}

ggbase <- test_industry
ggtop <- test_industry


df <- vector(mode='list', length=length(Total_mat))
names(df) <- industry_levels

test <- vector(mode='list', length=length(Total_mat))
names(test) <- industry_levels

for (l in 1:length(Total_mat)){
  for (p in 1:length(rural_extent)){
    df[[l]][[p]] <- inner_join(test_industry[[l]][[p]], primary_c[[l]], by = "industry_label") %>% arrange(core_fips, industry_label) 
    df[[l]][[p]]$absorb <- pmin(df[[l]][[p]]$NIE, df[[l]][[p]]$NIS)
    test[[l]][[p]] <- df[[l]][[p]] %>% filter(absorb > 0) %>% group_by(core_fips) %>% slice_max(order_by = absorb, n = 7) %>% arrange(core_fips)
  }
}


for (l in 3){
  for (p in 1:length(rural_extent)){
    county <- TIGER_RUCC %>% filter(TIGER_RUCC$FIPS %in% rural_extent[p]) %>% pull(COUNTY)
     ggtop[[l]][[p]] <- ggplot(test[[l]][[p]]) +
      geom_col_interactive(aes(x = industry_label,
                               y = (NIE)),
                               fill = "grey") +
 
      geom_point_interactive(
                 aes(x = industry_label,
                     y = (NIS),
                     color = core_fips), 
                     size  = 3.5) +
      labs(x = "Industry Sector", y = "Input Value") +
      scale_y_continuous() +
       labs(title = "Absorption Distribution Capacitance",
            subtitle = glue("Net Input Excess: {county}"),
            color = "Net Import Shortage") +

       scale_colour_brewer(palette = "Set3", labels = (TIGER_RUCC %>% filter(TIGER_RUCC$FIPS %in% primary_extent) %>% pull(COUNTY)) ) +
       theme_minimal() +
        theme(axis.text.x = element_text(angle=45, hjust=1))
    }
}

print(ggtop[[3]]$`55043`)


```









```{r second hierarchical extent}


# 
# spacet <- TIGER_RUCC %>% filter(TIGER_RUCC$FIPS %in% c(names(L2_extent), all_extent))
# test  <-  st_union(filter(spacet, spacet$FIPS %in% "55043"), filter(spacet, spacet$FIPS %in% "55133"))
# ggplot(test) + geom_sf()
# 
# spacet <- left_join(filter(TIGER_RUCC, TIGER_RUCC$FIPS %in% c(names(L2_extent), all_extent)),  
#           data.frame(place = rownames(WI_match$Sector), match  = colnames(WI_match$Sector)[apply(WI_match$Sector, 1, which.max)]), by = "place", copy = TRUE )
# spacet$match[is.na(spacet$match)] <- spacet %>% filter(is.na(spacet$match)) %>% pull(place)
# 
# 
# 
# test  <- data.frame(matrix(NA, nrow = 0, ncol = ncol(spacet)  ))
# #test  <- spacet
# colnames(test) <- colnames(spacet) 
# for (l in unique(spacet$match)){
#  test[nrow(test) + 1, ] <- st_union(filter(spacet, spacet$match == l),  by_feature = TRUE)   
# }
# #test <- test[75:90,]
# View(test)
# 
# 
# test  <-  st_union(st_union(filter(spacet, spacet$match == "55089")), st_union(filter(spacet, spacet$match == "55131")), by_feature = TRUE)
# 
# test  <-  st_union(filter(spacet, spacet$match == "55089"))
# ggplot(test) + geom_sf()
# 




```



Note: two-level hierarchy is not the same as two-stage matching




FIN
::: 
















