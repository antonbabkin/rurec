---

title: Adding rurality measures to InfoGroup


keywords: fastai
sidebar: home_sidebar

summary: "Merge different definitions of rurality."
description: "Merge different definitions of rurality."
nb_path: "nbs/rurality.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/rurality.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%(asctime)s</span><span class="s1"> </span><span class="si">%(levelname)s</span><span class="s1">:</span><span class="se">\n</span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">resources</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Resource</span><span class="p">(</span><span class="s1">&#39;infogroup/rural&#39;</span><span class="p">,</span> <span class="s1">&#39;/InfoGroup/data/processed/rural.pq&#39;</span><span class="p">,</span> <span class="s1">&#39;InfoGroup with rural columns&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Resource &#34;infogroup/rural&#34; added to registry.
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Outside-of-Urban-Area">Outside of Urban Area<a class="anchor-link" href="#Outside-of-Urban-Area"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The Census Bureau's concept of Urban Area includes two urban categories: the more densely
populated Urbanized Area and the Urban Cluster. See the gazetteer for the details of 
definition. Urban Areas are not defined in terms of any other standard spatial unit. The
borders of an urban area are defined by the density of commuting patterns in the orbit of
urban cores of various population size.</p>
<p>InfoGroup does not include the code for the Urbanized Area or Urban Cluster in which an
establishment may be located. The Bureau does distribute a shapefile for Urban Areas. It
would therefore be possible in theory to locate each establishment's locational coordinates
in an Urban Area or to determine that it is not included in any Urban Area. However, this 
would be 1) an incredibly CPU-intensive process; and 2) probably irrelevant since we are
concerned mostly with InfoGroup establishments in rural areas.</p>
<p>However, because we do have an establishment's census tract code on the InfoGroup record, 
we can determine with just barely imperfect accuracy whether an establishment is
located in a census tract that is itself centered in an Urban Area or non-urban territory.</p>
<p>We have created a geo-reference file starting with shapefiles for Urban Areas and census 
tracts. The centroid location of each census tract was computed and from that data point 
and the coordinate dimensions of each urban area, the 'parental' urban area, if any,
of each census tract was determined. This was an extrememly machine-intensive process itself.</p>
<h3 id="rural_outside_UA,-UA-Code,-UA-Type">rural_outside_UA, UA Code, UA Type<a class="anchor-link" href="#rural_outside_UA,-UA-Code,-UA-Type"> </a></h3><p>The 'rural_outside_UA' variable identifies tracts that are not located within a Census Bureau 
Urban Area. More precisely, if the spatial centroid of the InfoGroup establishment's census 
tract is not located within the polygon of coordinates that defines an Urban Area, the 
establishment is considered 'rural' and coded '1'. In the 2017 file, 3,596,102 establishments,
24.5% of the total, were flagged 'rural' by this measure.</p>
<p>For the 'urban' establishments (coded '0' on 'rural_outside_UA') we also take the Census code 
for its 'parental' Urban Area ('UA Code') and the code for the parental urban area's type 
('UA Type'): 'U' = Urbanized Area, 'C' = Urban Cluster.</p>
<p>The accuracy of these three variables is 'just barely imperfect' because a census
tract can overlap multiple urban (or non-urban) areas. It is therefore not necessarily 
true that the urban area pinpointed by the centroid of the census tract is the one in which 
the InfoGroup establishment itself is actually located, although in nearly every case it 
would be.</p>
<p>Our locally processed geo-reference file 
('/InfoGroup/data/rurality/reference/geographical/points-in-polygons/data/all_tracts.csv')
consists of one record per 2010 census tract, with the following variables:
    'STATEFP', 'COUNTYFP', 'TRACTCE', 'GEOID', 'NAME', 'NAMELSAD', 'MTFCC',
    'FUNCSTAT', 'ALAND', 'AWATER', 'INTPTLAT', 'INTPTLON', 'geometry',
    'UA_GEOID10', 'UATYP10', 'rural_tract'
'STATEFP' through 'geometry' are simply taken from the Census Bureau's shapefile. 
'GEOID' is the file's 11-digit census tract identifier. 'UA-GEOID10' and 'UATYP10' are the 
Urban Area identifier and the Urban Area type code taken from the Urban Area shapefile, and 
'rural_tract' is the laboriously computed rurality flag for each census tract renamed to
'rural_outside_UA' in the InfoGroup record to distinguish it from other such indicator
variables to be created in step 3.</p>
<p>Having created this file at an earlier time, adding the last three variables to the InfoGroup
record was simply a matter of a pandas dataframe merge, where 'df' is the InfoGroup dataframe
and 'tract_df' is the dataframe created from 'all_tracts.csv'.</p>
<p>'all_tracts.csv' is a locally processed file starting with shapefiles for Urban Areas 
and census tracts. The centroid location of each census tract was computed and from that 
data point and the coordinate dimensions of each urban area, the 'parental' urban area, if 
any, of each census tract was determined. This was an extrememly machine-intensive process.</p>
<p>Urban Areas and census tracts are defined by entirely different criteria. Even though
census tracts are on average much smaller than urban areas, each can overlap several of the 
other. The purpose here is to identify 'rural' census tracts, defined as those whose centroid point does not fall within any urban area. A census tract has a 'parental' urban
area if its centroid point does fall within an urban area, either an urbanized area or a
smaller urban cluster.</p>
<p>The all_tracts.csv file contains one record per census tract and the identifying information 
for the single 'parental' urban area, if there is one. The records for rural tracts are 
coded '1' in the 'rural_tract' variable, which indicates a missing value for the Urban
Area identifier, 'UA_GEOID10'. 'UATYP10' identifies the type of the parental urban area: 
'U' = urbanized area, 'C'= urban cluster.</p>
<p>This file is the source data for the 'rural_outside_UA' variable added in this step to the
basic InfoGroup extract created in step 1. It is also the source for the 'UA Code' and
'UA Type' variables, understood to apply to the 'parental' urban area. Since a census
tract can overlap multiple urban areas, it is not necessarily true that the urban area
identified by the 'UA Code' and 'UA Type' variables is the one in which the InfoGroup
establishment itself is actually located, though in nearly every case it would be.</p>
<p>It would be possible to locate each InfoGroup record in an urban area by computing whether
the establishment's spatial coordinates lie within the polygon of coordinates specified in
the urban area shapefile. However, our focus is on the rural economy and that computation,
for all establishments over two decades, would consume an extraordinary amount of calendar 
time and computational resources.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="prepare_outside_ua_df" class="doc_header"><code>prepare_outside_ua_df</code><a href="https://github.com/antonbabkin/rurec/tree/master/rurec/rurality.py#L35" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>prepare_outside_ua_df</code>()</p>
</blockquote>
<p>Memoized version of prepare_outside_ua_df()</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="ERS-Measures-of-Urban-Spatial-Effect">ERS Measures of Urban Spatial Effect<a class="anchor-link" href="#ERS-Measures-of-Urban-Spatial-Effect"> </a></h2><p>The ERS's three measures of urban influence and spatial effect are the Urban Influence codes,
the Urban-Rural Continuum codes, and the Urban-Rural Commuting Area codes. These measures
are applied to the InfoGroup record by simple pandas merges as described below. The source
files are downloaded as Excel spreadsheets and processed into csv text files and finally
read into pandas dataframes.</p>
<p>The ERS has created files of all three codes for a variety of years. The unit of analysis
for the Urban Influence codes and the Rural-Urban Continuum codes is the county. For the
Rural-Urban Commuting Area codes the unit of analysis is the census tract.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>ERS classifications are created for a number of years. We choose the nearest classification
year when merging to a particular year of InfoGroup.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="nearest_gridpoint" class="doc_header"><code>nearest_gridpoint</code><a href="https://github.com/antonbabkin/rurec/tree/master/rurec/rurality.py#L46" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>nearest_gridpoint</code>(<strong><code>x</code></strong>, <strong><code>grid</code></strong>)</p>
</blockquote>
<p>Return value from <code>grid</code> that is nearest to <code>x</code>.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">assert</span> <span class="n">nearest_gridpoint</span><span class="p">(</span><span class="mi">1999</span><span class="p">,</span> <span class="p">[</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">2003</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2000</span>
<span class="k">assert</span> <span class="n">nearest_gridpoint</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="p">[</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">2003</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2000</span>
<span class="k">assert</span> <span class="n">nearest_gridpoint</span><span class="p">(</span><span class="mi">2001</span><span class="p">,</span> <span class="p">[</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">2003</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2000</span>
<span class="k">assert</span> <span class="n">nearest_gridpoint</span><span class="p">(</span><span class="mi">2002</span><span class="p">,</span> <span class="p">[</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">2003</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2003</span>
<span class="k">assert</span> <span class="n">nearest_gridpoint</span><span class="p">(</span><span class="mi">2010</span><span class="p">,</span> <span class="p">[</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">2003</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2003</span>
<span class="c1"># unsorted grid</span>
<span class="k">assert</span> <span class="n">nearest_gridpoint</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="p">[</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">1995</span><span class="p">,</span> <span class="mi">2001</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2001</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="UI_CODE">UI_CODE<a class="anchor-link" href="#UI_CODE"> </a></h3><p><a href="https://www.ers.usda.gov/data-products/">https://www.ers.usda.gov/data-products/</a>:
"The 2013 Urban Influence Codes form a classification scheme that distinguishes metropolitan 
counties by population size of their metro area, and nonmetropolitan counties by size of the 
largest city or town and proximity to metro and micropolitan areas. The standard Office of 
Management and Budget (OMB) metro and nonmetro categories have been subdivided into two 
metro and 10 nonmetro categories, resulting in a 12-part county classification."</p>
<p>See <a href="https://www.ers.usda.gov/data-products/urban-influence-codes/">https://www.ers.usda.gov/data-products/urban-influence-codes/</a>.
Urban Influence codes "form a classification scheme that distinguishes metropolitan counties
by population size of their metro area, and nonmetropolitan counties by size of the largest 
city or town and proximity to metro and micropolitan areas. The standard Office of Management 
and Budget (OMB) metro and nonmetro categories have been subdivided into two metro and 10 
nonmetro categories, resulting in a 12-part county classification."</p>
<p>There are separate ERS collections of Urban Influence codes for 1974, 1983, 1993, 2001, 
and 2013. Having chosen a single year of data as appropriate for the particular year or 
years of InfoGroup data, the command to apply UI_CODE to the InfoGroup record, where
'df' is the dataframe of InfoGroup data and 'ui_df' is the dataframe of Urban Influence data,
is:
    merged = df.merge(ui_df,how='inner',left_on='FIPS Code',right_on='FIPS')</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="prepare_ui_df" class="doc_header"><code>prepare_ui_df</code><a href="https://github.com/antonbabkin/rurec/tree/master/rurec/rurality.py#L56" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>prepare_ui_df</code>(<strong><code>year</code></strong>)</p>
</blockquote>
<p>Memoized version of prepare_ui_df(year)</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="RUC_CODE">RUC_CODE<a class="anchor-link" href="#RUC_CODE"> </a></h3><p><a href="https://www.ers.usda.gov/data-products/">https://www.ers.usda.gov/data-products/</a>:
"The 2013 Rural-Urban Continuum Codes form a classification scheme that distinguishes 
metropolitan counties by the population size of their metro area, and nonmetropolitan 
counties by degree of urbanization and adjacency to metro areas. The official Office of 
Management and Budget (OMB) metro and nonmetro categories have been subdivided into three
metro and six nonmetro categories. Each county in the U.S. and Puerto Rico is assigned one 
of the 9 codes."</p>
<p>See <a href="https://www.ers.usda.gov/data-products/rural-urban-continuum">https://www.ers.usda.gov/data-products/rural-urban-continuum</a> codes/. 
Rural-Urban Continuum codes "form a classification scheme that distinguishes metropolitan 
counties by the population size of their metro area, and nonmetropolitan counties by degree 
of urbanization and adjacency to a metro area. The official Office of Management and Budget 
(OMB) metro and nonmetro categories have been subdivided into three metro and six nonmetro 
categories. Each county in the U.S. is assigned one of the 9 codes."</p>
<p>There are separate ERS collections of Rural-Urban Continuum codes for 1993, 2003, and 2013.
Having first chosen a single year of RUC data, the command to apply RUC_CODE to the InfoGroup 
record, where is:
    merged = df.merge(ruc_df,how='inner',left_on='FIPS Code',right_on='FIPS')</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="prepare_ruc_df" class="doc_header"><code>prepare_ruc_df</code><a href="https://github.com/antonbabkin/rurec/tree/master/rurec/rurality.py#L66" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>prepare_ruc_df</code>(<strong><code>year</code></strong>)</p>
</blockquote>
<p>Memoized version of prepare_ruc_df(year)</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="RUCA_CODE">RUCA_CODE<a class="anchor-link" href="#RUCA_CODE"> </a></h3><p>See <a href="https://www.ers.usda.gov/data-products/rural-urban-commuting-area-codes/">https://www.ers.usda.gov/data-products/rural-urban-commuting-area-codes/</a>.
Rural-Urban Commuting Area codes "classify U.S. census tracts using measures of population 
density, urbanization, and daily commuting....The classification contains two levels. Whole 
numbers (1-10) delineate metropolitan, micropolitan, small town, and rural commuting areas 
based on the size and direction of the primary (largest) commuting flows. These 10 codes are 
further subdivided based on secondary commuting flows, providing flexibility in combining 
levels to meet varying definitional needs and preferences."</p>
<p>There are separate ERS collections of Rural-Urban Commuting Area codes for 1990, 2000, 
and 2010. The three years of RUCA codes "are not directly comparable because many census 
tracts are reconfigured during each decade. Also, changes to census methodologies 
significantly affected the RUCA classifications."</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="prepare_ruca_df" class="doc_header"><code>prepare_ruca_df</code><a href="https://github.com/antonbabkin/rurec/tree/master/rurec/rurality.py#L77" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>prepare_ruca_df</code>(<strong><code>year</code></strong>)</p>
</blockquote>
<p>Memoized version of prepare_ruca_df(year)</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>First choose the appropriate year, then match as below:</p>
<ol>
<li><p>Match 'FIPS' in /ers/ui/ui.csv to 'FIPS Code' (county level) in InfoGroup. 
'UI_YEAR' in ui.csv has the values [1974,1983,1993,2001,2013].</p>
</li>
<li><p>Match 'FIPS' in /ers/ruc/ruc.csv to 'FIPS Code' in InfoGroup.
'RUC_YEAR' in ruc.csv has the values [1993,2003,2013].</p>
</li>
<li><p>Match 'FIPS' in /ers/ruca/ruca.csv to 'Full Census Tract' in InfoGroup.
'YEAR' in ruca.csv has the values [1990,2000,2010].</p>
</li>
</ol>
<p>For example:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="rural_HRSA">rural_HRSA<a class="anchor-link" href="#rural_HRSA"> </a></h2><p>Like the 'rural_outside_UA' variable created in step 2, this variable is an 1/0 flag 
indicating rurality at the census tract level.</p>
<p>HRSA refers to the Health Resources and Services Administration. It is particularly its
sub-unit, the Federal Office of Rural Health Policy (FORHP), that is responsible for this
definition of rurality. For its own administrative purposes it considers a census tract to
be rural if it is contained within a county that is not part of a CBSA. To these, they add
2,302 census tracts from CBSA counties that they have specially defined as rural by applying
the RUCA criteria, of which the FORHP was actually a developer in its early phase.</p>
<p>In the 2017 file, 1,277,342 establishments, 8.7% of the total, were flagged 'rural' by this 
measure, about 1/3 the incidence of rurality measured by the 'rural_outside_UA' variable.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="gen_rural_hrsa" class="doc_header"><code>gen_rural_hrsa</code><a href="https://github.com/antonbabkin/rurec/tree/master/rurec/rurality.py#L88" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>gen_rural_hrsa</code>(<strong><code>df</code></strong>)</p>
</blockquote>
<p>Return bool column of rurality by HRSA definition for all establishments in <code>df</code>.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_hrsa_rural_in_cbsa" class="doc_header"><code>get_hrsa_rural_in_cbsa</code><a href="https://github.com/antonbabkin/rurec/tree/master/rurec/rurality.py#L97" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_hrsa_rural_in_cbsa</code>()</p>
</blockquote>
<p>Return list of tracts that are in CBSA, but rural by HRSA definition.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="FAR-Level">FAR Level<a class="anchor-link" href="#FAR-Level"> </a></h2><p>The USDA writes: “To assist in providing policy-relevant information about conditions in 
sparsely-settled, remote areas of the U.S. to public officials, researchers, and the general 
public, ERS has developed ZIP-code-level frontier and remote area (FAR) codes”.</p>
<p>FAR codes are applied to postal zip codes to identify different degrees and criteria of 
remoteness. It is not a code for any functional concept of rurality, but there is an obvious 
family resemblance between “remote” and “rural” which might find some analytical use.</p>
<p>The ERS created four FAR levels based on proximity (conceived of as travel time) to 
“urban” places of different sizes. Levels 1 through 4 measure increasing remoteness.
The ‘FAR Level’ variable captures the highest numbered positive FAR level for a location.</p>
<p>In 2017, 659,070 InfoGroup establishments, 4.56% of the total, were located in zip codes
designated far or remote.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_far_df" class="doc_header"><code>get_far_df</code><a href="https://github.com/antonbabkin/rurec/tree/master/rurec/rurality.py#L117" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_far_df</code>()</p>
</blockquote>
<p>Memoized version of get_far_df()</p>
<p>Return dataframe with ERS FAR levels by Zip code.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Merge-and-save-new-dataframe">Merge and save new dataframe<a class="anchor-link" href="#Merge-and-save-new-dataframe"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="add_rural_cols" class="doc_header"><code>add_rural_cols</code><a href="https://github.com/antonbabkin/rurec/tree/master/rurec/rurality.py#L135" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>add_rural_cols</code>(<strong><code>year</code></strong>)</p>
</blockquote>
<p>Load InfoGroup data for one <code>year</code>, add rurality columns and
save as parquet partition.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="build_parquet_dataset" class="doc_header"><code>build_parquet_dataset</code><a href="https://github.com/antonbabkin/rurec/tree/master/rurec/rurality.py#L192" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>build_parquet_dataset</code>(<strong><code>n_cpus</code></strong>=<em><code>1</code></em>)</p>
</blockquote>
<p>Merge rural columns to all years, save and merge parquet partitions.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Interface-for-opening-dataframe">Interface for opening dataframe<a class="anchor-link" href="#Interface-for-opening-dataframe"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_df" class="doc_header"><code>get_df</code><a href="https://github.com/antonbabkin/rurec/tree/master/rurec/rurality.py#L212" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_df</code>(<strong><code>years</code></strong>=<em><code>None</code></em>, <strong><code>cols</code></strong>=<em><code>None</code></em>, <strong><code>states</code></strong>=<em><code>None</code></em>, <strong><code>onlymeta</code></strong>=<em><code>False</code></em>)</p>
</blockquote>
<p>Return InfoGroup with rurality columns as dataframe.
If <code>onlymeta</code> is True, return ParquetFile instead, which can be used
to quickly inspect dataset schema without loading it ("dtypes" attribute).</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

</div>
 

